/* automatically generated by rust-bindgen 0.60.1 */

#![allow(clippy::all)]
#![allow(unknown_lints)]
#![allow(deref_nullptr)]
#![allow(improper_ctypes)]
pub enum GrContext_Base {}
pub enum GrImageContext {}
pub enum GrImageContextPriv {}
pub enum GrContextThreadSafeProxy {}
pub enum GrContextThreadSafeProxyPriv {}
pub enum GrRecordingContextPriv {}
pub enum GrContextPriv {}
pub enum SkVerticesPriv {}

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
pub struct __BindgenUnionField<T>(::core::marker::PhantomData<T>);
impl<T> __BindgenUnionField<T> {
    #[inline]
    pub const fn new() -> Self {
        __BindgenUnionField(::core::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T {
        ::core::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T {
        ::core::mem::transmute(self)
    }
}
impl<T> ::core::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self {
        Self::new()
    }
}
impl<T> ::core::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self {
        Self::new()
    }
}
impl<T> ::core::marker::Copy for __BindgenUnionField<T> {}
impl<T> ::core::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
impl<T> ::core::hash::Hash for __BindgenUnionField<T> {
    fn hash<H: ::core::hash::Hasher>(&self, _state: &mut H) {}
}
impl<T> ::core::cmp::PartialEq for __BindgenUnionField<T> {
    fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
        true
    }
}
impl<T> ::core::cmp::Eq for __BindgenUnionField<T> {}
pub type std_integral_constant_value_type<_Tp> = _Tp;
pub type std_integral_constant_type = u8;
pub type std_true_type = u8;
pub type std__If = u8;
pub type std__Or = u8;
pub type std_conditional_type<_If> = _If;
pub type std_streampos = std_fpos<mbstate_t>;
pub type std_streamoff = ::std::os::raw::c_longlong;
pub type std_string = [u64; 3usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_tuple {
    pub _address: u8,
}
pub type std_tuple__BaseT = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_tuple__IsThisTuple {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_tuple__EnableUTypesCtor {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_tuple__EnableCopyFromOtherTuple {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_tuple__EnableMoveFromOtherTuple {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_tuple__EnableImplicitCopyFromPair {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_tuple__EnableExplicitCopyFromPair {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_tuple__EnableImplicitMoveFromPair {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_tuple__EnableExplicitMoveFromPair {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_input_iterator_tag {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std_input_iterator_tag() {
    assert_eq!(
        ::core::mem::size_of::<std_input_iterator_tag>(),
        1usize,
        concat!("Size of: ", stringify!(std_input_iterator_tag))
    );
    assert_eq!(
        ::core::mem::align_of::<std_input_iterator_tag>(),
        1usize,
        concat!("Alignment of ", stringify!(std_input_iterator_tag))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_forward_iterator_tag {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std_forward_iterator_tag() {
    assert_eq!(
        ::core::mem::size_of::<std_forward_iterator_tag>(),
        1usize,
        concat!("Size of: ", stringify!(std_forward_iterator_tag))
    );
    assert_eq!(
        ::core::mem::align_of::<std_forward_iterator_tag>(),
        1usize,
        concat!("Alignment of ", stringify!(std_forward_iterator_tag))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_bidirectional_iterator_tag {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std_bidirectional_iterator_tag() {
    assert_eq!(
        ::core::mem::size_of::<std_bidirectional_iterator_tag>(),
        1usize,
        concat!("Size of: ", stringify!(std_bidirectional_iterator_tag))
    );
    assert_eq!(
        ::core::mem::align_of::<std_bidirectional_iterator_tag>(),
        1usize,
        concat!("Alignment of ", stringify!(std_bidirectional_iterator_tag))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_random_access_iterator_tag {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std_random_access_iterator_tag() {
    assert_eq!(
        ::core::mem::size_of::<std_random_access_iterator_tag>(),
        1usize,
        concat!("Size of: ", stringify!(std_random_access_iterator_tag))
    );
    assert_eq!(
        ::core::mem::align_of::<std_random_access_iterator_tag>(),
        1usize,
        concat!("Alignment of ", stringify!(std_random_access_iterator_tag))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_iterator_traits {
    pub _address: u8,
}
pub type std_iterator_traits___primary_template = std_iterator_traits;
pub type std___pointer_type = [u8; 0usize];
pub type std___allocator_traits_rebind_type<_Tp> = _Tp;
pub type std___allocator_traits_rebind_t = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator_traits {
    pub _address: u8,
}
pub type std_allocator_traits_allocator_type<_Alloc> = _Alloc;
pub type std_allocator_traits_value_type = [u8; 0usize];
pub type std_allocator_traits_pointer = [u8; 0usize];
pub type std_allocator_traits_const_pointer = [u8; 0usize];
pub type std_allocator_traits_void_pointer = [u8; 0usize];
pub type std_allocator_traits_const_void_pointer = [u8; 0usize];
pub type std_allocator_traits_difference_type = [u8; 0usize];
pub type std_allocator_traits_size_type = [u8; 0usize];
pub type std_allocator_traits_propagate_on_container_copy_assignment = u8;
pub type std_allocator_traits_propagate_on_container_move_assignment = u8;
pub type std_allocator_traits_propagate_on_container_swap = u8;
pub type std_allocator_traits_is_always_equal = u8;
pub type std_allocator_traits_rebind_alloc = std___allocator_traits_rebind_t;
pub type std_allocator_traits_rebind_traits = std_allocator_traits;
pub type std___compressed_pair_elem__ParamT<_Tp> = _Tp;
pub type std___compressed_pair_elem_reference<_Tp> = *mut _Tp;
pub type std___compressed_pair_elem_const_reference<_Tp> = *const _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___compressed_pair {
    pub _address: u8,
}
pub type std___compressed_pair__Base1 = u8;
pub type std___compressed_pair__Base2 = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator {
    pub _address: u8,
}
pub type std_allocator_size_type = usize;
pub type std_allocator_difference_type = isize;
pub type std_allocator_value_type<_Tp> = _Tp;
pub type std_allocator_propagate_on_container_move_assignment = std_true_type;
pub type std_allocator_is_always_equal = std_true_type;
pub type std_allocator_pointer<_Tp> = *mut _Tp;
pub type std_allocator_const_pointer<_Tp> = *const _Tp;
pub type std_allocator_reference<_Tp> = *mut _Tp;
pub type std_allocator_const_reference<_Tp> = *const _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator_rebind {
    pub _address: u8,
}
pub type std_allocator_rebind_other = std_allocator;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_default_delete {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___unique_ptr_deleter_sfinae {
    pub _address: u8,
}
pub type std___unique_ptr_deleter_sfinae___lval_ref_type<_Deleter> = *const _Deleter;
pub type std___unique_ptr_deleter_sfinae___good_rval_ref_type<_Deleter> = *mut _Deleter;
pub type std___unique_ptr_deleter_sfinae___enable_rval_overload = std_true_type;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_unique_ptr {
    pub _address: u8,
}
pub type std_unique_ptr_element_type<_Tp> = _Tp;
pub type std_unique_ptr_deleter_type<_Dp> = _Dp;
pub type std_unique_ptr_pointer = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_unique_ptr___nat {
    pub __for_bool_: ::std::os::raw::c_int,
}
pub type std_unique_ptr__DeleterSFINAE = std___unique_ptr_deleter_sfinae;
pub type std_unique_ptr__LValRefType = u8;
pub type std_unique_ptr__GoodRValRefType = u8;
pub type std_unique_ptr__BadRValRefType = u8;
pub type std_unique_ptr__EnableIfDeleterDefaultConstructible = u8;
pub type std_unique_ptr__EnableIfDeleterConstructible = u8;
pub type std_unique_ptr__EnableIfMoveConvertible = u8;
pub type std_unique_ptr__EnableIfDeleterConvertible = u8;
pub type std_unique_ptr__EnableIfDeleterAssignable = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_atomic {
    pub _address: u8,
}
pub type std_atomic___base = u8;
pub type std_atomic_value_type<_Tp> = _Tp;
pub type std_atomic_difference_type<_Tp> = std_atomic_value_type<_Tp>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_iterator {
    pub _address: u8,
}
pub type std_iterator_value_type<_Tp> = _Tp;
pub type std_iterator_difference_type<_Distance> = _Distance;
pub type std_iterator_pointer<_Pointer> = _Pointer;
pub type std_iterator_reference<_Reference> = _Reference;
pub type std_iterator_iterator_category<_Category> = _Category;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_reverse_iterator<_Iter> {
    pub __t: _Iter,
    pub current: _Iter,
    pub _phantom_0: ::core::marker::PhantomData<::core::cell::UnsafeCell<_Iter>>,
}
pub type std_reverse_iterator_iterator_type<_Iter> = _Iter;
pub type std_reverse_iterator_difference_type = std_iterator_traits;
pub type std_reverse_iterator_reference = std_iterator_traits;
pub type std_reverse_iterator_pointer = std_iterator_traits;
pub type std_reverse_iterator_iterator_category = std__If;
pub type std_reverse_iterator_value_type = std_iterator_traits;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___wrap_iter<_Iter> {
    pub __i: std___wrap_iter_iterator_type<_Iter>,
    pub _phantom_0: ::core::marker::PhantomData<::core::cell::UnsafeCell<_Iter>>,
}
pub type std___wrap_iter_iterator_type<_Iter> = _Iter;
pub type std___wrap_iter_value_type = std_iterator_traits;
pub type std___wrap_iter_difference_type = std_iterator_traits;
pub type std___wrap_iter_pointer = std_iterator_traits;
pub type std___wrap_iter_reference = std_iterator_traits;
pub type std___wrap_iter_iterator_category = std_iterator_traits;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_function {
    pub _address: u8,
}
pub type std___bit_reference___storage_type = [u8; 0usize];
pub type std___bit_reference___storage_pointer = [u8; 0usize];
#[repr(C)]
pub struct std___bit_const_reference {
    pub __seg_: std___bit_const_reference___storage_pointer,
    pub __mask_: std___bit_const_reference___storage_type,
}
pub type std___bit_const_reference___storage_type = [u8; 0usize];
pub type std___bit_const_reference___storage_pointer = [u8; 0usize];
pub type std___bit_iterator_difference_type = [u8; 0usize];
pub type std___bit_iterator_value_type = bool;
pub type std___bit_iterator_pointer = u8;
pub type std___bit_iterator_reference = u8;
pub type std___bit_iterator_iterator_category = std_random_access_iterator_tag;
pub type std___bit_iterator___storage_type = [u8; 0usize];
pub type std___bit_iterator___storage_pointer = [u8; 0usize];
extern "C" {
    #[link_name = "\u{1}__throw_length_error"]
    pub fn std___vector_base_common___throw_length_error(this: *const u8);
}
extern "C" {
    #[link_name = "\u{1}__throw_out_of_range"]
    pub fn std___vector_base_common___throw_out_of_range(this: *const u8);
}
#[repr(C)]
#[derive(Debug)]
pub struct std___vector_base {
    pub _base: u8,
    pub __begin_: std___vector_base_pointer,
    pub __end_: std___vector_base_pointer,
    pub __end_cap_: std___compressed_pair,
}
pub type std___vector_base_allocator_type<_Allocator> = _Allocator;
pub type std___vector_base___alloc_traits = std_allocator_traits;
pub type std___vector_base_size_type = std___vector_base___alloc_traits;
pub type std___vector_base_value_type<_Tp> = _Tp;
pub type std___vector_base_reference<_Tp> = *mut std___vector_base_value_type<_Tp>;
pub type std___vector_base_const_reference<_Tp> = *const std___vector_base_value_type<_Tp>;
pub type std___vector_base_difference_type = std___vector_base___alloc_traits;
pub type std___vector_base_pointer = std___vector_base___alloc_traits;
pub type std___vector_base_const_pointer = std___vector_base___alloc_traits;
pub type std___vector_base_iterator = std___vector_base_pointer;
pub type std___vector_base_const_iterator = std___vector_base_const_pointer;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_optional {
    pub _address: u8,
}
pub type std_optional___base = u8;
pub type std_optional_value_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_optional__CheckOptionalArgsConstructor {
    pub _address: u8,
}
pub type std_optional__CheckOptionalArgsCtor = std__If;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_optional__CheckOptionalLikeConstructor {
    pub _address: u8,
}
pub type std_optional__CheckOptionalLikeConstructor___check_constructible_from_opt = std__Or;
pub type std_optional__CheckOptionalLikeConstructor___check_assignable_from_opt = std__Or;
pub type std_optional__CheckOptionalLikeCtor = std__If;
pub type std_optional__CheckOptionalLikeAssign = std__If;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_char_traits {
    pub _address: u8,
}
pub type std_char_traits_char_type<_CharT> = _CharT;
pub type std_char_traits_int_type = ::std::os::raw::c_int;
pub type std_char_traits_off_type = std_streamoff;
pub type std_char_traits_pos_type = std_streampos;
pub type std_char_traits_state_type = mbstate_t;
pub type std_string_view = std_basic_string_view<::std::os::raw::c_char>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_string_view<_CharT> {
    pub __data: *const std_basic_string_view_value_type<_CharT>,
    pub __size: std_basic_string_view_size_type,
    pub _phantom_0: ::core::marker::PhantomData<::core::cell::UnsafeCell<_CharT>>,
}
pub type std_basic_string_view_traits_type<_Traits> = _Traits;
pub type std_basic_string_view_value_type<_CharT> = _CharT;
pub type std_basic_string_view_pointer<_CharT> = *mut _CharT;
pub type std_basic_string_view_const_pointer<_CharT> = *const _CharT;
pub type std_basic_string_view_reference<_CharT> = *mut _CharT;
pub type std_basic_string_view_const_reference<_CharT> = *const _CharT;
pub type std_basic_string_view_const_iterator<_CharT> = std_basic_string_view_const_pointer<_CharT>;
pub type std_basic_string_view_iterator<_CharT> = std_basic_string_view_const_iterator<_CharT>;
pub type std_basic_string_view_const_reverse_iterator<_CharT> =
    std_reverse_iterator<std_basic_string_view_const_iterator<_CharT>>;
pub type std_basic_string_view_reverse_iterator<_CharT> =
    std_basic_string_view_const_reverse_iterator<_CharT>;
pub type std_basic_string_view_size_type = usize;
pub type std_basic_string_view_difference_type = isize;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_fpos<_StateT> {
    pub __st_: _StateT,
    pub __off_: std_streamoff,
    pub _phantom_0: ::core::marker::PhantomData<::core::cell::UnsafeCell<_StateT>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_string {
    pub _address: u8,
}
pub type std_basic_string___self = u8;
pub type std_basic_string___self_view<_CharT> = std_basic_string_view<_CharT>;
pub type std_basic_string_traits_type<_Traits> = _Traits;
pub type std_basic_string_value_type = u8;
pub type std_basic_string_allocator_type<_Allocator> = _Allocator;
pub type std_basic_string___alloc_traits = std_allocator_traits;
pub type std_basic_string_size_type = std_basic_string___alloc_traits;
pub type std_basic_string_difference_type = std_basic_string___alloc_traits;
pub type std_basic_string_reference = *mut std_basic_string_value_type;
pub type std_basic_string_const_reference = *const std_basic_string_value_type;
pub type std_basic_string_pointer = std_basic_string___alloc_traits;
pub type std_basic_string_const_pointer = std_basic_string___alloc_traits;
pub type std_basic_string_iterator = std___wrap_iter<std_basic_string_pointer>;
pub type std_basic_string_const_iterator = std___wrap_iter<std_basic_string_const_pointer>;
pub type std_basic_string_reverse_iterator = std_reverse_iterator<std_basic_string_iterator>;
pub type std_basic_string_const_reverse_iterator =
    std_reverse_iterator<std_basic_string_const_iterator>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_string___long {
    pub __data_: std_basic_string_pointer,
    pub __size_: std_basic_string_size_type,
    pub __cap_: std_basic_string_size_type,
}
pub const std_basic_string___min_cap: std_basic_string__bindgen_ty_1 =
    std_basic_string__bindgen_ty_1::__min_cap;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum std_basic_string__bindgen_ty_1 {
    __min_cap = 0,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_string___short {
    pub __data_: *mut std_basic_string_value_type,
    pub __bindgen_anon_1: std_basic_string___short__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_string___short__bindgen_ty_1 {
    pub __size_: ::std::os::raw::c_uchar,
}
#[repr(C)]
#[repr(align(1))]
pub struct std_basic_string___ulx {
    pub __lx: __BindgenUnionField<std_basic_string___long>,
    pub __lxx: __BindgenUnionField<std_basic_string___short>,
    pub bindgen_union_field: [u8; 0usize],
}
pub const std_basic_string___n_words: std_basic_string__bindgen_ty_2 =
    std_basic_string__bindgen_ty_2::__n_words;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum std_basic_string__bindgen_ty_2 {
    __n_words = 0,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_string___raw {
    pub __words: *mut std_basic_string_size_type,
}
#[repr(C)]
pub struct std_basic_string___rep {
    pub __bindgen_anon_1: std_basic_string___rep__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(1))]
pub struct std_basic_string___rep__bindgen_ty_1 {
    pub __l: __BindgenUnionField<std_basic_string___long>,
    pub __s: __BindgenUnionField<std_basic_string___short>,
    pub __r: __BindgenUnionField<std_basic_string___raw>,
    pub bindgen_union_field: [u8; 0usize],
}
pub const std_basic_string___alignment: std_basic_string__bindgen_ty_3 =
    std_basic_string__bindgen_ty_3::__alignment;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum std_basic_string__bindgen_ty_3 {
    __alignment = 0,
}
pub type std___bitset_difference_type = isize;
pub type std___bitset_size_type = usize;
pub type std___bitset___storage_type = std___bitset_size_type;
pub type std___bitset___self = u8;
pub type std___bitset___storage_pointer = *mut std___bitset___storage_type;
pub type std___bitset___const_storage_pointer = *const std___bitset___storage_type;
pub const std___bitset___bits_per_word: ::std::os::raw::c_uint = 64;
pub type std___bitset_reference = u8;
pub type std___bitset_const_reference = std___bit_const_reference;
pub type std___bitset_iterator = u8;
pub type std___bitset_const_iterator = u8;
extern "C" {
    #[link_name = "\u{1}flip"]
    pub fn std___bitset_flip(this: *mut u8);
}
extern "C" {
    #[link_name = "\u{1}all"]
    pub fn std___bitset_all(this: *const u8) -> bool;
}
extern "C" {
    #[link_name = "\u{1}any"]
    pub fn std___bitset_any(this: *const u8) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__n_words"]
    pub static std_bitset___n_words: ::std::os::raw::c_uint;
}
pub type std_bitset_base = u8;
pub type std_bitset_reference = std_bitset_base;
pub type std_bitset_const_reference = std_bitset_base;
extern "C" {
    #[link_name = "\u{1}set"]
    pub fn std_bitset_set1(this: *mut u8, __pos: usize, __val: bool) -> *mut u8;
}
extern "C" {
    #[link_name = "\u{1}reset"]
    pub fn std_bitset_reset1(this: *mut u8, __pos: usize) -> *mut u8;
}
extern "C" {
    #[link_name = "\u{1}test"]
    pub fn std_bitset_test(this: *const u8, __pos: usize) -> bool;
}
pub type __int64_t = ::std::os::raw::c_longlong;
pub type __darwin_intptr_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t {
    pub __mbstate8: [::std::os::raw::c_char; 128usize],
    pub _mbstateL: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(
        ::core::mem::size_of::<__mbstate_t>(),
        128usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::core::mem::align_of::<__mbstate_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    fn test_field___mbstate8() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<__mbstate_t>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).__mbstate8) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__mbstate_t),
                "::",
                stringify!(__mbstate8)
            )
        );
    }
    test_field___mbstate8();
    fn test_field__mbstateL() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<__mbstate_t>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr)._mbstateL) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__mbstate_t),
                "::",
                stringify!(_mbstateL)
            )
        );
    }
    test_field__mbstateL();
}
pub type __darwin_mbstate_t = __mbstate_t;
pub type __darwin_size_t = ::std::os::raw::c_ulong;
pub type __darwin_off_t = __int64_t;
pub type mbstate_t = __darwin_mbstate_t;
pub type va_list = __builtin_va_list;
pub type fpos_t = __darwin_off_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sbuf {
    pub _base: *mut ::std::os::raw::c_uchar,
    pub _size: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___sbuf() {
    assert_eq!(
        ::core::mem::size_of::<__sbuf>(),
        16usize,
        concat!("Size of: ", stringify!(__sbuf))
    );
    assert_eq!(
        ::core::mem::align_of::<__sbuf>(),
        8usize,
        concat!("Alignment of ", stringify!(__sbuf))
    );
    fn test_field__base() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<__sbuf>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr)._base) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__sbuf),
                "::",
                stringify!(_base)
            )
        );
    }
    test_field__base();
    fn test_field__size() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<__sbuf>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr)._size) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(__sbuf),
                "::",
                stringify!(_size)
            )
        );
    }
    test_field__size();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sFILEX {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sFILE {
    pub _p: *mut ::std::os::raw::c_uchar,
    pub _r: ::std::os::raw::c_int,
    pub _w: ::std::os::raw::c_int,
    pub _flags: ::std::os::raw::c_short,
    pub _file: ::std::os::raw::c_short,
    pub _bf: __sbuf,
    pub _lbfsize: ::std::os::raw::c_int,
    pub _cookie: *mut ::core::ffi::c_void,
    pub _close: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void) -> ::std::os::raw::c_int,
    >,
    pub _read: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: *mut ::std::os::raw::c_char,
            arg3: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub _seek: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: fpos_t,
            arg3: ::std::os::raw::c_int,
        ) -> fpos_t,
    >,
    pub _write: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: *const ::std::os::raw::c_char,
            arg3: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub _ub: __sbuf,
    pub _extra: *mut __sFILEX,
    pub _ur: ::std::os::raw::c_int,
    pub _ubuf: [::std::os::raw::c_uchar; 3usize],
    pub _nbuf: [::std::os::raw::c_uchar; 1usize],
    pub _lb: __sbuf,
    pub _blksize: ::std::os::raw::c_int,
    pub _offset: fpos_t,
}
#[test]
fn bindgen_test_layout___sFILE() {
    assert_eq!(
        ::core::mem::size_of::<__sFILE>(),
        152usize,
        concat!("Size of: ", stringify!(__sFILE))
    );
    assert_eq!(
        ::core::mem::align_of::<__sFILE>(),
        8usize,
        concat!("Alignment of ", stringify!(__sFILE))
    );
    fn test_field__p() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<__sFILE>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr)._p) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__sFILE),
                "::",
                stringify!(_p)
            )
        );
    }
    test_field__p();
    fn test_field__r() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<__sFILE>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr)._r) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(__sFILE),
                "::",
                stringify!(_r)
            )
        );
    }
    test_field__r();
    fn test_field__w() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<__sFILE>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr)._w) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(__sFILE),
                "::",
                stringify!(_w)
            )
        );
    }
    test_field__w();
    fn test_field__flags() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<__sFILE>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr)._flags) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(__sFILE),
                "::",
                stringify!(_flags)
            )
        );
    }
    test_field__flags();
    fn test_field__file() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<__sFILE>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr)._file) as usize - ptr as usize
            },
            18usize,
            concat!(
                "Offset of field: ",
                stringify!(__sFILE),
                "::",
                stringify!(_file)
            )
        );
    }
    test_field__file();
    fn test_field__bf() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<__sFILE>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr)._bf) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(__sFILE),
                "::",
                stringify!(_bf)
            )
        );
    }
    test_field__bf();
    fn test_field__lbfsize() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<__sFILE>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr)._lbfsize) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(__sFILE),
                "::",
                stringify!(_lbfsize)
            )
        );
    }
    test_field__lbfsize();
    fn test_field__cookie() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<__sFILE>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr)._cookie) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(__sFILE),
                "::",
                stringify!(_cookie)
            )
        );
    }
    test_field__cookie();
    fn test_field__close() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<__sFILE>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr)._close) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(__sFILE),
                "::",
                stringify!(_close)
            )
        );
    }
    test_field__close();
    fn test_field__read() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<__sFILE>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr)._read) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(__sFILE),
                "::",
                stringify!(_read)
            )
        );
    }
    test_field__read();
    fn test_field__seek() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<__sFILE>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr)._seek) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(__sFILE),
                "::",
                stringify!(_seek)
            )
        );
    }
    test_field__seek();
    fn test_field__write() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<__sFILE>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr)._write) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(__sFILE),
                "::",
                stringify!(_write)
            )
        );
    }
    test_field__write();
    fn test_field__ub() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<__sFILE>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr)._ub) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(__sFILE),
                "::",
                stringify!(_ub)
            )
        );
    }
    test_field__ub();
    fn test_field__extra() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<__sFILE>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr)._extra) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(__sFILE),
                "::",
                stringify!(_extra)
            )
        );
    }
    test_field__extra();
    fn test_field__ur() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<__sFILE>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr)._ur) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(__sFILE),
                "::",
                stringify!(_ur)
            )
        );
    }
    test_field__ur();
    fn test_field__ubuf() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<__sFILE>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr)._ubuf) as usize - ptr as usize
            },
            116usize,
            concat!(
                "Offset of field: ",
                stringify!(__sFILE),
                "::",
                stringify!(_ubuf)
            )
        );
    }
    test_field__ubuf();
    fn test_field__nbuf() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<__sFILE>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr)._nbuf) as usize - ptr as usize
            },
            119usize,
            concat!(
                "Offset of field: ",
                stringify!(__sFILE),
                "::",
                stringify!(_nbuf)
            )
        );
    }
    test_field__nbuf();
    fn test_field__lb() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<__sFILE>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr)._lb) as usize - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(__sFILE),
                "::",
                stringify!(_lb)
            )
        );
    }
    test_field__lb();
    fn test_field__blksize() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<__sFILE>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr)._blksize) as usize - ptr as usize
            },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(__sFILE),
                "::",
                stringify!(_blksize)
            )
        );
    }
    test_field__blksize();
    fn test_field__offset() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<__sFILE>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr)._offset) as usize - ptr as usize
            },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(__sFILE),
                "::",
                stringify!(_offset)
            )
        );
    }
    test_field__offset();
}
pub type FILE = __sFILE;
pub type U8CPU = ::std::os::raw::c_uint;
pub type SkFourByteTag = u32;
pub type SkUnichar = i32;
pub type SkGlyphID = u16;
#[repr(u8)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkBudgeted {
    kNo = 0,
    kYes = 1,
}
#[repr(C)]
pub struct SkRefCntBase__bindgen_vtable(::core::ffi::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct SkRefCntBase {
    pub vtable_: *const SkRefCntBase__bindgen_vtable,
    pub fRefCnt: u32,
}
#[test]
fn bindgen_test_layout_SkRefCntBase() {
    assert_eq!(
        ::core::mem::size_of::<SkRefCntBase>(),
        16usize,
        concat!("Size of: ", stringify!(SkRefCntBase))
    );
    assert_eq!(
        ::core::mem::align_of::<SkRefCntBase>(),
        8usize,
        concat!("Alignment of ", stringify!(SkRefCntBase))
    );
    fn test_field_fRefCnt() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkRefCntBase>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fRefCnt) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(SkRefCntBase),
                "::",
                stringify!(fRefCnt)
            )
        );
    }
    test_field_fRefCnt();
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct SkRefCnt {
    pub _bindgen_opaque_blob: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_SkRefCnt() {
    assert_eq!(
        ::core::mem::size_of::<SkRefCnt>(),
        16usize,
        concat!("Size of: ", stringify!(SkRefCnt))
    );
    assert_eq!(
        ::core::mem::align_of::<SkRefCnt>(),
        8usize,
        concat!("Alignment of ", stringify!(SkRefCnt))
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct SkNVRefCnt {
    pub fRefCnt: u32,
}
#[repr(C)]
#[derive(Debug)]
pub struct sk_sp<T> {
    pub fPtr: *mut T,
    pub _phantom_0: ::core::marker::PhantomData<::core::cell::UnsafeCell<T>>,
}
pub type sk_sp_element_type<T> = T;
pub type SkScalar = f32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkAutoTMalloc {
    pub _address: u8,
}
impl SkTArray_ReallocType {
    pub const kGrowing: SkTArray_ReallocType = SkTArray_ReallocType::kExactFit;
}
impl SkTArray_ReallocType {
    pub const kShrinking: SkTArray_ReallocType = SkTArray_ReallocType::kExactFit;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkTArray_ReallocType {
    kExactFit = 0,
}
pub type SkTArray_value_type<T> = T;
#[repr(C)]
#[derive(Debug)]
pub struct SkString {
    pub fRec: sk_sp<SkString_Rec>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkString_Rec {
    pub fLength: u32,
    pub fRefCnt: u32,
    pub fBeginningOfData: [::std::os::raw::c_char; 1usize],
}
#[test]
fn bindgen_test_layout_SkString_Rec() {
    assert_eq!(
        ::core::mem::size_of::<SkString_Rec>(),
        12usize,
        concat!("Size of: ", stringify!(SkString_Rec))
    );
    assert_eq!(
        ::core::mem::align_of::<SkString_Rec>(),
        4usize,
        concat!("Alignment of ", stringify!(SkString_Rec))
    );
    fn test_field_fLength() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkString_Rec>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fLength) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SkString_Rec),
                "::",
                stringify!(fLength)
            )
        );
    }
    test_field_fLength();
    fn test_field_fRefCnt() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkString_Rec>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fRefCnt) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(SkString_Rec),
                "::",
                stringify!(fRefCnt)
            )
        );
    }
    test_field_fRefCnt();
    fn test_field_fBeginningOfData() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkString_Rec>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fBeginningOfData) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(SkString_Rec),
                "::",
                stringify!(fBeginningOfData)
            )
        );
    }
    test_field_fBeginningOfData();
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkString3Rec4MakeEPKcm"]
    pub fn SkString_Rec_Make(
        text: *const ::std::os::raw::c_char,
        len: usize,
    ) -> sk_sp<SkString_Rec>;
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkString3Rec3refEv"]
    pub fn SkString_Rec_ref(this: *const SkString_Rec);
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkString3Rec5unrefEv"]
    pub fn SkString_Rec_unref(this: *const SkString_Rec);
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkString3Rec6uniqueEv"]
    pub fn SkString_Rec_unique(this: *const SkString_Rec) -> bool;
}
impl SkString_Rec {
    #[inline]
    pub unsafe fn Make(text: *const ::std::os::raw::c_char, len: usize) -> sk_sp<SkString_Rec> {
        SkString_Rec_Make(text, len)
    }
    #[inline]
    pub unsafe fn ref_(&self) {
        SkString_Rec_ref(self)
    }
    #[inline]
    pub unsafe fn unref(&self) {
        SkString_Rec_unref(self)
    }
    #[inline]
    pub unsafe fn unique(&self) -> bool {
        SkString_Rec_unique(self)
    }
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkString9gEmptyRecE"]
    pub static SkString_gEmptyRec: SkString_Rec;
}
#[test]
fn bindgen_test_layout_SkString() {
    assert_eq!(
        ::core::mem::size_of::<SkString>(),
        8usize,
        concat!("Size of: ", stringify!(SkString))
    );
    assert_eq!(
        ::core::mem::align_of::<SkString>(),
        8usize,
        concat!("Alignment of ", stringify!(SkString))
    );
    fn test_field_fRec() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkString>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fRec) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SkString),
                "::",
                stringify!(fRec)
            )
        );
    }
    test_field_fRec();
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkString6equalsERKS_"]
    pub fn SkString_equals(this: *const SkString, arg1: *const SkString) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkString6equalsEPKc"]
    pub fn SkString_equals1(this: *const SkString, text: *const ::std::os::raw::c_char) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkString6equalsEPKcm"]
    pub fn SkString_equals2(
        this: *const SkString,
        text: *const ::std::os::raw::c_char,
        len: usize,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkString12writable_strEv"]
    pub fn SkString_writable_str(this: *mut SkString) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkString5resetEv"]
    pub fn SkString_reset(this: *mut SkString);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkString6resizeEm"]
    pub fn SkString_resize(this: *mut SkString, len: usize);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkString3setEPKc"]
    pub fn SkString_set(this: *mut SkString, text: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkString3setEPKcm"]
    pub fn SkString_set1(this: *mut SkString, text: *const ::std::os::raw::c_char, len: usize);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkString6insertEmPKc"]
    pub fn SkString_insert(this: *mut SkString, offset: usize, text: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkString6insertEmPKcm"]
    pub fn SkString_insert1(
        this: *mut SkString,
        offset: usize,
        text: *const ::std::os::raw::c_char,
        len: usize,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkString13insertUnicharEmi"]
    pub fn SkString_insertUnichar(this: *mut SkString, offset: usize, arg1: SkUnichar);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkString9insertS32Emi"]
    pub fn SkString_insertS32(this: *mut SkString, offset: usize, value: i32);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkString9insertS64Emxi"]
    pub fn SkString_insertS64(
        this: *mut SkString,
        offset: usize,
        value: i64,
        minDigits: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkString9insertU32Emj"]
    pub fn SkString_insertU32(this: *mut SkString, offset: usize, value: u32);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkString9insertU64Emyi"]
    pub fn SkString_insertU64(
        this: *mut SkString,
        offset: usize,
        value: u64,
        minDigits: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkString9insertHexEmji"]
    pub fn SkString_insertHex(
        this: *mut SkString,
        offset: usize,
        value: u32,
        minDigits: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkString12insertScalarEmf"]
    pub fn SkString_insertScalar(this: *mut SkString, offset: usize, arg1: SkScalar);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkString6printfEPKcz"]
    pub fn SkString_printf(this: *mut SkString, format: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkString11printVAListEPKcPc"]
    pub fn SkString_printVAList(
        this: *mut SkString,
        format: *const ::std::os::raw::c_char,
        arg1: va_list,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkString7appendfEPKcz"]
    pub fn SkString_appendf(this: *mut SkString, format: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkString12appendVAListEPKcPc"]
    pub fn SkString_appendVAList(
        this: *mut SkString,
        format: *const ::std::os::raw::c_char,
        arg1: va_list,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkString8prependfEPKcz"]
    pub fn SkString_prependf(this: *mut SkString, format: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkString13prependVAListEPKcPc"]
    pub fn SkString_prependVAList(
        this: *mut SkString,
        format: *const ::std::os::raw::c_char,
        arg1: va_list,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkString6removeEmm"]
    pub fn SkString_remove(this: *mut SkString, offset: usize, length: usize);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkString4swapERS_"]
    pub fn SkString_swap(this: *mut SkString, other: *mut SkString);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkStringC1Ev"]
    pub fn SkString_SkString(this: *mut SkString);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkStringC1Em"]
    pub fn SkString_SkString1(this: *mut SkString, len: usize);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkStringC1EPKc"]
    pub fn SkString_SkString2(this: *mut SkString, text: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkStringC1EPKcm"]
    pub fn SkString_SkString3(this: *mut SkString, text: *const ::std::os::raw::c_char, len: usize);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkStringC1ERKS_"]
    pub fn SkString_SkString4(this: *mut SkString, arg1: *const SkString);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkStringC1EOS_"]
    pub fn SkString_SkString5(this: *mut SkString, arg1: *mut SkString);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkStringC1ERKNSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEE"]
    pub fn SkString_SkString6(this: *mut SkString, arg1: *const std_string);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkStringC1ENSt3__117basic_string_viewIcNS0_11char_traitsIcEEEE"]
    pub fn SkString_SkString7(this: *mut SkString, arg1: std_string_view);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkStringD1Ev"]
    pub fn SkString_SkString_destructor(this: *mut SkString);
}
impl SkString {
    #[inline]
    pub unsafe fn equals(&self, arg1: *const SkString) -> bool {
        SkString_equals(self, arg1)
    }
    #[inline]
    pub unsafe fn equals1(&self, text: *const ::std::os::raw::c_char) -> bool {
        SkString_equals1(self, text)
    }
    #[inline]
    pub unsafe fn equals2(&self, text: *const ::std::os::raw::c_char, len: usize) -> bool {
        SkString_equals2(self, text, len)
    }
    #[inline]
    pub unsafe fn writable_str(&mut self) -> *mut ::std::os::raw::c_char {
        SkString_writable_str(self)
    }
    #[inline]
    pub unsafe fn reset(&mut self) {
        SkString_reset(self)
    }
    #[inline]
    pub unsafe fn resize(&mut self, len: usize) {
        SkString_resize(self, len)
    }
    #[inline]
    pub unsafe fn set(&mut self, text: *const ::std::os::raw::c_char) {
        SkString_set(self, text)
    }
    #[inline]
    pub unsafe fn set1(&mut self, text: *const ::std::os::raw::c_char, len: usize) {
        SkString_set1(self, text, len)
    }
    #[inline]
    pub unsafe fn insert(&mut self, offset: usize, text: *const ::std::os::raw::c_char) {
        SkString_insert(self, offset, text)
    }
    #[inline]
    pub unsafe fn insert1(
        &mut self,
        offset: usize,
        text: *const ::std::os::raw::c_char,
        len: usize,
    ) {
        SkString_insert1(self, offset, text, len)
    }
    #[inline]
    pub unsafe fn insertUnichar(&mut self, offset: usize, arg1: SkUnichar) {
        SkString_insertUnichar(self, offset, arg1)
    }
    #[inline]
    pub unsafe fn insertS32(&mut self, offset: usize, value: i32) {
        SkString_insertS32(self, offset, value)
    }
    #[inline]
    pub unsafe fn insertS64(
        &mut self,
        offset: usize,
        value: i64,
        minDigits: ::std::os::raw::c_int,
    ) {
        SkString_insertS64(self, offset, value, minDigits)
    }
    #[inline]
    pub unsafe fn insertU32(&mut self, offset: usize, value: u32) {
        SkString_insertU32(self, offset, value)
    }
    #[inline]
    pub unsafe fn insertU64(
        &mut self,
        offset: usize,
        value: u64,
        minDigits: ::std::os::raw::c_int,
    ) {
        SkString_insertU64(self, offset, value, minDigits)
    }
    #[inline]
    pub unsafe fn insertHex(
        &mut self,
        offset: usize,
        value: u32,
        minDigits: ::std::os::raw::c_int,
    ) {
        SkString_insertHex(self, offset, value, minDigits)
    }
    #[inline]
    pub unsafe fn insertScalar(&mut self, offset: usize, arg1: SkScalar) {
        SkString_insertScalar(self, offset, arg1)
    }
    #[inline]
    pub unsafe fn printVAList(&mut self, format: *const ::std::os::raw::c_char, arg1: va_list) {
        SkString_printVAList(self, format, arg1)
    }
    #[inline]
    pub unsafe fn appendVAList(&mut self, format: *const ::std::os::raw::c_char, arg1: va_list) {
        SkString_appendVAList(self, format, arg1)
    }
    #[inline]
    pub unsafe fn prependVAList(&mut self, format: *const ::std::os::raw::c_char, arg1: va_list) {
        SkString_prependVAList(self, format, arg1)
    }
    #[inline]
    pub unsafe fn remove(&mut self, offset: usize, length: usize) {
        SkString_remove(self, offset, length)
    }
    #[inline]
    pub unsafe fn swap(&mut self, other: *mut SkString) {
        SkString_swap(self, other)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkString_SkString(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(len: usize) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkString_SkString1(__bindgen_tmp.as_mut_ptr(), len);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(text: *const ::std::os::raw::c_char) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkString_SkString2(__bindgen_tmp.as_mut_ptr(), text);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new3(text: *const ::std::os::raw::c_char, len: usize) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkString_SkString3(__bindgen_tmp.as_mut_ptr(), text, len);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new4(arg1: *const SkString) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkString_SkString4(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new5(arg1: *mut SkString) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkString_SkString5(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new6(arg1: *const std_string) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkString_SkString6(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new7(arg1: std_string_view) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkString_SkString7(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        SkString_SkString_destructor(self)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TraitObject {
    pub data: *mut ::core::ffi::c_void,
    pub vtable: *mut ::core::ffi::c_void,
}
#[test]
fn bindgen_test_layout_TraitObject() {
    assert_eq!(
        ::core::mem::size_of::<TraitObject>(),
        16usize,
        concat!("Size of: ", stringify!(TraitObject))
    );
    assert_eq!(
        ::core::mem::align_of::<TraitObject>(),
        8usize,
        concat!("Alignment of ", stringify!(TraitObject))
    );
    fn test_field_data() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<TraitObject>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(TraitObject),
                "::",
                stringify!(data)
            )
        );
    }
    test_field_data();
    fn test_field_vtable() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<TraitObject>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).vtable) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(TraitObject),
                "::",
                stringify!(vtable)
            )
        );
    }
    test_field_vtable();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VecSink<T> {
    pub fn_trait: TraitObject,
    pub set_fn:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut T, arg2: usize, arg3: TraitObject)>,
    pub _phantom_0: ::core::marker::PhantomData<::core::cell::UnsafeCell<T>>,
}
#[repr(C)]
pub struct SkStrings {
    pub strings: [u64; 3usize],
}
#[test]
fn bindgen_test_layout_SkStrings() {
    assert_eq!(
        ::core::mem::size_of::<SkStrings>(),
        24usize,
        concat!("Size of: ", stringify!(SkStrings))
    );
    assert_eq!(
        ::core::mem::align_of::<SkStrings>(),
        8usize,
        concat!("Alignment of ", stringify!(SkStrings))
    );
    fn test_field_strings() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkStrings>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).strings) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SkStrings),
                "::",
                stringify!(strings)
            )
        );
    }
    test_field_strings();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkIPoint {
    pub fX: i32,
    pub fY: i32,
}
#[test]
fn bindgen_test_layout_SkIPoint() {
    assert_eq!(
        ::core::mem::size_of::<SkIPoint>(),
        8usize,
        concat!("Size of: ", stringify!(SkIPoint))
    );
    assert_eq!(
        ::core::mem::align_of::<SkIPoint>(),
        4usize,
        concat!("Alignment of ", stringify!(SkIPoint))
    );
    fn test_field_fX() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkIPoint>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fX) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SkIPoint),
                "::",
                stringify!(fX)
            )
        );
    }
    test_field_fX();
    fn test_field_fY() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkIPoint>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fY) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(SkIPoint),
                "::",
                stringify!(fY)
            )
        );
    }
    test_field_fY();
}
pub type SkVector = SkPoint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkPoint {
    pub fX: SkScalar,
    pub fY: SkScalar,
}
#[test]
fn bindgen_test_layout_SkPoint() {
    assert_eq!(
        ::core::mem::size_of::<SkPoint>(),
        8usize,
        concat!("Size of: ", stringify!(SkPoint))
    );
    assert_eq!(
        ::core::mem::align_of::<SkPoint>(),
        4usize,
        concat!("Alignment of ", stringify!(SkPoint))
    );
    fn test_field_fX() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkPoint>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fX) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SkPoint),
                "::",
                stringify!(fX)
            )
        );
    }
    test_field_fX();
    fn test_field_fY() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkPoint>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fY) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(SkPoint),
                "::",
                stringify!(fY)
            )
        );
    }
    test_field_fY();
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkPoint9normalizeEv"]
    pub fn SkPoint_normalize(this: *mut SkPoint) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkPoint12setNormalizeEff"]
    pub fn SkPoint_setNormalize(this: *mut SkPoint, x: SkScalar, y: SkScalar) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkPoint9setLengthEf"]
    pub fn SkPoint_setLength(this: *mut SkPoint, length: SkScalar) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkPoint9setLengthEfff"]
    pub fn SkPoint_setLength1(
        this: *mut SkPoint,
        x: SkScalar,
        y: SkScalar,
        length: SkScalar,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK7SkPoint5scaleEfPS_"]
    pub fn SkPoint_scale(this: *const SkPoint, scale: SkScalar, dst: *mut SkPoint);
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkPoint6LengthEff"]
    pub fn SkPoint_Length(x: SkScalar, y: SkScalar) -> SkScalar;
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkPoint9NormalizeEPS_"]
    pub fn SkPoint_Normalize(vec: *mut SkVector) -> SkScalar;
}
impl SkPoint {
    #[inline]
    pub unsafe fn normalize(&mut self) -> bool {
        SkPoint_normalize(self)
    }
    #[inline]
    pub unsafe fn setNormalize(&mut self, x: SkScalar, y: SkScalar) -> bool {
        SkPoint_setNormalize(self, x, y)
    }
    #[inline]
    pub unsafe fn setLength(&mut self, length: SkScalar) -> bool {
        SkPoint_setLength(self, length)
    }
    #[inline]
    pub unsafe fn setLength1(&mut self, x: SkScalar, y: SkScalar, length: SkScalar) -> bool {
        SkPoint_setLength1(self, x, y, length)
    }
    #[inline]
    pub unsafe fn scale(&self, scale: SkScalar, dst: *mut SkPoint) {
        SkPoint_scale(self, scale, dst)
    }
    #[inline]
    pub unsafe fn Length(x: SkScalar, y: SkScalar) -> SkScalar {
        SkPoint_Length(x, y)
    }
    #[inline]
    pub unsafe fn Normalize(vec: *mut SkVector) -> SkScalar {
        SkPoint_Normalize(vec)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkISize {
    pub fWidth: i32,
    pub fHeight: i32,
}
#[test]
fn bindgen_test_layout_SkISize() {
    assert_eq!(
        ::core::mem::size_of::<SkISize>(),
        8usize,
        concat!("Size of: ", stringify!(SkISize))
    );
    assert_eq!(
        ::core::mem::align_of::<SkISize>(),
        4usize,
        concat!("Alignment of ", stringify!(SkISize))
    );
    fn test_field_fWidth() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkISize>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fWidth) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SkISize),
                "::",
                stringify!(fWidth)
            )
        );
    }
    test_field_fWidth();
    fn test_field_fHeight() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkISize>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fHeight) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(SkISize),
                "::",
                stringify!(fHeight)
            )
        );
    }
    test_field_fHeight();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkSize {
    pub fWidth: SkScalar,
    pub fHeight: SkScalar,
}
#[test]
fn bindgen_test_layout_SkSize() {
    assert_eq!(
        ::core::mem::size_of::<SkSize>(),
        8usize,
        concat!("Size of: ", stringify!(SkSize))
    );
    assert_eq!(
        ::core::mem::align_of::<SkSize>(),
        4usize,
        concat!("Alignment of ", stringify!(SkSize))
    );
    fn test_field_fWidth() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkSize>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fWidth) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SkSize),
                "::",
                stringify!(fWidth)
            )
        );
    }
    test_field_fWidth();
    fn test_field_fHeight() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkSize>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fHeight) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(SkSize),
                "::",
                stringify!(fHeight)
            )
        );
    }
    test_field_fHeight();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkIRect {
    pub fLeft: i32,
    pub fTop: i32,
    pub fRight: i32,
    pub fBottom: i32,
}
#[test]
fn bindgen_test_layout_SkIRect() {
    assert_eq!(
        ::core::mem::size_of::<SkIRect>(),
        16usize,
        concat!("Size of: ", stringify!(SkIRect))
    );
    assert_eq!(
        ::core::mem::align_of::<SkIRect>(),
        4usize,
        concat!("Alignment of ", stringify!(SkIRect))
    );
    fn test_field_fLeft() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkIRect>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fLeft) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SkIRect),
                "::",
                stringify!(fLeft)
            )
        );
    }
    test_field_fLeft();
    fn test_field_fTop() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkIRect>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fTop) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(SkIRect),
                "::",
                stringify!(fTop)
            )
        );
    }
    test_field_fTop();
    fn test_field_fRight() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkIRect>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fRight) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(SkIRect),
                "::",
                stringify!(fRight)
            )
        );
    }
    test_field_fRight();
    fn test_field_fBottom() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkIRect>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fBottom) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(SkIRect),
                "::",
                stringify!(fBottom)
            )
        );
    }
    test_field_fBottom();
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkIRect9intersectERKS_S1_"]
    pub fn SkIRect_intersect(this: *mut SkIRect, a: *const SkIRect, b: *const SkIRect) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkIRect4joinERKS_"]
    pub fn SkIRect_join(this: *mut SkIRect, r: *const SkIRect);
}
impl SkIRect {
    #[inline]
    pub unsafe fn intersect(&mut self, a: *const SkIRect, b: *const SkIRect) -> bool {
        SkIRect_intersect(self, a, b)
    }
    #[inline]
    pub unsafe fn join(&mut self, r: *const SkIRect) {
        SkIRect_join(self, r)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkRect {
    pub fLeft: SkScalar,
    pub fTop: SkScalar,
    pub fRight: SkScalar,
    pub fBottom: SkScalar,
}
#[test]
fn bindgen_test_layout_SkRect() {
    assert_eq!(
        ::core::mem::size_of::<SkRect>(),
        16usize,
        concat!("Size of: ", stringify!(SkRect))
    );
    assert_eq!(
        ::core::mem::align_of::<SkRect>(),
        4usize,
        concat!("Alignment of ", stringify!(SkRect))
    );
    fn test_field_fLeft() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkRect>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fLeft) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SkRect),
                "::",
                stringify!(fLeft)
            )
        );
    }
    test_field_fLeft();
    fn test_field_fTop() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkRect>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fTop) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(SkRect),
                "::",
                stringify!(fTop)
            )
        );
    }
    test_field_fTop();
    fn test_field_fRight() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkRect>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fRight) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(SkRect),
                "::",
                stringify!(fRight)
            )
        );
    }
    test_field_fRight();
    fn test_field_fBottom() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkRect>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fBottom) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(SkRect),
                "::",
                stringify!(fBottom)
            )
        );
    }
    test_field_fBottom();
}
extern "C" {
    #[link_name = "\u{1}__ZNK6SkRect6toQuadEP7SkPoint"]
    pub fn SkRect_toQuad(this: *const SkRect, quad: *mut SkPoint);
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkRect14setBoundsCheckEPK7SkPointi"]
    pub fn SkRect_setBoundsCheck(
        this: *mut SkRect,
        pts: *const SkPoint,
        count: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkRect16setBoundsNoCheckEPK7SkPointi"]
    pub fn SkRect_setBoundsNoCheck(
        this: *mut SkRect,
        pts: *const SkPoint,
        count: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkRect9intersectERKS_"]
    pub fn SkRect_intersect(this: *mut SkRect, r: *const SkRect) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkRect9intersectERKS_S1_"]
    pub fn SkRect_intersect1(this: *mut SkRect, a: *const SkRect, b: *const SkRect) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkRect4joinERKS_"]
    pub fn SkRect_join(this: *mut SkRect, r: *const SkRect);
}
extern "C" {
    #[link_name = "\u{1}__ZNK6SkRect4dumpEb"]
    pub fn SkRect_dump(this: *const SkRect, asHex: bool);
}
impl SkRect {
    #[inline]
    pub unsafe fn toQuad(&self, quad: *mut SkPoint) {
        SkRect_toQuad(self, quad)
    }
    #[inline]
    pub unsafe fn setBoundsCheck(
        &mut self,
        pts: *const SkPoint,
        count: ::std::os::raw::c_int,
    ) -> bool {
        SkRect_setBoundsCheck(self, pts, count)
    }
    #[inline]
    pub unsafe fn setBoundsNoCheck(&mut self, pts: *const SkPoint, count: ::std::os::raw::c_int) {
        SkRect_setBoundsNoCheck(self, pts, count)
    }
    #[inline]
    pub unsafe fn intersect(&mut self, r: *const SkRect) -> bool {
        SkRect_intersect(self, r)
    }
    #[inline]
    pub unsafe fn intersect1(&mut self, a: *const SkRect, b: *const SkRect) -> bool {
        SkRect_intersect1(self, a, b)
    }
    #[inline]
    pub unsafe fn join(&mut self, r: *const SkRect) {
        SkRect_join(self, r)
    }
    #[inline]
    pub unsafe fn dump(&self, asHex: bool) {
        SkRect_dump(self, asHex)
    }
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkApplyPerspectiveClip {
    No = 0,
    Yes = 1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkMatrix {
    pub fMat: [SkScalar; 9usize],
    pub fTypeMask: i32,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkMatrix_ScaleToFit {
    Fill = 0,
    Start = 1,
    Center = 2,
    End = 3,
}
pub const SkMatrix_TypeMask_kIdentity_Mask: SkMatrix_TypeMask = 0;
pub const SkMatrix_TypeMask_kTranslate_Mask: SkMatrix_TypeMask = 1;
pub const SkMatrix_TypeMask_kScale_Mask: SkMatrix_TypeMask = 2;
pub const SkMatrix_TypeMask_kAffine_Mask: SkMatrix_TypeMask = 4;
pub const SkMatrix_TypeMask_kPerspective_Mask: SkMatrix_TypeMask = 8;
pub type SkMatrix_TypeMask = ::std::os::raw::c_uint;
pub type SkMatrix_MapXYProc = ::core::option::Option<
    unsafe extern "C" fn(mat: *const SkMatrix, x: SkScalar, y: SkScalar, result: *mut SkPoint),
>;
pub type SkMatrix_MapPtsProc = ::core::option::Option<
    unsafe extern "C" fn(
        mat: *const SkMatrix,
        dst: *mut SkPoint,
        src: *const SkPoint,
        count: ::std::os::raw::c_int,
    ),
>;
pub const SkMatrix_kMScaleX: ::std::os::raw::c_int = 0;
pub const SkMatrix_kMSkewX: ::std::os::raw::c_int = 1;
pub const SkMatrix_kMTransX: ::std::os::raw::c_int = 2;
pub const SkMatrix_kMSkewY: ::std::os::raw::c_int = 3;
pub const SkMatrix_kMScaleY: ::std::os::raw::c_int = 4;
pub const SkMatrix_kMTransY: ::std::os::raw::c_int = 5;
pub const SkMatrix_kMPersp0: ::std::os::raw::c_int = 6;
pub const SkMatrix_kMPersp1: ::std::os::raw::c_int = 7;
pub const SkMatrix_kMPersp2: ::std::os::raw::c_int = 8;
pub const SkMatrix_kAScaleX: ::std::os::raw::c_int = 0;
pub const SkMatrix_kASkewY: ::std::os::raw::c_int = 1;
pub const SkMatrix_kASkewX: ::std::os::raw::c_int = 2;
pub const SkMatrix_kAScaleY: ::std::os::raw::c_int = 3;
pub const SkMatrix_kATransX: ::std::os::raw::c_int = 4;
pub const SkMatrix_kATransY: ::std::os::raw::c_int = 5;
pub const SkMatrix_kRectStaysRect_Mask: ::std::os::raw::c_int = 16;
pub const SkMatrix_kOnlyPerspectiveValid_Mask: ::std::os::raw::c_int = 64;
pub const SkMatrix_kUnknown_Mask: ::std::os::raw::c_int = 128;
pub const SkMatrix_kORableMasks: ::std::os::raw::c_int = 15;
pub const SkMatrix_kAllMasks: ::std::os::raw::c_int = 31;
extern "C" {
    #[link_name = "\u{1}__ZN8SkMatrix11gMapXYProcsE"]
    pub static mut SkMatrix_gMapXYProcs: [SkMatrix_MapXYProc; 0usize];
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkMatrix12gMapPtsProcsE"]
    pub static mut SkMatrix_gMapPtsProcs: [SkMatrix_MapPtsProc; 0usize];
}
#[test]
fn bindgen_test_layout_SkMatrix() {
    assert_eq!(
        ::core::mem::size_of::<SkMatrix>(),
        40usize,
        concat!("Size of: ", stringify!(SkMatrix))
    );
    assert_eq!(
        ::core::mem::align_of::<SkMatrix>(),
        4usize,
        concat!("Alignment of ", stringify!(SkMatrix))
    );
    fn test_field_fMat() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkMatrix>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fMat) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SkMatrix),
                "::",
                stringify!(fMat)
            )
        );
    }
    test_field_fMat();
    fn test_field_fTypeMask() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkMatrix>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fTypeMask) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(SkMatrix),
                "::",
                stringify!(fTypeMask)
            )
        );
    }
    test_field_fTypeMask();
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkMatrix12isSimilarityEf"]
    pub fn SkMatrix_isSimilarity(this: *const SkMatrix, tol: SkScalar) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkMatrix20preservesRightAnglesEf"]
    pub fn SkMatrix_preservesRightAngles(this: *const SkMatrix, tol: SkScalar) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkMatrix4set9EPKf"]
    pub fn SkMatrix_set9(this: *mut SkMatrix, buffer: *const SkScalar) -> *mut SkMatrix;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkMatrix5resetEv"]
    pub fn SkMatrix_reset(this: *mut SkMatrix) -> *mut SkMatrix;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkMatrix12setTranslateEff"]
    pub fn SkMatrix_setTranslate(this: *mut SkMatrix, dx: SkScalar, dy: SkScalar) -> *mut SkMatrix;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkMatrix8setScaleEffff"]
    pub fn SkMatrix_setScale(
        this: *mut SkMatrix,
        sx: SkScalar,
        sy: SkScalar,
        px: SkScalar,
        py: SkScalar,
    ) -> *mut SkMatrix;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkMatrix8setScaleEff"]
    pub fn SkMatrix_setScale1(this: *mut SkMatrix, sx: SkScalar, sy: SkScalar) -> *mut SkMatrix;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkMatrix9setRotateEfff"]
    pub fn SkMatrix_setRotate(
        this: *mut SkMatrix,
        degrees: SkScalar,
        px: SkScalar,
        py: SkScalar,
    ) -> *mut SkMatrix;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkMatrix9setRotateEf"]
    pub fn SkMatrix_setRotate1(this: *mut SkMatrix, degrees: SkScalar) -> *mut SkMatrix;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkMatrix9setSinCosEffff"]
    pub fn SkMatrix_setSinCos(
        this: *mut SkMatrix,
        sinValue: SkScalar,
        cosValue: SkScalar,
        px: SkScalar,
        py: SkScalar,
    ) -> *mut SkMatrix;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkMatrix9setSinCosEff"]
    pub fn SkMatrix_setSinCos1(
        this: *mut SkMatrix,
        sinValue: SkScalar,
        cosValue: SkScalar,
    ) -> *mut SkMatrix;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkMatrix10setRSXformERK9SkRSXform"]
    pub fn SkMatrix_setRSXform(this: *mut SkMatrix, rsxForm: *const SkRSXform) -> *mut SkMatrix;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkMatrix7setSkewEffff"]
    pub fn SkMatrix_setSkew(
        this: *mut SkMatrix,
        kx: SkScalar,
        ky: SkScalar,
        px: SkScalar,
        py: SkScalar,
    ) -> *mut SkMatrix;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkMatrix7setSkewEff"]
    pub fn SkMatrix_setSkew1(this: *mut SkMatrix, kx: SkScalar, ky: SkScalar) -> *mut SkMatrix;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkMatrix9setConcatERKS_S1_"]
    pub fn SkMatrix_setConcat(
        this: *mut SkMatrix,
        a: *const SkMatrix,
        b: *const SkMatrix,
    ) -> *mut SkMatrix;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkMatrix12preTranslateEff"]
    pub fn SkMatrix_preTranslate(this: *mut SkMatrix, dx: SkScalar, dy: SkScalar) -> *mut SkMatrix;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkMatrix8preScaleEffff"]
    pub fn SkMatrix_preScale(
        this: *mut SkMatrix,
        sx: SkScalar,
        sy: SkScalar,
        px: SkScalar,
        py: SkScalar,
    ) -> *mut SkMatrix;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkMatrix8preScaleEff"]
    pub fn SkMatrix_preScale1(this: *mut SkMatrix, sx: SkScalar, sy: SkScalar) -> *mut SkMatrix;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkMatrix9preRotateEfff"]
    pub fn SkMatrix_preRotate(
        this: *mut SkMatrix,
        degrees: SkScalar,
        px: SkScalar,
        py: SkScalar,
    ) -> *mut SkMatrix;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkMatrix9preRotateEf"]
    pub fn SkMatrix_preRotate1(this: *mut SkMatrix, degrees: SkScalar) -> *mut SkMatrix;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkMatrix7preSkewEffff"]
    pub fn SkMatrix_preSkew(
        this: *mut SkMatrix,
        kx: SkScalar,
        ky: SkScalar,
        px: SkScalar,
        py: SkScalar,
    ) -> *mut SkMatrix;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkMatrix7preSkewEff"]
    pub fn SkMatrix_preSkew1(this: *mut SkMatrix, kx: SkScalar, ky: SkScalar) -> *mut SkMatrix;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkMatrix9preConcatERKS_"]
    pub fn SkMatrix_preConcat(this: *mut SkMatrix, other: *const SkMatrix) -> *mut SkMatrix;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkMatrix13postTranslateEff"]
    pub fn SkMatrix_postTranslate(this: *mut SkMatrix, dx: SkScalar, dy: SkScalar)
        -> *mut SkMatrix;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkMatrix9postScaleEffff"]
    pub fn SkMatrix_postScale(
        this: *mut SkMatrix,
        sx: SkScalar,
        sy: SkScalar,
        px: SkScalar,
        py: SkScalar,
    ) -> *mut SkMatrix;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkMatrix9postScaleEff"]
    pub fn SkMatrix_postScale1(this: *mut SkMatrix, sx: SkScalar, sy: SkScalar) -> *mut SkMatrix;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkMatrix10postRotateEfff"]
    pub fn SkMatrix_postRotate(
        this: *mut SkMatrix,
        degrees: SkScalar,
        px: SkScalar,
        py: SkScalar,
    ) -> *mut SkMatrix;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkMatrix10postRotateEf"]
    pub fn SkMatrix_postRotate1(this: *mut SkMatrix, degrees: SkScalar) -> *mut SkMatrix;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkMatrix8postSkewEffff"]
    pub fn SkMatrix_postSkew(
        this: *mut SkMatrix,
        kx: SkScalar,
        ky: SkScalar,
        px: SkScalar,
        py: SkScalar,
    ) -> *mut SkMatrix;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkMatrix8postSkewEff"]
    pub fn SkMatrix_postSkew1(this: *mut SkMatrix, kx: SkScalar, ky: SkScalar) -> *mut SkMatrix;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkMatrix10postConcatERKS_"]
    pub fn SkMatrix_postConcat(this: *mut SkMatrix, other: *const SkMatrix) -> *mut SkMatrix;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkMatrix13setRectToRectERK6SkRectS2_NS_10ScaleToFitE"]
    pub fn SkMatrix_setRectToRect(
        this: *mut SkMatrix,
        src: *const SkRect,
        dst: *const SkRect,
        stf: SkMatrix_ScaleToFit,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkMatrix13setPolyToPolyEPK7SkPointS2_i"]
    pub fn SkMatrix_setPolyToPoly(
        this: *mut SkMatrix,
        src: *const SkPoint,
        dst: *const SkPoint,
        count: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkMatrix17SetAffineIdentityEPf"]
    pub fn SkMatrix_SetAffineIdentity(affine: *mut SkScalar);
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkMatrix8asAffineEPf"]
    pub fn SkMatrix_asAffine(this: *const SkMatrix, affine: *mut SkScalar) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkMatrix9setAffineEPKf"]
    pub fn SkMatrix_setAffine(this: *mut SkMatrix, affine: *const SkScalar) -> *mut SkMatrix;
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkMatrix9mapPointsEP7SkPointPKS0_i"]
    pub fn SkMatrix_mapPoints(
        this: *const SkMatrix,
        dst: *mut SkPoint,
        src: *const SkPoint,
        count: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkMatrix20mapHomogeneousPointsEP8SkPoint3PKS0_i"]
    pub fn SkMatrix_mapHomogeneousPoints(
        this: *const SkMatrix,
        dst: *mut SkPoint3,
        src: *const SkPoint3,
        count: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkMatrix20mapHomogeneousPointsEP8SkPoint3PK7SkPointi"]
    pub fn SkMatrix_mapHomogeneousPoints1(
        this: *const SkMatrix,
        dst: *mut SkPoint3,
        src: *const SkPoint,
        count: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkMatrix5mapXYEffP7SkPoint"]
    pub fn SkMatrix_mapXY(this: *const SkMatrix, x: SkScalar, y: SkScalar, result: *mut SkPoint);
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkMatrix10mapVectorsEP7SkPointPKS0_i"]
    pub fn SkMatrix_mapVectors(
        this: *const SkMatrix,
        dst: *mut SkVector,
        src: *const SkVector,
        count: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkMatrix7mapRectEP6SkRectRKS0_22SkApplyPerspectiveClip"]
    pub fn SkMatrix_mapRect(
        this: *const SkMatrix,
        dst: *mut SkRect,
        src: *const SkRect,
        pc: SkApplyPerspectiveClip,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkMatrix21mapRectScaleTranslateEP6SkRectRKS0_"]
    pub fn SkMatrix_mapRectScaleTranslate(
        this: *const SkMatrix,
        dst: *mut SkRect,
        src: *const SkRect,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkMatrix9mapRadiusEf"]
    pub fn SkMatrix_mapRadius(this: *const SkMatrix, radius: SkScalar) -> SkScalar;
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkMatrix4dumpEv"]
    pub fn SkMatrix_dump(this: *const SkMatrix);
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkMatrix11getMinScaleEv"]
    pub fn SkMatrix_getMinScale(this: *const SkMatrix) -> SkScalar;
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkMatrix11getMaxScaleEv"]
    pub fn SkMatrix_getMaxScale(this: *const SkMatrix) -> SkScalar;
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkMatrix15getMinMaxScalesEPf"]
    pub fn SkMatrix_getMinMaxScales(this: *const SkMatrix, scaleFactors: *mut SkScalar) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkMatrix14decomposeScaleEP6SkSizePS_"]
    pub fn SkMatrix_decomposeScale(
        this: *const SkMatrix,
        scale: *mut SkSize,
        remaining: *mut SkMatrix,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkMatrix1IEv"]
    pub fn SkMatrix_I() -> *const SkMatrix;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkMatrix13InvalidMatrixEv"]
    pub fn SkMatrix_InvalidMatrix() -> *const SkMatrix;
}
impl SkMatrix {
    #[inline]
    pub unsafe fn isSimilarity(&self, tol: SkScalar) -> bool {
        SkMatrix_isSimilarity(self, tol)
    }
    #[inline]
    pub unsafe fn preservesRightAngles(&self, tol: SkScalar) -> bool {
        SkMatrix_preservesRightAngles(self, tol)
    }
    #[inline]
    pub unsafe fn set9(&mut self, buffer: *const SkScalar) -> *mut SkMatrix {
        SkMatrix_set9(self, buffer)
    }
    #[inline]
    pub unsafe fn reset(&mut self) -> *mut SkMatrix {
        SkMatrix_reset(self)
    }
    #[inline]
    pub unsafe fn setTranslate(&mut self, dx: SkScalar, dy: SkScalar) -> *mut SkMatrix {
        SkMatrix_setTranslate(self, dx, dy)
    }
    #[inline]
    pub unsafe fn setScale(
        &mut self,
        sx: SkScalar,
        sy: SkScalar,
        px: SkScalar,
        py: SkScalar,
    ) -> *mut SkMatrix {
        SkMatrix_setScale(self, sx, sy, px, py)
    }
    #[inline]
    pub unsafe fn setScale1(&mut self, sx: SkScalar, sy: SkScalar) -> *mut SkMatrix {
        SkMatrix_setScale1(self, sx, sy)
    }
    #[inline]
    pub unsafe fn setRotate(
        &mut self,
        degrees: SkScalar,
        px: SkScalar,
        py: SkScalar,
    ) -> *mut SkMatrix {
        SkMatrix_setRotate(self, degrees, px, py)
    }
    #[inline]
    pub unsafe fn setRotate1(&mut self, degrees: SkScalar) -> *mut SkMatrix {
        SkMatrix_setRotate1(self, degrees)
    }
    #[inline]
    pub unsafe fn setSinCos(
        &mut self,
        sinValue: SkScalar,
        cosValue: SkScalar,
        px: SkScalar,
        py: SkScalar,
    ) -> *mut SkMatrix {
        SkMatrix_setSinCos(self, sinValue, cosValue, px, py)
    }
    #[inline]
    pub unsafe fn setSinCos1(&mut self, sinValue: SkScalar, cosValue: SkScalar) -> *mut SkMatrix {
        SkMatrix_setSinCos1(self, sinValue, cosValue)
    }
    #[inline]
    pub unsafe fn setRSXform(&mut self, rsxForm: *const SkRSXform) -> *mut SkMatrix {
        SkMatrix_setRSXform(self, rsxForm)
    }
    #[inline]
    pub unsafe fn setSkew(
        &mut self,
        kx: SkScalar,
        ky: SkScalar,
        px: SkScalar,
        py: SkScalar,
    ) -> *mut SkMatrix {
        SkMatrix_setSkew(self, kx, ky, px, py)
    }
    #[inline]
    pub unsafe fn setSkew1(&mut self, kx: SkScalar, ky: SkScalar) -> *mut SkMatrix {
        SkMatrix_setSkew1(self, kx, ky)
    }
    #[inline]
    pub unsafe fn setConcat(&mut self, a: *const SkMatrix, b: *const SkMatrix) -> *mut SkMatrix {
        SkMatrix_setConcat(self, a, b)
    }
    #[inline]
    pub unsafe fn preTranslate(&mut self, dx: SkScalar, dy: SkScalar) -> *mut SkMatrix {
        SkMatrix_preTranslate(self, dx, dy)
    }
    #[inline]
    pub unsafe fn preScale(
        &mut self,
        sx: SkScalar,
        sy: SkScalar,
        px: SkScalar,
        py: SkScalar,
    ) -> *mut SkMatrix {
        SkMatrix_preScale(self, sx, sy, px, py)
    }
    #[inline]
    pub unsafe fn preScale1(&mut self, sx: SkScalar, sy: SkScalar) -> *mut SkMatrix {
        SkMatrix_preScale1(self, sx, sy)
    }
    #[inline]
    pub unsafe fn preRotate(
        &mut self,
        degrees: SkScalar,
        px: SkScalar,
        py: SkScalar,
    ) -> *mut SkMatrix {
        SkMatrix_preRotate(self, degrees, px, py)
    }
    #[inline]
    pub unsafe fn preRotate1(&mut self, degrees: SkScalar) -> *mut SkMatrix {
        SkMatrix_preRotate1(self, degrees)
    }
    #[inline]
    pub unsafe fn preSkew(
        &mut self,
        kx: SkScalar,
        ky: SkScalar,
        px: SkScalar,
        py: SkScalar,
    ) -> *mut SkMatrix {
        SkMatrix_preSkew(self, kx, ky, px, py)
    }
    #[inline]
    pub unsafe fn preSkew1(&mut self, kx: SkScalar, ky: SkScalar) -> *mut SkMatrix {
        SkMatrix_preSkew1(self, kx, ky)
    }
    #[inline]
    pub unsafe fn preConcat(&mut self, other: *const SkMatrix) -> *mut SkMatrix {
        SkMatrix_preConcat(self, other)
    }
    #[inline]
    pub unsafe fn postTranslate(&mut self, dx: SkScalar, dy: SkScalar) -> *mut SkMatrix {
        SkMatrix_postTranslate(self, dx, dy)
    }
    #[inline]
    pub unsafe fn postScale(
        &mut self,
        sx: SkScalar,
        sy: SkScalar,
        px: SkScalar,
        py: SkScalar,
    ) -> *mut SkMatrix {
        SkMatrix_postScale(self, sx, sy, px, py)
    }
    #[inline]
    pub unsafe fn postScale1(&mut self, sx: SkScalar, sy: SkScalar) -> *mut SkMatrix {
        SkMatrix_postScale1(self, sx, sy)
    }
    #[inline]
    pub unsafe fn postRotate(
        &mut self,
        degrees: SkScalar,
        px: SkScalar,
        py: SkScalar,
    ) -> *mut SkMatrix {
        SkMatrix_postRotate(self, degrees, px, py)
    }
    #[inline]
    pub unsafe fn postRotate1(&mut self, degrees: SkScalar) -> *mut SkMatrix {
        SkMatrix_postRotate1(self, degrees)
    }
    #[inline]
    pub unsafe fn postSkew(
        &mut self,
        kx: SkScalar,
        ky: SkScalar,
        px: SkScalar,
        py: SkScalar,
    ) -> *mut SkMatrix {
        SkMatrix_postSkew(self, kx, ky, px, py)
    }
    #[inline]
    pub unsafe fn postSkew1(&mut self, kx: SkScalar, ky: SkScalar) -> *mut SkMatrix {
        SkMatrix_postSkew1(self, kx, ky)
    }
    #[inline]
    pub unsafe fn postConcat(&mut self, other: *const SkMatrix) -> *mut SkMatrix {
        SkMatrix_postConcat(self, other)
    }
    #[inline]
    pub unsafe fn setRectToRect(
        &mut self,
        src: *const SkRect,
        dst: *const SkRect,
        stf: SkMatrix_ScaleToFit,
    ) -> bool {
        SkMatrix_setRectToRect(self, src, dst, stf)
    }
    #[inline]
    pub unsafe fn setPolyToPoly(
        &mut self,
        src: *const SkPoint,
        dst: *const SkPoint,
        count: ::std::os::raw::c_int,
    ) -> bool {
        SkMatrix_setPolyToPoly(self, src, dst, count)
    }
    #[inline]
    pub unsafe fn SetAffineIdentity(affine: *mut SkScalar) {
        SkMatrix_SetAffineIdentity(affine)
    }
    #[inline]
    pub unsafe fn asAffine(&self, affine: *mut SkScalar) -> bool {
        SkMatrix_asAffine(self, affine)
    }
    #[inline]
    pub unsafe fn setAffine(&mut self, affine: *const SkScalar) -> *mut SkMatrix {
        SkMatrix_setAffine(self, affine)
    }
    #[inline]
    pub unsafe fn mapPoints(
        &self,
        dst: *mut SkPoint,
        src: *const SkPoint,
        count: ::std::os::raw::c_int,
    ) {
        SkMatrix_mapPoints(self, dst, src, count)
    }
    #[inline]
    pub unsafe fn mapHomogeneousPoints(
        &self,
        dst: *mut SkPoint3,
        src: *const SkPoint3,
        count: ::std::os::raw::c_int,
    ) {
        SkMatrix_mapHomogeneousPoints(self, dst, src, count)
    }
    #[inline]
    pub unsafe fn mapHomogeneousPoints1(
        &self,
        dst: *mut SkPoint3,
        src: *const SkPoint,
        count: ::std::os::raw::c_int,
    ) {
        SkMatrix_mapHomogeneousPoints1(self, dst, src, count)
    }
    #[inline]
    pub unsafe fn mapXY(&self, x: SkScalar, y: SkScalar, result: *mut SkPoint) {
        SkMatrix_mapXY(self, x, y, result)
    }
    #[inline]
    pub unsafe fn mapVectors(
        &self,
        dst: *mut SkVector,
        src: *const SkVector,
        count: ::std::os::raw::c_int,
    ) {
        SkMatrix_mapVectors(self, dst, src, count)
    }
    #[inline]
    pub unsafe fn mapRect(
        &self,
        dst: *mut SkRect,
        src: *const SkRect,
        pc: SkApplyPerspectiveClip,
    ) -> bool {
        SkMatrix_mapRect(self, dst, src, pc)
    }
    #[inline]
    pub unsafe fn mapRectScaleTranslate(&self, dst: *mut SkRect, src: *const SkRect) {
        SkMatrix_mapRectScaleTranslate(self, dst, src)
    }
    #[inline]
    pub unsafe fn mapRadius(&self, radius: SkScalar) -> SkScalar {
        SkMatrix_mapRadius(self, radius)
    }
    #[inline]
    pub unsafe fn dump(&self) {
        SkMatrix_dump(self)
    }
    #[inline]
    pub unsafe fn getMinScale(&self) -> SkScalar {
        SkMatrix_getMinScale(self)
    }
    #[inline]
    pub unsafe fn getMaxScale(&self) -> SkScalar {
        SkMatrix_getMaxScale(self)
    }
    #[inline]
    pub unsafe fn getMinMaxScales(&self, scaleFactors: *mut SkScalar) -> bool {
        SkMatrix_getMinMaxScales(self, scaleFactors)
    }
    #[inline]
    pub unsafe fn decomposeScale(&self, scale: *mut SkSize, remaining: *mut SkMatrix) -> bool {
        SkMatrix_decomposeScale(self, scale, remaining)
    }
    #[inline]
    pub unsafe fn I() -> *const SkMatrix {
        SkMatrix_I()
    }
    #[inline]
    pub unsafe fn InvalidMatrix() -> *const SkMatrix {
        SkMatrix_InvalidMatrix()
    }
}
impl SkEncodedOrigin {
    pub const Default: SkEncodedOrigin = SkEncodedOrigin::TopLeft;
}
impl SkEncodedOrigin {
    pub const Last: SkEncodedOrigin = SkEncodedOrigin::LeftBottom;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkEncodedOrigin {
    TopLeft = 1,
    TopRight = 2,
    BottomRight = 3,
    BottomLeft = 4,
    LeftTop = 5,
    RightTop = 6,
    RightBottom = 7,
    LeftBottom = 8,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkCodecAnimation_DisposalMethod {
    kKeep = 1,
    kRestoreBGColor = 2,
    kRestorePrevious = 3,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkCodecAnimation_Blend {
    kSrcOver = 0,
    kSrc = 1,
}
impl SkAlphaType {
    pub const LastEnum: SkAlphaType = SkAlphaType::Unpremul;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkAlphaType {
    Unknown = 0,
    Opaque = 1,
    Premul = 2,
    Unpremul = 3,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkEncodedImageFormat {
    BMP = 0,
    GIF = 1,
    ICO = 2,
    JPEG = 3,
    PNG = 4,
    WBMP = 5,
    WEBP = 6,
    PKM = 7,
    KTX = 8,
    ASTC = 9,
    DNG = 10,
    HEIF = 11,
    AVIF = 12,
    JPEGXL = 13,
}
impl SkColorType {
    pub const kLastEnum_SkColorType: SkColorType = SkColorType::kR8_unorm_SkColorType;
}
impl SkColorType {
    pub const kN32_SkColorType: SkColorType = SkColorType::kRGBA_8888_SkColorType;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkColorType {
    kUnknown_SkColorType = 0,
    kAlpha_8_SkColorType = 1,
    kRGB_565_SkColorType = 2,
    kARGB_4444_SkColorType = 3,
    kRGBA_8888_SkColorType = 4,
    kRGB_888x_SkColorType = 5,
    kBGRA_8888_SkColorType = 6,
    kRGBA_1010102_SkColorType = 7,
    kBGRA_1010102_SkColorType = 8,
    kRGB_101010x_SkColorType = 9,
    kBGR_101010x_SkColorType = 10,
    kGray_8_SkColorType = 11,
    kRGBA_F16Norm_SkColorType = 12,
    kRGBA_F16_SkColorType = 13,
    kRGBA_F32_SkColorType = 14,
    kR8G8_unorm_SkColorType = 15,
    kA16_float_SkColorType = 16,
    kR16G16_float_SkColorType = 17,
    kA16_unorm_SkColorType = 18,
    kR16G16_unorm_SkColorType = 19,
    kR16G16B16A16_unorm_SkColorType = 20,
    kSRGBA_8888_SkColorType = 21,
    kR8_unorm_SkColorType = 22,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkReadBuffer {
    _unused: [u8; 0],
}
extern "C" {
    #[link_name = "\u{1}__Z24SkColorTypeBytesPerPixel11SkColorType"]
    pub fn SkColorTypeBytesPerPixel(ct: SkColorType) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__Z25SkColorTypeIsAlwaysOpaque11SkColorType"]
    pub fn SkColorTypeIsAlwaysOpaque(ct: SkColorType) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__Z28SkColorTypeValidateAlphaType11SkColorType11SkAlphaTypePS0_"]
    pub fn SkColorTypeValidateAlphaType(
        colorType: SkColorType,
        alphaType: SkAlphaType,
        canonical: *mut SkAlphaType,
    ) -> bool;
}
impl SkYUVColorSpace {
    pub const LastEnum: SkYUVColorSpace = SkYUVColorSpace::Identity;
}
impl SkYUVColorSpace {
    pub const JPEG: SkYUVColorSpace = SkYUVColorSpace::JPEG_Full;
}
impl SkYUVColorSpace {
    pub const Rec601: SkYUVColorSpace = SkYUVColorSpace::Rec601_Limited;
}
impl SkYUVColorSpace {
    pub const Rec709: SkYUVColorSpace = SkYUVColorSpace::Rec709_Limited;
}
impl SkYUVColorSpace {
    pub const BT2020: SkYUVColorSpace = SkYUVColorSpace::BT2020_8bit_Limited;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkYUVColorSpace {
    JPEG_Full = 0,
    Rec601_Limited = 1,
    Rec709_Full = 2,
    Rec709_Limited = 3,
    BT2020_8bit_Full = 4,
    BT2020_8bit_Limited = 5,
    BT2020_10bit_Full = 6,
    BT2020_10bit_Limited = 7,
    BT2020_12bit_Full = 8,
    BT2020_12bit_Limited = 9,
    Identity = 10,
}
#[repr(C)]
#[derive(Debug)]
pub struct SkColorInfo {
    pub fColorSpace: sk_sp<SkColorSpace>,
    pub fColorType: SkColorType,
    pub fAlphaType: SkAlphaType,
}
#[test]
fn bindgen_test_layout_SkColorInfo() {
    assert_eq!(
        ::core::mem::size_of::<SkColorInfo>(),
        16usize,
        concat!("Size of: ", stringify!(SkColorInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<SkColorInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(SkColorInfo))
    );
    fn test_field_fColorSpace() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkColorInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fColorSpace) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SkColorInfo),
                "::",
                stringify!(fColorSpace)
            )
        );
    }
    test_field_fColorSpace();
    fn test_field_fColorType() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkColorInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fColorType) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(SkColorInfo),
                "::",
                stringify!(fColorType)
            )
        );
    }
    test_field_fColorType();
    fn test_field_fAlphaType() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkColorInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fAlphaType) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(SkColorInfo),
                "::",
                stringify!(fAlphaType)
            )
        );
    }
    test_field_fAlphaType();
}
extern "C" {
    #[link_name = "\u{1}__ZNK11SkColorInfo10colorSpaceEv"]
    pub fn SkColorInfo_colorSpace(this: *const SkColorInfo) -> *mut SkColorSpace;
}
extern "C" {
    #[link_name = "\u{1}__ZNK11SkColorInfo13refColorSpaceEv"]
    pub fn SkColorInfo_refColorSpace(this: *const SkColorInfo) -> sk_sp<SkColorSpace>;
}
extern "C" {
    #[link_name = "\u{1}__ZNK11SkColorInfo16gammaCloseToSRGBEv"]
    pub fn SkColorInfo_gammaCloseToSRGB(this: *const SkColorInfo) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK11SkColorInfo13makeAlphaTypeE11SkAlphaType"]
    pub fn SkColorInfo_makeAlphaType(
        this: *const SkColorInfo,
        newAlphaType: SkAlphaType,
    ) -> SkColorInfo;
}
extern "C" {
    #[link_name = "\u{1}__ZNK11SkColorInfo13makeColorTypeE11SkColorType"]
    pub fn SkColorInfo_makeColorType(
        this: *const SkColorInfo,
        newColorType: SkColorType,
    ) -> SkColorInfo;
}
extern "C" {
    #[link_name = "\u{1}__ZNK11SkColorInfo14makeColorSpaceE5sk_spI12SkColorSpaceE"]
    pub fn SkColorInfo_makeColorSpace(
        this: *const SkColorInfo,
        cs: sk_sp<SkColorSpace>,
    ) -> SkColorInfo;
}
extern "C" {
    #[link_name = "\u{1}__ZNK11SkColorInfo13bytesPerPixelEv"]
    pub fn SkColorInfo_bytesPerPixel(this: *const SkColorInfo) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__ZNK11SkColorInfo13shiftPerPixelEv"]
    pub fn SkColorInfo_shiftPerPixel(this: *const SkColorInfo) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__ZN11SkColorInfoC1Ev"]
    pub fn SkColorInfo_SkColorInfo(this: *mut SkColorInfo);
}
extern "C" {
    #[link_name = "\u{1}__ZN11SkColorInfoC1E11SkColorType11SkAlphaType5sk_spI12SkColorSpaceE"]
    pub fn SkColorInfo_SkColorInfo1(
        this: *mut SkColorInfo,
        ct: SkColorType,
        at: SkAlphaType,
        cs: sk_sp<SkColorSpace>,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN11SkColorInfoC1ERKS_"]
    pub fn SkColorInfo_SkColorInfo2(this: *mut SkColorInfo, arg1: *const SkColorInfo);
}
extern "C" {
    #[link_name = "\u{1}__ZN11SkColorInfoC1EOS_"]
    pub fn SkColorInfo_SkColorInfo3(this: *mut SkColorInfo, arg1: *mut SkColorInfo);
}
extern "C" {
    #[link_name = "\u{1}__ZN11SkColorInfoD1Ev"]
    pub fn SkColorInfo_SkColorInfo_destructor(this: *mut SkColorInfo);
}
impl SkColorInfo {
    #[inline]
    pub unsafe fn colorSpace(&self) -> *mut SkColorSpace {
        SkColorInfo_colorSpace(self)
    }
    #[inline]
    pub unsafe fn refColorSpace(&self) -> sk_sp<SkColorSpace> {
        SkColorInfo_refColorSpace(self)
    }
    #[inline]
    pub unsafe fn gammaCloseToSRGB(&self) -> bool {
        SkColorInfo_gammaCloseToSRGB(self)
    }
    #[inline]
    pub unsafe fn makeAlphaType(&self, newAlphaType: SkAlphaType) -> SkColorInfo {
        SkColorInfo_makeAlphaType(self, newAlphaType)
    }
    #[inline]
    pub unsafe fn makeColorType(&self, newColorType: SkColorType) -> SkColorInfo {
        SkColorInfo_makeColorType(self, newColorType)
    }
    #[inline]
    pub unsafe fn makeColorSpace(&self, cs: sk_sp<SkColorSpace>) -> SkColorInfo {
        SkColorInfo_makeColorSpace(self, cs)
    }
    #[inline]
    pub unsafe fn bytesPerPixel(&self) -> ::std::os::raw::c_int {
        SkColorInfo_bytesPerPixel(self)
    }
    #[inline]
    pub unsafe fn shiftPerPixel(&self) -> ::std::os::raw::c_int {
        SkColorInfo_shiftPerPixel(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkColorInfo_SkColorInfo(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(ct: SkColorType, at: SkAlphaType, cs: sk_sp<SkColorSpace>) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkColorInfo_SkColorInfo1(__bindgen_tmp.as_mut_ptr(), ct, at, cs);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(arg1: *const SkColorInfo) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkColorInfo_SkColorInfo2(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new3(arg1: *mut SkColorInfo) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkColorInfo_SkColorInfo3(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        SkColorInfo_SkColorInfo_destructor(self)
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct SkImageInfo {
    pub fColorInfo: SkColorInfo,
    pub fDimensions: SkISize,
}
#[test]
fn bindgen_test_layout_SkImageInfo() {
    assert_eq!(
        ::core::mem::size_of::<SkImageInfo>(),
        24usize,
        concat!("Size of: ", stringify!(SkImageInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<SkImageInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(SkImageInfo))
    );
    fn test_field_fColorInfo() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkImageInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fColorInfo) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SkImageInfo),
                "::",
                stringify!(fColorInfo)
            )
        );
    }
    test_field_fColorInfo();
    fn test_field_fDimensions() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkImageInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fDimensions) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(SkImageInfo),
                "::",
                stringify!(fDimensions)
            )
        );
    }
    test_field_fDimensions();
}
extern "C" {
    #[link_name = "\u{1}__ZN11SkImageInfo4MakeEii11SkColorType11SkAlphaType"]
    pub fn SkImageInfo_Make(
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        ct: SkColorType,
        at: SkAlphaType,
    ) -> SkImageInfo;
}
extern "C" {
    #[link_name = "\u{1}__ZN11SkImageInfo4MakeEii11SkColorType11SkAlphaType5sk_spI12SkColorSpaceE"]
    pub fn SkImageInfo_Make1(
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        ct: SkColorType,
        at: SkAlphaType,
        cs: sk_sp<SkColorSpace>,
    ) -> SkImageInfo;
}
extern "C" {
    #[link_name = "\u{1}__ZN11SkImageInfo4MakeE7SkISize11SkColorType11SkAlphaType"]
    pub fn SkImageInfo_Make2(dimensions: SkISize, ct: SkColorType, at: SkAlphaType) -> SkImageInfo;
}
extern "C" {
    #[link_name = "\u{1}__ZN11SkImageInfo4MakeE7SkISize11SkColorType11SkAlphaType5sk_spI12SkColorSpaceE"]
    pub fn SkImageInfo_Make3(
        dimensions: SkISize,
        ct: SkColorType,
        at: SkAlphaType,
        cs: sk_sp<SkColorSpace>,
    ) -> SkImageInfo;
}
extern "C" {
    #[link_name = "\u{1}__ZN11SkImageInfo7MakeN32Eii11SkAlphaType"]
    pub fn SkImageInfo_MakeN32(
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        at: SkAlphaType,
    ) -> SkImageInfo;
}
extern "C" {
    #[link_name = "\u{1}__ZN11SkImageInfo7MakeN32Eii11SkAlphaType5sk_spI12SkColorSpaceE"]
    pub fn SkImageInfo_MakeN321(
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        at: SkAlphaType,
        cs: sk_sp<SkColorSpace>,
    ) -> SkImageInfo;
}
extern "C" {
    #[link_name = "\u{1}__ZN11SkImageInfo7MakeS32Eii11SkAlphaType"]
    pub fn SkImageInfo_MakeS32(
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        at: SkAlphaType,
    ) -> SkImageInfo;
}
extern "C" {
    #[link_name = "\u{1}__ZN11SkImageInfo13MakeN32PremulEii"]
    pub fn SkImageInfo_MakeN32Premul(
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
    ) -> SkImageInfo;
}
extern "C" {
    #[link_name = "\u{1}__ZN11SkImageInfo13MakeN32PremulEii5sk_spI12SkColorSpaceE"]
    pub fn SkImageInfo_MakeN32Premul1(
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        cs: sk_sp<SkColorSpace>,
    ) -> SkImageInfo;
}
extern "C" {
    #[link_name = "\u{1}__ZN11SkImageInfo13MakeN32PremulE7SkISize"]
    pub fn SkImageInfo_MakeN32Premul2(dimensions: SkISize) -> SkImageInfo;
}
extern "C" {
    #[link_name = "\u{1}__ZN11SkImageInfo13MakeN32PremulE7SkISize5sk_spI12SkColorSpaceE"]
    pub fn SkImageInfo_MakeN32Premul3(dimensions: SkISize, cs: sk_sp<SkColorSpace>) -> SkImageInfo;
}
extern "C" {
    #[link_name = "\u{1}__ZN11SkImageInfo6MakeA8Eii"]
    pub fn SkImageInfo_MakeA8(
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
    ) -> SkImageInfo;
}
extern "C" {
    #[link_name = "\u{1}__ZN11SkImageInfo6MakeA8E7SkISize"]
    pub fn SkImageInfo_MakeA81(dimensions: SkISize) -> SkImageInfo;
}
extern "C" {
    #[link_name = "\u{1}__ZN11SkImageInfo11MakeUnknownEii"]
    pub fn SkImageInfo_MakeUnknown(
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
    ) -> SkImageInfo;
}
extern "C" {
    #[link_name = "\u{1}__ZNK11SkImageInfo10colorSpaceEv"]
    pub fn SkImageInfo_colorSpace(this: *const SkImageInfo) -> *mut SkColorSpace;
}
extern "C" {
    #[link_name = "\u{1}__ZNK11SkImageInfo13refColorSpaceEv"]
    pub fn SkImageInfo_refColorSpace(this: *const SkImageInfo) -> sk_sp<SkColorSpace>;
}
extern "C" {
    #[link_name = "\u{1}__ZNK11SkImageInfo14makeColorSpaceE5sk_spI12SkColorSpaceE"]
    pub fn SkImageInfo_makeColorSpace(
        this: *const SkImageInfo,
        cs: sk_sp<SkColorSpace>,
    ) -> SkImageInfo;
}
extern "C" {
    #[link_name = "\u{1}__ZNK11SkImageInfo13computeOffsetEiim"]
    pub fn SkImageInfo_computeOffset(
        this: *const SkImageInfo,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        rowBytes: usize,
    ) -> usize;
}
extern "C" {
    #[link_name = "\u{1}__ZNK11SkImageInfo15computeByteSizeEm"]
    pub fn SkImageInfo_computeByteSize(this: *const SkImageInfo, rowBytes: usize) -> usize;
}
impl SkImageInfo {
    #[inline]
    pub unsafe fn Make(
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        ct: SkColorType,
        at: SkAlphaType,
    ) -> SkImageInfo {
        SkImageInfo_Make(width, height, ct, at)
    }
    #[inline]
    pub unsafe fn Make1(
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        ct: SkColorType,
        at: SkAlphaType,
        cs: sk_sp<SkColorSpace>,
    ) -> SkImageInfo {
        SkImageInfo_Make1(width, height, ct, at, cs)
    }
    #[inline]
    pub unsafe fn Make2(dimensions: SkISize, ct: SkColorType, at: SkAlphaType) -> SkImageInfo {
        SkImageInfo_Make2(dimensions, ct, at)
    }
    #[inline]
    pub unsafe fn Make3(
        dimensions: SkISize,
        ct: SkColorType,
        at: SkAlphaType,
        cs: sk_sp<SkColorSpace>,
    ) -> SkImageInfo {
        SkImageInfo_Make3(dimensions, ct, at, cs)
    }
    #[inline]
    pub unsafe fn MakeN32(
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        at: SkAlphaType,
    ) -> SkImageInfo {
        SkImageInfo_MakeN32(width, height, at)
    }
    #[inline]
    pub unsafe fn MakeN321(
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        at: SkAlphaType,
        cs: sk_sp<SkColorSpace>,
    ) -> SkImageInfo {
        SkImageInfo_MakeN321(width, height, at, cs)
    }
    #[inline]
    pub unsafe fn MakeS32(
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        at: SkAlphaType,
    ) -> SkImageInfo {
        SkImageInfo_MakeS32(width, height, at)
    }
    #[inline]
    pub unsafe fn MakeN32Premul(
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
    ) -> SkImageInfo {
        SkImageInfo_MakeN32Premul(width, height)
    }
    #[inline]
    pub unsafe fn MakeN32Premul1(
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        cs: sk_sp<SkColorSpace>,
    ) -> SkImageInfo {
        SkImageInfo_MakeN32Premul1(width, height, cs)
    }
    #[inline]
    pub unsafe fn MakeN32Premul2(dimensions: SkISize) -> SkImageInfo {
        SkImageInfo_MakeN32Premul2(dimensions)
    }
    #[inline]
    pub unsafe fn MakeN32Premul3(dimensions: SkISize, cs: sk_sp<SkColorSpace>) -> SkImageInfo {
        SkImageInfo_MakeN32Premul3(dimensions, cs)
    }
    #[inline]
    pub unsafe fn MakeA8(
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
    ) -> SkImageInfo {
        SkImageInfo_MakeA8(width, height)
    }
    #[inline]
    pub unsafe fn MakeA81(dimensions: SkISize) -> SkImageInfo {
        SkImageInfo_MakeA81(dimensions)
    }
    #[inline]
    pub unsafe fn MakeUnknown(
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
    ) -> SkImageInfo {
        SkImageInfo_MakeUnknown(width, height)
    }
    #[inline]
    pub unsafe fn colorSpace(&self) -> *mut SkColorSpace {
        SkImageInfo_colorSpace(self)
    }
    #[inline]
    pub unsafe fn refColorSpace(&self) -> sk_sp<SkColorSpace> {
        SkImageInfo_refColorSpace(self)
    }
    #[inline]
    pub unsafe fn makeColorSpace(&self, cs: sk_sp<SkColorSpace>) -> SkImageInfo {
        SkImageInfo_makeColorSpace(self, cs)
    }
    #[inline]
    pub unsafe fn computeOffset(
        &self,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        rowBytes: usize,
    ) -> usize {
        SkImageInfo_computeOffset(self, x, y, rowBytes)
    }
    #[inline]
    pub unsafe fn computeByteSize(&self, rowBytes: usize) -> usize {
        SkImageInfo_computeByteSize(self, rowBytes)
    }
}
pub type SkColor = u32;
pub const SK_ColorTRANSPARENT: SkColor = 0;
pub const SK_ColorBLACK: SkColor = 4278190080;
pub const SK_ColorDKGRAY: SkColor = 4282664004;
pub const SK_ColorGRAY: SkColor = 4287137928;
pub const SK_ColorLTGRAY: SkColor = 4291611852;
pub const SK_ColorWHITE: SkColor = 4294967295;
pub const SK_ColorRED: SkColor = 4294901760;
pub const SK_ColorGREEN: SkColor = 4278255360;
pub const SK_ColorBLUE: SkColor = 4278190335;
pub const SK_ColorYELLOW: SkColor = 4294967040;
pub const SK_ColorCYAN: SkColor = 4278255615;
pub const SK_ColorMAGENTA: SkColor = 4294902015;
extern "C" {
    #[link_name = "\u{1}__Z10SkRGBToHSVjjjPf"]
    pub fn SkRGBToHSV(red: U8CPU, green: U8CPU, blue: U8CPU, hsv: *mut SkScalar);
}
extern "C" {
    #[link_name = "\u{1}__Z12SkHSVToColorjPKf"]
    pub fn SkHSVToColor(alpha: U8CPU, hsv: *const SkScalar) -> SkColor;
}
pub type SkPMColor = u32;
extern "C" {
    #[link_name = "\u{1}__Z17SkPreMultiplyARGBjjjj"]
    pub fn SkPreMultiplyARGB(a: U8CPU, r: U8CPU, g: U8CPU, b: U8CPU) -> SkPMColor;
}
extern "C" {
    #[link_name = "\u{1}__Z18SkPreMultiplyColorj"]
    pub fn SkPreMultiplyColor(c: SkColor) -> SkPMColor;
}
impl SkColorChannel {
    pub const LastEnum: SkColorChannel = SkColorChannel::A;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkColorChannel {
    R = 0,
    G = 1,
    B = 2,
    A = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkColorChannelFlag {
    kRed_SkColorChannelFlag = 1,
    kGreen_SkColorChannelFlag = 2,
    kBlue_SkColorChannelFlag = 4,
    kAlpha_SkColorChannelFlag = 8,
    kGray_SkColorChannelFlag = 16,
    kGrayAlpha_SkColorChannelFlags = 24,
    kRG_SkColorChannelFlags = 3,
    kRGB_SkColorChannelFlags = 7,
    kRGBA_SkColorChannelFlags = 15,
}
extern "C" {
    #[link_name = "\u{1}FromColor"]
    pub fn SkRGBA4f_FromColor(color: SkColor) -> u8;
}
extern "C" {
    #[link_name = "\u{1}toSkColor"]
    pub fn SkRGBA4f_toSkColor(this: *const u8) -> SkColor;
}
extern "C" {
    #[link_name = "\u{1}FromPMColor"]
    pub fn SkRGBA4f_FromPMColor(arg1: SkPMColor) -> u8;
}
extern "C" {
    #[link_name = "\u{1}toBytes_RGBA"]
    pub fn SkRGBA4f_toBytes_RGBA(this: *const u8) -> u32;
}
extern "C" {
    #[link_name = "\u{1}FromBytes_RGBA"]
    pub fn SkRGBA4f_FromBytes_RGBA(color: u32) -> u8;
}
pub type SkColor4f = [u32; 4usize];
impl SkFilterMode {
    pub const Last: SkFilterMode = SkFilterMode::Linear;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkFilterMode {
    Nearest = 0,
    Linear = 1,
}
impl SkMipmapMode {
    pub const Last: SkMipmapMode = SkMipmapMode::Linear;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkMipmapMode {
    None = 0,
    Nearest = 1,
    Linear = 2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkCubicResampler {
    pub B: f32,
    pub C: f32,
}
#[test]
fn bindgen_test_layout_SkCubicResampler() {
    assert_eq!(
        ::core::mem::size_of::<SkCubicResampler>(),
        8usize,
        concat!("Size of: ", stringify!(SkCubicResampler))
    );
    assert_eq!(
        ::core::mem::align_of::<SkCubicResampler>(),
        4usize,
        concat!("Alignment of ", stringify!(SkCubicResampler))
    );
    fn test_field_B() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkCubicResampler>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).B) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SkCubicResampler),
                "::",
                stringify!(B)
            )
        );
    }
    test_field_B();
    fn test_field_C() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkCubicResampler>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).C) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(SkCubicResampler),
                "::",
                stringify!(C)
            )
        );
    }
    test_field_C();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkSamplingOptions {
    pub maxAniso: ::std::os::raw::c_int,
    pub useCubic: bool,
    pub cubic: SkCubicResampler,
    pub filter: SkFilterMode,
    pub mipmap: SkMipmapMode,
}
#[test]
fn bindgen_test_layout_SkSamplingOptions() {
    assert_eq!(
        ::core::mem::size_of::<SkSamplingOptions>(),
        24usize,
        concat!("Size of: ", stringify!(SkSamplingOptions))
    );
    assert_eq!(
        ::core::mem::align_of::<SkSamplingOptions>(),
        4usize,
        concat!("Alignment of ", stringify!(SkSamplingOptions))
    );
    fn test_field_maxAniso() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkSamplingOptions>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).maxAniso) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SkSamplingOptions),
                "::",
                stringify!(maxAniso)
            )
        );
    }
    test_field_maxAniso();
    fn test_field_useCubic() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkSamplingOptions>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).useCubic) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(SkSamplingOptions),
                "::",
                stringify!(useCubic)
            )
        );
    }
    test_field_useCubic();
    fn test_field_cubic() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkSamplingOptions>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).cubic) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(SkSamplingOptions),
                "::",
                stringify!(cubic)
            )
        );
    }
    test_field_cubic();
    fn test_field_filter() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkSamplingOptions>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).filter) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(SkSamplingOptions),
                "::",
                stringify!(filter)
            )
        );
    }
    test_field_filter();
    fn test_field_mipmap() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkSamplingOptions>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).mipmap) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(SkSamplingOptions),
                "::",
                stringify!(mipmap)
            )
        );
    }
    test_field_mipmap();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkMask {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct SkPixmap {
    pub fPixels: *const ::core::ffi::c_void,
    pub fRowBytes: usize,
    pub fInfo: SkImageInfo,
}
#[test]
fn bindgen_test_layout_SkPixmap() {
    assert_eq!(
        ::core::mem::size_of::<SkPixmap>(),
        40usize,
        concat!("Size of: ", stringify!(SkPixmap))
    );
    assert_eq!(
        ::core::mem::align_of::<SkPixmap>(),
        8usize,
        concat!("Alignment of ", stringify!(SkPixmap))
    );
    fn test_field_fPixels() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkPixmap>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fPixels) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SkPixmap),
                "::",
                stringify!(fPixels)
            )
        );
    }
    test_field_fPixels();
    fn test_field_fRowBytes() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkPixmap>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fRowBytes) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(SkPixmap),
                "::",
                stringify!(fRowBytes)
            )
        );
    }
    test_field_fRowBytes();
    fn test_field_fInfo() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkPixmap>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fInfo) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(SkPixmap),
                "::",
                stringify!(fInfo)
            )
        );
    }
    test_field_fInfo();
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkPixmap5resetEv"]
    pub fn SkPixmap_reset(this: *mut SkPixmap);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkPixmap5resetERK11SkImageInfoPKvm"]
    pub fn SkPixmap_reset1(
        this: *mut SkPixmap,
        info: *const SkImageInfo,
        addr: *const ::core::ffi::c_void,
        rowBytes: usize,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkPixmap13setColorSpaceE5sk_spI12SkColorSpaceE"]
    pub fn SkPixmap_setColorSpace(this: *mut SkPixmap, colorSpace: sk_sp<SkColorSpace>);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkPixmap5resetERK6SkMask"]
    pub fn SkPixmap_reset2(this: *mut SkPixmap, mask: *const SkMask) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkPixmap13extractSubsetEPS_RK7SkIRect"]
    pub fn SkPixmap_extractSubset(
        this: *const SkPixmap,
        subset: *mut SkPixmap,
        area: *const SkIRect,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkPixmap10colorSpaceEv"]
    pub fn SkPixmap_colorSpace(this: *const SkPixmap) -> *mut SkColorSpace;
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkPixmap13refColorSpaceEv"]
    pub fn SkPixmap_refColorSpace(this: *const SkPixmap) -> sk_sp<SkColorSpace>;
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkPixmap15computeIsOpaqueEv"]
    pub fn SkPixmap_computeIsOpaque(this: *const SkPixmap) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkPixmap8getColorEii"]
    pub fn SkPixmap_getColor(
        this: *const SkPixmap,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
    ) -> SkColor;
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkPixmap10getColor4fEii"]
    pub fn SkPixmap_getColor4f(
        this: *const SkPixmap,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
    ) -> SkColor4f;
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkPixmap9getAlphafEii"]
    pub fn SkPixmap_getAlphaf(
        this: *const SkPixmap,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
    ) -> f32;
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkPixmap10readPixelsERK11SkImageInfoPvmii"]
    pub fn SkPixmap_readPixels(
        this: *const SkPixmap,
        dstInfo: *const SkImageInfo,
        dstPixels: *mut ::core::ffi::c_void,
        dstRowBytes: usize,
        srcX: ::std::os::raw::c_int,
        srcY: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkPixmap11scalePixelsERKS_RK17SkSamplingOptions"]
    pub fn SkPixmap_scalePixels(
        this: *const SkPixmap,
        dst: *const SkPixmap,
        arg1: *const SkSamplingOptions,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkPixmap5eraseEjRK7SkIRect"]
    pub fn SkPixmap_erase(this: *const SkPixmap, color: SkColor, subset: *const SkIRect) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkPixmap5eraseERK8SkRGBA4fIL11SkAlphaType3EEP12SkColorSpacePK7SkIRect"]
    pub fn SkPixmap_erase1(
        this: *const SkPixmap,
        color: *const SkColor4f,
        cs: *mut SkColorSpace,
        subset: *const SkIRect,
    ) -> bool;
}
impl SkPixmap {
    #[inline]
    pub unsafe fn reset(&mut self) {
        SkPixmap_reset(self)
    }
    #[inline]
    pub unsafe fn reset1(
        &mut self,
        info: *const SkImageInfo,
        addr: *const ::core::ffi::c_void,
        rowBytes: usize,
    ) {
        SkPixmap_reset1(self, info, addr, rowBytes)
    }
    #[inline]
    pub unsafe fn setColorSpace(&mut self, colorSpace: sk_sp<SkColorSpace>) {
        SkPixmap_setColorSpace(self, colorSpace)
    }
    #[inline]
    pub unsafe fn reset2(&mut self, mask: *const SkMask) -> bool {
        SkPixmap_reset2(self, mask)
    }
    #[inline]
    pub unsafe fn extractSubset(&self, subset: *mut SkPixmap, area: *const SkIRect) -> bool {
        SkPixmap_extractSubset(self, subset, area)
    }
    #[inline]
    pub unsafe fn colorSpace(&self) -> *mut SkColorSpace {
        SkPixmap_colorSpace(self)
    }
    #[inline]
    pub unsafe fn refColorSpace(&self) -> sk_sp<SkColorSpace> {
        SkPixmap_refColorSpace(self)
    }
    #[inline]
    pub unsafe fn computeIsOpaque(&self) -> bool {
        SkPixmap_computeIsOpaque(self)
    }
    #[inline]
    pub unsafe fn getColor(&self, x: ::std::os::raw::c_int, y: ::std::os::raw::c_int) -> SkColor {
        SkPixmap_getColor(self, x, y)
    }
    #[inline]
    pub unsafe fn getColor4f(
        &self,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
    ) -> SkColor4f {
        SkPixmap_getColor4f(self, x, y)
    }
    #[inline]
    pub unsafe fn getAlphaf(&self, x: ::std::os::raw::c_int, y: ::std::os::raw::c_int) -> f32 {
        SkPixmap_getAlphaf(self, x, y)
    }
    #[inline]
    pub unsafe fn readPixels(
        &self,
        dstInfo: *const SkImageInfo,
        dstPixels: *mut ::core::ffi::c_void,
        dstRowBytes: usize,
        srcX: ::std::os::raw::c_int,
        srcY: ::std::os::raw::c_int,
    ) -> bool {
        SkPixmap_readPixels(self, dstInfo, dstPixels, dstRowBytes, srcX, srcY)
    }
    #[inline]
    pub unsafe fn scalePixels(&self, dst: *const SkPixmap, arg1: *const SkSamplingOptions) -> bool {
        SkPixmap_scalePixels(self, dst, arg1)
    }
    #[inline]
    pub unsafe fn erase(&self, color: SkColor, subset: *const SkIRect) -> bool {
        SkPixmap_erase(self, color, subset)
    }
    #[inline]
    pub unsafe fn erase1(
        &self,
        color: *const SkColor4f,
        cs: *mut SkColorSpace,
        subset: *const SkIRect,
    ) -> bool {
        SkPixmap_erase1(self, color, cs, subset)
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct SkData {
    pub _base: SkNVRefCnt,
    pub fReleaseProc: SkData_ReleaseProc,
    pub fReleaseProcContext: *mut ::core::ffi::c_void,
    pub fPtr: *const ::core::ffi::c_void,
    pub fSize: usize,
}
pub type SkData_ReleaseProc = ::core::option::Option<
    unsafe extern "C" fn(ptr: *const ::core::ffi::c_void, context: *mut ::core::ffi::c_void),
>;
pub type SkData_INHERITED = SkRefCnt;
#[test]
fn bindgen_test_layout_SkData() {
    assert_eq!(
        ::core::mem::size_of::<SkData>(),
        40usize,
        concat!("Size of: ", stringify!(SkData))
    );
    assert_eq!(
        ::core::mem::align_of::<SkData>(),
        8usize,
        concat!("Alignment of ", stringify!(SkData))
    );
    fn test_field_fReleaseProc() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkData>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fReleaseProc) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(SkData),
                "::",
                stringify!(fReleaseProc)
            )
        );
    }
    test_field_fReleaseProc();
    fn test_field_fReleaseProcContext() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkData>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fReleaseProcContext) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(SkData),
                "::",
                stringify!(fReleaseProcContext)
            )
        );
    }
    test_field_fReleaseProcContext();
    fn test_field_fPtr() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkData>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fPtr) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(SkData),
                "::",
                stringify!(fPtr)
            )
        );
    }
    test_field_fPtr();
    fn test_field_fSize() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkData>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fSize) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(SkData),
                "::",
                stringify!(fSize)
            )
        );
    }
    test_field_fSize();
}
extern "C" {
    #[link_name = "\u{1}__ZNK6SkData9copyRangeEmmPv"]
    pub fn SkData_copyRange(
        this: *const SkData,
        offset: usize,
        length: usize,
        buffer: *mut ::core::ffi::c_void,
    ) -> usize;
}
extern "C" {
    #[link_name = "\u{1}__ZNK6SkData6equalsEPKS_"]
    pub fn SkData_equals(this: *const SkData, other: *const SkData) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkData12MakeWithCopyEPKvm"]
    pub fn SkData_MakeWithCopy(data: *const ::core::ffi::c_void, length: usize) -> sk_sp<SkData>;
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkData17MakeUninitializedEm"]
    pub fn SkData_MakeUninitialized(length: usize) -> sk_sp<SkData>;
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkData19MakeZeroInitializedEm"]
    pub fn SkData_MakeZeroInitialized(length: usize) -> sk_sp<SkData>;
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkData15MakeWithCStringEPKc"]
    pub fn SkData_MakeWithCString(cstr: *const ::std::os::raw::c_char) -> sk_sp<SkData>;
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkData12MakeWithProcEPKvmPFvS1_PvES2_"]
    pub fn SkData_MakeWithProc(
        ptr: *const ::core::ffi::c_void,
        length: usize,
        proc_: SkData_ReleaseProc,
        ctx: *mut ::core::ffi::c_void,
    ) -> sk_sp<SkData>;
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkData14MakeFromMallocEPKvm"]
    pub fn SkData_MakeFromMalloc(data: *const ::core::ffi::c_void, length: usize) -> sk_sp<SkData>;
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkData16MakeFromFileNameEPKc"]
    pub fn SkData_MakeFromFileName(path: *const ::std::os::raw::c_char) -> sk_sp<SkData>;
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkData12MakeFromFILEEP7__sFILE"]
    pub fn SkData_MakeFromFILE(f: *mut FILE) -> sk_sp<SkData>;
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkData10MakeFromFDEi"]
    pub fn SkData_MakeFromFD(fd: ::std::os::raw::c_int) -> sk_sp<SkData>;
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkData14MakeFromStreamEP8SkStreamm"]
    pub fn SkData_MakeFromStream(arg1: *mut SkStream, size: usize) -> sk_sp<SkData>;
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkData10MakeSubsetEPKS_mm"]
    pub fn SkData_MakeSubset(src: *const SkData, offset: usize, length: usize) -> sk_sp<SkData>;
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkData9MakeEmptyEv"]
    pub fn SkData_MakeEmpty() -> sk_sp<SkData>;
}
impl SkData {
    #[inline]
    pub unsafe fn copyRange(
        &self,
        offset: usize,
        length: usize,
        buffer: *mut ::core::ffi::c_void,
    ) -> usize {
        SkData_copyRange(self, offset, length, buffer)
    }
    #[inline]
    pub unsafe fn equals(&self, other: *const SkData) -> bool {
        SkData_equals(self, other)
    }
    #[inline]
    pub unsafe fn MakeWithCopy(data: *const ::core::ffi::c_void, length: usize) -> sk_sp<SkData> {
        SkData_MakeWithCopy(data, length)
    }
    #[inline]
    pub unsafe fn MakeUninitialized(length: usize) -> sk_sp<SkData> {
        SkData_MakeUninitialized(length)
    }
    #[inline]
    pub unsafe fn MakeZeroInitialized(length: usize) -> sk_sp<SkData> {
        SkData_MakeZeroInitialized(length)
    }
    #[inline]
    pub unsafe fn MakeWithCString(cstr: *const ::std::os::raw::c_char) -> sk_sp<SkData> {
        SkData_MakeWithCString(cstr)
    }
    #[inline]
    pub unsafe fn MakeWithProc(
        ptr: *const ::core::ffi::c_void,
        length: usize,
        proc_: SkData_ReleaseProc,
        ctx: *mut ::core::ffi::c_void,
    ) -> sk_sp<SkData> {
        SkData_MakeWithProc(ptr, length, proc_, ctx)
    }
    #[inline]
    pub unsafe fn MakeFromMalloc(data: *const ::core::ffi::c_void, length: usize) -> sk_sp<SkData> {
        SkData_MakeFromMalloc(data, length)
    }
    #[inline]
    pub unsafe fn MakeFromFileName(path: *const ::std::os::raw::c_char) -> sk_sp<SkData> {
        SkData_MakeFromFileName(path)
    }
    #[inline]
    pub unsafe fn MakeFromFILE(f: *mut FILE) -> sk_sp<SkData> {
        SkData_MakeFromFILE(f)
    }
    #[inline]
    pub unsafe fn MakeFromFD(fd: ::std::os::raw::c_int) -> sk_sp<SkData> {
        SkData_MakeFromFD(fd)
    }
    #[inline]
    pub unsafe fn MakeFromStream(arg1: *mut SkStream, size: usize) -> sk_sp<SkData> {
        SkData_MakeFromStream(arg1, size)
    }
    #[inline]
    pub unsafe fn MakeSubset(src: *const SkData, offset: usize, length: usize) -> sk_sp<SkData> {
        SkData_MakeSubset(src, offset, length)
    }
    #[inline]
    pub unsafe fn MakeEmpty() -> sk_sp<SkData> {
        SkData_MakeEmpty()
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkYUVAInfo {
    pub fDimensions: SkISize,
    pub fPlaneConfig: SkYUVAInfo_PlaneConfig,
    pub fSubsampling: SkYUVAInfo_Subsampling,
    pub fYUVColorSpace: SkYUVColorSpace,
    pub fOrigin: SkEncodedOrigin,
    pub fSitingX: SkYUVAInfo_Siting,
    pub fSitingY: SkYUVAInfo_Siting,
}
impl SkYUVAInfo_YUVAChannels {
    pub const kLast: SkYUVAInfo_YUVAChannels = SkYUVAInfo_YUVAChannels::kA;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkYUVAInfo_YUVAChannels {
    kY = 0,
    kU = 1,
    kV = 2,
    kA = 3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkYUVAInfo_YUVALocation {
    _unused: [u8; 0],
}
pub type SkYUVAInfo_YUVALocations = u8;
impl SkYUVAInfo_PlaneConfig {
    pub const Last: SkYUVAInfo_PlaneConfig = SkYUVAInfo_PlaneConfig::UYVA;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkYUVAInfo_PlaneConfig {
    Unknown = 0,
    Y_U_V = 1,
    Y_V_U = 2,
    Y_UV = 3,
    Y_VU = 4,
    YUV = 5,
    UYV = 6,
    Y_U_V_A = 7,
    Y_V_U_A = 8,
    Y_UV_A = 9,
    Y_VU_A = 10,
    YUVA = 11,
    UYVA = 12,
}
impl SkYUVAInfo_Subsampling {
    pub const kLast: SkYUVAInfo_Subsampling = SkYUVAInfo_Subsampling::k410;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkYUVAInfo_Subsampling {
    kUnknown = 0,
    k444 = 1,
    k422 = 2,
    k420 = 3,
    k440 = 4,
    k411 = 5,
    k410 = 6,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkYUVAInfo_Siting {
    Centered = 0,
}
pub const SkYUVAInfo_kYUVAChannelCount: ::std::os::raw::c_int = 4;
pub const SkYUVAInfo_kMaxPlanes: ::std::os::raw::c_int = 4;
#[test]
fn bindgen_test_layout_SkYUVAInfo() {
    assert_eq!(
        ::core::mem::size_of::<SkYUVAInfo>(),
        32usize,
        concat!("Size of: ", stringify!(SkYUVAInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<SkYUVAInfo>(),
        4usize,
        concat!("Alignment of ", stringify!(SkYUVAInfo))
    );
    fn test_field_fDimensions() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkYUVAInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fDimensions) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SkYUVAInfo),
                "::",
                stringify!(fDimensions)
            )
        );
    }
    test_field_fDimensions();
    fn test_field_fPlaneConfig() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkYUVAInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fPlaneConfig) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(SkYUVAInfo),
                "::",
                stringify!(fPlaneConfig)
            )
        );
    }
    test_field_fPlaneConfig();
    fn test_field_fSubsampling() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkYUVAInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fSubsampling) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(SkYUVAInfo),
                "::",
                stringify!(fSubsampling)
            )
        );
    }
    test_field_fSubsampling();
    fn test_field_fYUVColorSpace() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkYUVAInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fYUVColorSpace) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(SkYUVAInfo),
                "::",
                stringify!(fYUVColorSpace)
            )
        );
    }
    test_field_fYUVColorSpace();
    fn test_field_fOrigin() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkYUVAInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fOrigin) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(SkYUVAInfo),
                "::",
                stringify!(fOrigin)
            )
        );
    }
    test_field_fOrigin();
    fn test_field_fSitingX() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkYUVAInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fSitingX) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(SkYUVAInfo),
                "::",
                stringify!(fSitingX)
            )
        );
    }
    test_field_fSitingX();
    fn test_field_fSitingY() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkYUVAInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fSitingY) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(SkYUVAInfo),
                "::",
                stringify!(fSitingY)
            )
        );
    }
    test_field_fSitingY();
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkYUVAInfo18SubsamplingFactorsENS_11SubsamplingE"]
    pub fn SkYUVAInfo_SubsamplingFactors(arg1: SkYUVAInfo_Subsampling) -> [u32; 2usize];
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkYUVAInfo23PlaneSubsamplingFactorsENS_11PlaneConfigENS_11SubsamplingEi"]
    pub fn SkYUVAInfo_PlaneSubsamplingFactors(
        arg1: SkYUVAInfo_PlaneConfig,
        arg2: SkYUVAInfo_Subsampling,
        planeIdx: ::std::os::raw::c_int,
    ) -> [u32; 2usize];
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkYUVAInfo15PlaneDimensionsE7SkISizeNS_11PlaneConfigENS_11SubsamplingE15SkEncodedOriginPS0_"]
    pub fn SkYUVAInfo_PlaneDimensions(
        imageDimensions: SkISize,
        arg1: SkYUVAInfo_PlaneConfig,
        arg2: SkYUVAInfo_Subsampling,
        arg3: SkEncodedOrigin,
        planeDimensions: *mut SkISize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkYUVAInfo16GetYUVALocationsENS_11PlaneConfigEPKj"]
    pub fn SkYUVAInfo_GetYUVALocations(
        arg1: SkYUVAInfo_PlaneConfig,
        planeChannelFlags: *const u32,
    ) -> SkYUVAInfo_YUVALocations;
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkYUVAInfo8HasAlphaENS_11PlaneConfigE"]
    pub fn SkYUVAInfo_HasAlpha(arg1: SkYUVAInfo_PlaneConfig) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK10SkYUVAInfo17computeTotalBytesEPKmPm"]
    pub fn SkYUVAInfo_computeTotalBytes(
        this: *const SkYUVAInfo,
        rowBytes: *const usize,
        planeSizes: *mut usize,
    ) -> usize;
}
extern "C" {
    #[link_name = "\u{1}__ZNK10SkYUVAInfo15toYUVALocationsEPKj"]
    pub fn SkYUVAInfo_toYUVALocations(
        this: *const SkYUVAInfo,
        channelFlags: *const u32,
    ) -> SkYUVAInfo_YUVALocations;
}
extern "C" {
    #[link_name = "\u{1}__ZNK10SkYUVAInfo15makeSubsamplingENS_11SubsamplingE"]
    pub fn SkYUVAInfo_makeSubsampling(
        this: *const SkYUVAInfo,
        arg1: SkYUVAInfo_Subsampling,
    ) -> SkYUVAInfo;
}
extern "C" {
    #[link_name = "\u{1}__ZNK10SkYUVAInfo14makeDimensionsE7SkISize"]
    pub fn SkYUVAInfo_makeDimensions(this: *const SkYUVAInfo, arg1: SkISize) -> SkYUVAInfo;
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkYUVAInfoC1E7SkISizeNS_11PlaneConfigENS_11SubsamplingE15SkYUVColorSpace15SkEncodedOriginNS_6SitingES5_"]
    pub fn SkYUVAInfo_SkYUVAInfo(
        this: *mut SkYUVAInfo,
        dimensions: SkISize,
        arg1: SkYUVAInfo_PlaneConfig,
        arg2: SkYUVAInfo_Subsampling,
        arg3: SkYUVColorSpace,
        origin: SkEncodedOrigin,
        sitingX: SkYUVAInfo_Siting,
        sitingY: SkYUVAInfo_Siting,
    );
}
impl SkYUVAInfo {
    #[inline]
    pub unsafe fn SubsamplingFactors(arg1: SkYUVAInfo_Subsampling) -> [u32; 2usize] {
        SkYUVAInfo_SubsamplingFactors(arg1)
    }
    #[inline]
    pub unsafe fn PlaneSubsamplingFactors(
        arg1: SkYUVAInfo_PlaneConfig,
        arg2: SkYUVAInfo_Subsampling,
        planeIdx: ::std::os::raw::c_int,
    ) -> [u32; 2usize] {
        SkYUVAInfo_PlaneSubsamplingFactors(arg1, arg2, planeIdx)
    }
    #[inline]
    pub unsafe fn PlaneDimensions(
        imageDimensions: SkISize,
        arg1: SkYUVAInfo_PlaneConfig,
        arg2: SkYUVAInfo_Subsampling,
        arg3: SkEncodedOrigin,
        planeDimensions: *mut SkISize,
    ) -> ::std::os::raw::c_int {
        SkYUVAInfo_PlaneDimensions(imageDimensions, arg1, arg2, arg3, planeDimensions)
    }
    #[inline]
    pub unsafe fn GetYUVALocations(
        arg1: SkYUVAInfo_PlaneConfig,
        planeChannelFlags: *const u32,
    ) -> SkYUVAInfo_YUVALocations {
        SkYUVAInfo_GetYUVALocations(arg1, planeChannelFlags)
    }
    #[inline]
    pub unsafe fn HasAlpha(arg1: SkYUVAInfo_PlaneConfig) -> bool {
        SkYUVAInfo_HasAlpha(arg1)
    }
    #[inline]
    pub unsafe fn computeTotalBytes(
        &self,
        rowBytes: *const usize,
        planeSizes: *mut usize,
    ) -> usize {
        SkYUVAInfo_computeTotalBytes(self, rowBytes, planeSizes)
    }
    #[inline]
    pub unsafe fn toYUVALocations(&self, channelFlags: *const u32) -> SkYUVAInfo_YUVALocations {
        SkYUVAInfo_toYUVALocations(self, channelFlags)
    }
    #[inline]
    pub unsafe fn makeSubsampling(&self, arg1: SkYUVAInfo_Subsampling) -> SkYUVAInfo {
        SkYUVAInfo_makeSubsampling(self, arg1)
    }
    #[inline]
    pub unsafe fn makeDimensions(&self, arg1: SkISize) -> SkYUVAInfo {
        SkYUVAInfo_makeDimensions(self, arg1)
    }
    #[inline]
    pub unsafe fn new(
        dimensions: SkISize,
        arg1: SkYUVAInfo_PlaneConfig,
        arg2: SkYUVAInfo_Subsampling,
        arg3: SkYUVColorSpace,
        origin: SkEncodedOrigin,
        sitingX: SkYUVAInfo_Siting,
        sitingY: SkYUVAInfo_Siting,
    ) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkYUVAInfo_SkYUVAInfo(
            __bindgen_tmp.as_mut_ptr(),
            dimensions,
            arg1,
            arg2,
            arg3,
            origin,
            sitingX,
            sitingY,
        );
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
pub struct SkYUVAPixmapInfo {
    pub fYUVAInfo: SkYUVAInfo,
    pub fPlaneInfos: [u64; 12usize],
    pub fRowBytes: [u64; 4usize],
    pub fDataType: SkYUVAPixmapInfo_DataType,
}
pub use self::SkYUVAInfo_PlaneConfig as SkYUVAPixmapInfo_PlaneConfig;
pub use self::SkYUVAInfo_Subsampling as SkYUVAPixmapInfo_Subsampling;
impl SkYUVAPixmapInfo_DataType {
    pub const Last: SkYUVAPixmapInfo_DataType = SkYUVAPixmapInfo_DataType::Unorm10_Unorm2;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkYUVAPixmapInfo_DataType {
    Unorm8 = 0,
    Unorm16 = 1,
    Float16 = 2,
    Unorm10_Unorm2 = 3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkYUVAPixmapInfo_SupportedDataTypes {
    pub fDataTypeSupport: u64,
}
#[test]
fn bindgen_test_layout_SkYUVAPixmapInfo_SupportedDataTypes() {
    assert_eq!(
        ::core::mem::size_of::<SkYUVAPixmapInfo_SupportedDataTypes>(),
        8usize,
        concat!("Size of: ", stringify!(SkYUVAPixmapInfo_SupportedDataTypes))
    );
    assert_eq!(
        ::core::mem::align_of::<SkYUVAPixmapInfo_SupportedDataTypes>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(SkYUVAPixmapInfo_SupportedDataTypes)
        )
    );
    fn test_field_fDataTypeSupport() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::core::mem::MaybeUninit::<SkYUVAPixmapInfo_SupportedDataTypes>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fDataTypeSupport) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SkYUVAPixmapInfo_SupportedDataTypes),
                "::",
                stringify!(fDataTypeSupport)
            )
        );
    }
    test_field_fDataTypeSupport();
}
extern "C" {
    #[link_name = "\u{1}__ZN16SkYUVAPixmapInfo18SupportedDataTypes14enableDataTypeENS_8DataTypeEi"]
    pub fn SkYUVAPixmapInfo_SupportedDataTypes_enableDataType(
        this: *mut SkYUVAPixmapInfo_SupportedDataTypes,
        arg1: SkYUVAPixmapInfo_DataType,
        numChannels: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN16SkYUVAPixmapInfo18SupportedDataTypesC1ERK14GrImageContext"]
    pub fn SkYUVAPixmapInfo_SupportedDataTypes_SupportedDataTypes(
        this: *mut SkYUVAPixmapInfo_SupportedDataTypes,
        arg1: *const GrImageContext,
    );
}
impl SkYUVAPixmapInfo_SupportedDataTypes {
    #[inline]
    pub unsafe fn enableDataType(
        &mut self,
        arg1: SkYUVAPixmapInfo_DataType,
        numChannels: ::std::os::raw::c_int,
    ) {
        SkYUVAPixmapInfo_SupportedDataTypes_enableDataType(self, arg1, numChannels)
    }
    #[inline]
    pub unsafe fn new(arg1: *const GrImageContext) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkYUVAPixmapInfo_SupportedDataTypes_SupportedDataTypes(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
}
pub const SkYUVAPixmapInfo_kMaxPlanes: ::std::os::raw::c_int = 4;
pub const SkYUVAPixmapInfo_kDataTypeCnt: ::std::os::raw::c_int = 4;
#[test]
fn bindgen_test_layout_SkYUVAPixmapInfo() {
    assert_eq!(
        ::core::mem::size_of::<SkYUVAPixmapInfo>(),
        168usize,
        concat!("Size of: ", stringify!(SkYUVAPixmapInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<SkYUVAPixmapInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(SkYUVAPixmapInfo))
    );
    fn test_field_fYUVAInfo() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkYUVAPixmapInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fYUVAInfo) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SkYUVAPixmapInfo),
                "::",
                stringify!(fYUVAInfo)
            )
        );
    }
    test_field_fYUVAInfo();
    fn test_field_fPlaneInfos() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkYUVAPixmapInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fPlaneInfos) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(SkYUVAPixmapInfo),
                "::",
                stringify!(fPlaneInfos)
            )
        );
    }
    test_field_fPlaneInfos();
    fn test_field_fRowBytes() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkYUVAPixmapInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fRowBytes) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(SkYUVAPixmapInfo),
                "::",
                stringify!(fRowBytes)
            )
        );
    }
    test_field_fRowBytes();
    fn test_field_fDataType() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkYUVAPixmapInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fDataType) as usize - ptr as usize
            },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(SkYUVAPixmapInfo),
                "::",
                stringify!(fDataType)
            )
        );
    }
    test_field_fDataType();
}
extern "C" {
    #[link_name = "\u{1}__ZN16SkYUVAPixmapInfo22NumChannelsAndDataTypeE11SkColorType"]
    pub fn SkYUVAPixmapInfo_NumChannelsAndDataType(arg1: SkColorType) -> [u32; 2usize];
}
extern "C" {
    #[link_name = "\u{1}__ZNK16SkYUVAPixmapInfo17computeTotalBytesEPm"]
    pub fn SkYUVAPixmapInfo_computeTotalBytes(
        this: *const SkYUVAPixmapInfo,
        planeSizes: *mut usize,
    ) -> usize;
}
extern "C" {
    #[link_name = "\u{1}__ZNK16SkYUVAPixmapInfo31initPixmapsFromSingleAllocationEPvP8SkPixmap"]
    pub fn SkYUVAPixmapInfo_initPixmapsFromSingleAllocation(
        this: *const SkYUVAPixmapInfo,
        memory: *mut ::core::ffi::c_void,
        pixmaps: *mut SkPixmap,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK16SkYUVAPixmapInfo11isSupportedERKNS_18SupportedDataTypesE"]
    pub fn SkYUVAPixmapInfo_isSupported(
        this: *const SkYUVAPixmapInfo,
        arg1: *const SkYUVAPixmapInfo_SupportedDataTypes,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN16SkYUVAPixmapInfoC1ERK10SkYUVAInfoPK11SkColorTypePKm"]
    pub fn SkYUVAPixmapInfo_SkYUVAPixmapInfo(
        this: *mut SkYUVAPixmapInfo,
        arg1: *const SkYUVAInfo,
        arg2: *const SkColorType,
        rowBytes: *const usize,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN16SkYUVAPixmapInfoC1ERK10SkYUVAInfoNS_8DataTypeEPKm"]
    pub fn SkYUVAPixmapInfo_SkYUVAPixmapInfo1(
        this: *mut SkYUVAPixmapInfo,
        arg1: *const SkYUVAInfo,
        arg2: SkYUVAPixmapInfo_DataType,
        rowBytes: *const usize,
    );
}
impl SkYUVAPixmapInfo {
    #[inline]
    pub unsafe fn NumChannelsAndDataType(arg1: SkColorType) -> [u32; 2usize] {
        SkYUVAPixmapInfo_NumChannelsAndDataType(arg1)
    }
    #[inline]
    pub unsafe fn computeTotalBytes(&self, planeSizes: *mut usize) -> usize {
        SkYUVAPixmapInfo_computeTotalBytes(self, planeSizes)
    }
    #[inline]
    pub unsafe fn initPixmapsFromSingleAllocation(
        &self,
        memory: *mut ::core::ffi::c_void,
        pixmaps: *mut SkPixmap,
    ) -> bool {
        SkYUVAPixmapInfo_initPixmapsFromSingleAllocation(self, memory, pixmaps)
    }
    #[inline]
    pub unsafe fn isSupported(&self, arg1: *const SkYUVAPixmapInfo_SupportedDataTypes) -> bool {
        SkYUVAPixmapInfo_isSupported(self, arg1)
    }
    #[inline]
    pub unsafe fn new(
        arg1: *const SkYUVAInfo,
        arg2: *const SkColorType,
        rowBytes: *const usize,
    ) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkYUVAPixmapInfo_SkYUVAPixmapInfo(__bindgen_tmp.as_mut_ptr(), arg1, arg2, rowBytes);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(
        arg1: *const SkYUVAInfo,
        arg2: SkYUVAPixmapInfo_DataType,
        rowBytes: *const usize,
    ) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkYUVAPixmapInfo_SkYUVAPixmapInfo1(__bindgen_tmp.as_mut_ptr(), arg1, arg2, rowBytes);
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
pub struct SkYUVAPixmaps {
    pub fPlanes: [u64; 20usize],
    pub fData: sk_sp<SkData>,
    pub fYUVAInfo: SkYUVAInfo,
    pub fDataType: SkYUVAPixmaps_DataType,
}
pub use self::SkYUVAPixmapInfo_DataType as SkYUVAPixmaps_DataType;
pub const SkYUVAPixmaps_kMaxPlanes: ::std::os::raw::c_int = 4;
#[test]
fn bindgen_test_layout_SkYUVAPixmaps() {
    assert_eq!(
        ::core::mem::size_of::<SkYUVAPixmaps>(),
        208usize,
        concat!("Size of: ", stringify!(SkYUVAPixmaps))
    );
    assert_eq!(
        ::core::mem::align_of::<SkYUVAPixmaps>(),
        8usize,
        concat!("Alignment of ", stringify!(SkYUVAPixmaps))
    );
    fn test_field_fPlanes() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkYUVAPixmaps>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fPlanes) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SkYUVAPixmaps),
                "::",
                stringify!(fPlanes)
            )
        );
    }
    test_field_fPlanes();
    fn test_field_fData() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkYUVAPixmaps>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fData) as usize - ptr as usize
            },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(SkYUVAPixmaps),
                "::",
                stringify!(fData)
            )
        );
    }
    test_field_fData();
    fn test_field_fYUVAInfo() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkYUVAPixmaps>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fYUVAInfo) as usize - ptr as usize
            },
            168usize,
            concat!(
                "Offset of field: ",
                stringify!(SkYUVAPixmaps),
                "::",
                stringify!(fYUVAInfo)
            )
        );
    }
    test_field_fYUVAInfo();
    fn test_field_fDataType() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkYUVAPixmaps>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fDataType) as usize - ptr as usize
            },
            200usize,
            concat!(
                "Offset of field: ",
                stringify!(SkYUVAPixmaps),
                "::",
                stringify!(fDataType)
            )
        );
    }
    test_field_fDataType();
}
extern "C" {
    #[link_name = "\u{1}__ZN13SkYUVAPixmaps24RecommendedRGBAColorTypeEN16SkYUVAPixmapInfo8DataTypeE"]
    pub fn SkYUVAPixmaps_RecommendedRGBAColorType(arg1: SkYUVAPixmaps_DataType) -> SkColorType;
}
extern "C" {
    #[link_name = "\u{1}__ZN13SkYUVAPixmaps8AllocateERK16SkYUVAPixmapInfo"]
    pub fn SkYUVAPixmaps_Allocate(yuvaPixmapInfo: *const SkYUVAPixmapInfo) -> SkYUVAPixmaps;
}
extern "C" {
    #[link_name = "\u{1}__ZN13SkYUVAPixmaps8FromDataERK16SkYUVAPixmapInfo5sk_spI6SkDataE"]
    pub fn SkYUVAPixmaps_FromData(
        arg1: *const SkYUVAPixmapInfo,
        arg2: sk_sp<SkData>,
    ) -> SkYUVAPixmaps;
}
extern "C" {
    #[link_name = "\u{1}__ZN13SkYUVAPixmaps8MakeCopyERKS_"]
    pub fn SkYUVAPixmaps_MakeCopy(src: *const SkYUVAPixmaps) -> SkYUVAPixmaps;
}
extern "C" {
    #[link_name = "\u{1}__ZN13SkYUVAPixmaps18FromExternalMemoryERK16SkYUVAPixmapInfoPv"]
    pub fn SkYUVAPixmaps_FromExternalMemory(
        arg1: *const SkYUVAPixmapInfo,
        memory: *mut ::core::ffi::c_void,
    ) -> SkYUVAPixmaps;
}
extern "C" {
    #[link_name = "\u{1}__ZN13SkYUVAPixmaps19FromExternalPixmapsERK10SkYUVAInfoPK8SkPixmap"]
    pub fn SkYUVAPixmaps_FromExternalPixmaps(
        arg1: *const SkYUVAInfo,
        arg2: *const SkPixmap,
    ) -> SkYUVAPixmaps;
}
extern "C" {
    #[link_name = "\u{1}__ZNK13SkYUVAPixmaps11pixmapsInfoEv"]
    pub fn SkYUVAPixmaps_pixmapsInfo(this: *const SkYUVAPixmaps) -> SkYUVAPixmapInfo;
}
extern "C" {
    #[link_name = "\u{1}__ZNK13SkYUVAPixmaps15toYUVALocationsEv"]
    pub fn SkYUVAPixmaps_toYUVALocations(this: *const SkYUVAPixmaps) -> SkYUVAInfo_YUVALocations;
}
impl SkYUVAPixmaps {
    #[inline]
    pub unsafe fn RecommendedRGBAColorType(arg1: SkYUVAPixmaps_DataType) -> SkColorType {
        SkYUVAPixmaps_RecommendedRGBAColorType(arg1)
    }
    #[inline]
    pub unsafe fn Allocate(yuvaPixmapInfo: *const SkYUVAPixmapInfo) -> SkYUVAPixmaps {
        SkYUVAPixmaps_Allocate(yuvaPixmapInfo)
    }
    #[inline]
    pub unsafe fn FromData(arg1: *const SkYUVAPixmapInfo, arg2: sk_sp<SkData>) -> SkYUVAPixmaps {
        SkYUVAPixmaps_FromData(arg1, arg2)
    }
    #[inline]
    pub unsafe fn MakeCopy(src: *const SkYUVAPixmaps) -> SkYUVAPixmaps {
        SkYUVAPixmaps_MakeCopy(src)
    }
    #[inline]
    pub unsafe fn FromExternalMemory(
        arg1: *const SkYUVAPixmapInfo,
        memory: *mut ::core::ffi::c_void,
    ) -> SkYUVAPixmaps {
        SkYUVAPixmaps_FromExternalMemory(arg1, memory)
    }
    #[inline]
    pub unsafe fn FromExternalPixmaps(
        arg1: *const SkYUVAInfo,
        arg2: *const SkPixmap,
    ) -> SkYUVAPixmaps {
        SkYUVAPixmaps_FromExternalPixmaps(arg1, arg2)
    }
    #[inline]
    pub unsafe fn pixmapsInfo(&self) -> SkYUVAPixmapInfo {
        SkYUVAPixmaps_pixmapsInfo(self)
    }
    #[inline]
    pub unsafe fn toYUVALocations(&self) -> SkYUVAInfo_YUVALocations {
        SkYUVAPixmaps_toYUVALocations(self)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkOnce {
    pub fState: u8,
}
#[repr(u8)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkOnce_State {
    NotStarted = 0,
    Claimed = 1,
    Done = 2,
}
#[test]
fn bindgen_test_layout_SkOnce() {
    assert_eq!(
        ::core::mem::size_of::<SkOnce>(),
        1usize,
        concat!("Size of: ", stringify!(SkOnce))
    );
    assert_eq!(
        ::core::mem::align_of::<SkOnce>(),
        1usize,
        concat!("Alignment of ", stringify!(SkOnce))
    );
    fn test_field_fState() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkOnce>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fState) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SkOnce),
                "::",
                stringify!(fState)
            )
        );
    }
    test_field_fState();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct skcms_Matrix3x3 {
    pub vals: [[f32; 3usize]; 3usize],
}
#[test]
fn bindgen_test_layout_skcms_Matrix3x3() {
    assert_eq!(
        ::core::mem::size_of::<skcms_Matrix3x3>(),
        36usize,
        concat!("Size of: ", stringify!(skcms_Matrix3x3))
    );
    assert_eq!(
        ::core::mem::align_of::<skcms_Matrix3x3>(),
        4usize,
        concat!("Alignment of ", stringify!(skcms_Matrix3x3))
    );
    fn test_field_vals() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<skcms_Matrix3x3>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).vals) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(skcms_Matrix3x3),
                "::",
                stringify!(vals)
            )
        );
    }
    test_field_vals();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct skcms_Matrix3x4 {
    pub vals: [[f32; 4usize]; 3usize],
}
#[test]
fn bindgen_test_layout_skcms_Matrix3x4() {
    assert_eq!(
        ::core::mem::size_of::<skcms_Matrix3x4>(),
        48usize,
        concat!("Size of: ", stringify!(skcms_Matrix3x4))
    );
    assert_eq!(
        ::core::mem::align_of::<skcms_Matrix3x4>(),
        4usize,
        concat!("Alignment of ", stringify!(skcms_Matrix3x4))
    );
    fn test_field_vals() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<skcms_Matrix3x4>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).vals) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(skcms_Matrix3x4),
                "::",
                stringify!(vals)
            )
        );
    }
    test_field_vals();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct skcms_TransferFunction {
    pub g: f32,
    pub a: f32,
    pub b: f32,
    pub c: f32,
    pub d: f32,
    pub e: f32,
    pub f: f32,
}
#[test]
fn bindgen_test_layout_skcms_TransferFunction() {
    assert_eq!(
        ::core::mem::size_of::<skcms_TransferFunction>(),
        28usize,
        concat!("Size of: ", stringify!(skcms_TransferFunction))
    );
    assert_eq!(
        ::core::mem::align_of::<skcms_TransferFunction>(),
        4usize,
        concat!("Alignment of ", stringify!(skcms_TransferFunction))
    );
    fn test_field_g() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<skcms_TransferFunction>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).g) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(skcms_TransferFunction),
                "::",
                stringify!(g)
            )
        );
    }
    test_field_g();
    fn test_field_a() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<skcms_TransferFunction>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).a) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(skcms_TransferFunction),
                "::",
                stringify!(a)
            )
        );
    }
    test_field_a();
    fn test_field_b() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<skcms_TransferFunction>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).b) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(skcms_TransferFunction),
                "::",
                stringify!(b)
            )
        );
    }
    test_field_b();
    fn test_field_c() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<skcms_TransferFunction>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).c) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(skcms_TransferFunction),
                "::",
                stringify!(c)
            )
        );
    }
    test_field_c();
    fn test_field_d() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<skcms_TransferFunction>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).d) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(skcms_TransferFunction),
                "::",
                stringify!(d)
            )
        );
    }
    test_field_d();
    fn test_field_e() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<skcms_TransferFunction>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).e) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(skcms_TransferFunction),
                "::",
                stringify!(e)
            )
        );
    }
    test_field_e();
    fn test_field_f() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<skcms_TransferFunction>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).f) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(skcms_TransferFunction),
                "::",
                stringify!(f)
            )
        );
    }
    test_field_f();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union skcms_Curve {
    pub __bindgen_anon_1: skcms_Curve__bindgen_ty_1,
    pub __bindgen_anon_2: skcms_Curve__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct skcms_Curve__bindgen_ty_1 {
    pub alias_of_table_entries: u32,
    pub parametric: skcms_TransferFunction,
}
#[test]
fn bindgen_test_layout_skcms_Curve__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<skcms_Curve__bindgen_ty_1>(),
        32usize,
        concat!("Size of: ", stringify!(skcms_Curve__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<skcms_Curve__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(skcms_Curve__bindgen_ty_1))
    );
    fn test_field_alias_of_table_entries() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<skcms_Curve__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).alias_of_table_entries) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(skcms_Curve__bindgen_ty_1),
                "::",
                stringify!(alias_of_table_entries)
            )
        );
    }
    test_field_alias_of_table_entries();
    fn test_field_parametric() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<skcms_Curve__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).parametric) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(skcms_Curve__bindgen_ty_1),
                "::",
                stringify!(parametric)
            )
        );
    }
    test_field_parametric();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct skcms_Curve__bindgen_ty_2 {
    pub table_entries: u32,
    pub table_8: *const u8,
    pub table_16: *const u8,
}
#[test]
fn bindgen_test_layout_skcms_Curve__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<skcms_Curve__bindgen_ty_2>(),
        24usize,
        concat!("Size of: ", stringify!(skcms_Curve__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<skcms_Curve__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(skcms_Curve__bindgen_ty_2))
    );
    fn test_field_table_entries() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<skcms_Curve__bindgen_ty_2>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).table_entries) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(skcms_Curve__bindgen_ty_2),
                "::",
                stringify!(table_entries)
            )
        );
    }
    test_field_table_entries();
    fn test_field_table_8() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<skcms_Curve__bindgen_ty_2>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).table_8) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(skcms_Curve__bindgen_ty_2),
                "::",
                stringify!(table_8)
            )
        );
    }
    test_field_table_8();
    fn test_field_table_16() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<skcms_Curve__bindgen_ty_2>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).table_16) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(skcms_Curve__bindgen_ty_2),
                "::",
                stringify!(table_16)
            )
        );
    }
    test_field_table_16();
}
#[test]
fn bindgen_test_layout_skcms_Curve() {
    assert_eq!(
        ::core::mem::size_of::<skcms_Curve>(),
        32usize,
        concat!("Size of: ", stringify!(skcms_Curve))
    );
    assert_eq!(
        ::core::mem::align_of::<skcms_Curve>(),
        8usize,
        concat!("Alignment of ", stringify!(skcms_Curve))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct skcms_A2B {
    pub input_channels: u32,
    pub input_curves: [skcms_Curve; 4usize],
    pub grid_points: [u8; 4usize],
    pub grid_8: *const u8,
    pub grid_16: *const u8,
    pub matrix_channels: u32,
    pub matrix_curves: [skcms_Curve; 3usize],
    pub matrix: skcms_Matrix3x4,
    pub output_channels: u32,
    pub output_curves: [skcms_Curve; 3usize],
}
#[test]
fn bindgen_test_layout_skcms_A2B() {
    assert_eq!(
        ::core::mem::size_of::<skcms_A2B>(),
        416usize,
        concat!("Size of: ", stringify!(skcms_A2B))
    );
    assert_eq!(
        ::core::mem::align_of::<skcms_A2B>(),
        8usize,
        concat!("Alignment of ", stringify!(skcms_A2B))
    );
    fn test_field_input_channels() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<skcms_A2B>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).input_channels) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(skcms_A2B),
                "::",
                stringify!(input_channels)
            )
        );
    }
    test_field_input_channels();
    fn test_field_input_curves() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<skcms_A2B>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).input_curves) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(skcms_A2B),
                "::",
                stringify!(input_curves)
            )
        );
    }
    test_field_input_curves();
    fn test_field_grid_points() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<skcms_A2B>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).grid_points) as usize - ptr as usize
            },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(skcms_A2B),
                "::",
                stringify!(grid_points)
            )
        );
    }
    test_field_grid_points();
    fn test_field_grid_8() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<skcms_A2B>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).grid_8) as usize - ptr as usize
            },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(skcms_A2B),
                "::",
                stringify!(grid_8)
            )
        );
    }
    test_field_grid_8();
    fn test_field_grid_16() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<skcms_A2B>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).grid_16) as usize - ptr as usize
            },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(skcms_A2B),
                "::",
                stringify!(grid_16)
            )
        );
    }
    test_field_grid_16();
    fn test_field_matrix_channels() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<skcms_A2B>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).matrix_channels) as usize - ptr as usize
            },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(skcms_A2B),
                "::",
                stringify!(matrix_channels)
            )
        );
    }
    test_field_matrix_channels();
    fn test_field_matrix_curves() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<skcms_A2B>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).matrix_curves) as usize - ptr as usize
            },
            168usize,
            concat!(
                "Offset of field: ",
                stringify!(skcms_A2B),
                "::",
                stringify!(matrix_curves)
            )
        );
    }
    test_field_matrix_curves();
    fn test_field_matrix() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<skcms_A2B>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).matrix) as usize - ptr as usize
            },
            264usize,
            concat!(
                "Offset of field: ",
                stringify!(skcms_A2B),
                "::",
                stringify!(matrix)
            )
        );
    }
    test_field_matrix();
    fn test_field_output_channels() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<skcms_A2B>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).output_channels) as usize - ptr as usize
            },
            312usize,
            concat!(
                "Offset of field: ",
                stringify!(skcms_A2B),
                "::",
                stringify!(output_channels)
            )
        );
    }
    test_field_output_channels();
    fn test_field_output_curves() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<skcms_A2B>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).output_curves) as usize - ptr as usize
            },
            320usize,
            concat!(
                "Offset of field: ",
                stringify!(skcms_A2B),
                "::",
                stringify!(output_curves)
            )
        );
    }
    test_field_output_curves();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct skcms_B2A {
    pub input_channels: u32,
    pub input_curves: [skcms_Curve; 3usize],
    pub matrix_channels: u32,
    pub matrix: skcms_Matrix3x4,
    pub matrix_curves: [skcms_Curve; 3usize],
    pub output_channels: u32,
    pub grid_points: [u8; 4usize],
    pub grid_8: *const u8,
    pub grid_16: *const u8,
    pub output_curves: [skcms_Curve; 4usize],
}
#[test]
fn bindgen_test_layout_skcms_B2A() {
    assert_eq!(
        ::core::mem::size_of::<skcms_B2A>(),
        408usize,
        concat!("Size of: ", stringify!(skcms_B2A))
    );
    assert_eq!(
        ::core::mem::align_of::<skcms_B2A>(),
        8usize,
        concat!("Alignment of ", stringify!(skcms_B2A))
    );
    fn test_field_input_channels() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<skcms_B2A>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).input_channels) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(skcms_B2A),
                "::",
                stringify!(input_channels)
            )
        );
    }
    test_field_input_channels();
    fn test_field_input_curves() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<skcms_B2A>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).input_curves) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(skcms_B2A),
                "::",
                stringify!(input_curves)
            )
        );
    }
    test_field_input_curves();
    fn test_field_matrix_channels() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<skcms_B2A>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).matrix_channels) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(skcms_B2A),
                "::",
                stringify!(matrix_channels)
            )
        );
    }
    test_field_matrix_channels();
    fn test_field_matrix() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<skcms_B2A>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).matrix) as usize - ptr as usize
            },
            108usize,
            concat!(
                "Offset of field: ",
                stringify!(skcms_B2A),
                "::",
                stringify!(matrix)
            )
        );
    }
    test_field_matrix();
    fn test_field_matrix_curves() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<skcms_B2A>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).matrix_curves) as usize - ptr as usize
            },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(skcms_B2A),
                "::",
                stringify!(matrix_curves)
            )
        );
    }
    test_field_matrix_curves();
    fn test_field_output_channels() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<skcms_B2A>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).output_channels) as usize - ptr as usize
            },
            256usize,
            concat!(
                "Offset of field: ",
                stringify!(skcms_B2A),
                "::",
                stringify!(output_channels)
            )
        );
    }
    test_field_output_channels();
    fn test_field_grid_points() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<skcms_B2A>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).grid_points) as usize - ptr as usize
            },
            260usize,
            concat!(
                "Offset of field: ",
                stringify!(skcms_B2A),
                "::",
                stringify!(grid_points)
            )
        );
    }
    test_field_grid_points();
    fn test_field_grid_8() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<skcms_B2A>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).grid_8) as usize - ptr as usize
            },
            264usize,
            concat!(
                "Offset of field: ",
                stringify!(skcms_B2A),
                "::",
                stringify!(grid_8)
            )
        );
    }
    test_field_grid_8();
    fn test_field_grid_16() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<skcms_B2A>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).grid_16) as usize - ptr as usize
            },
            272usize,
            concat!(
                "Offset of field: ",
                stringify!(skcms_B2A),
                "::",
                stringify!(grid_16)
            )
        );
    }
    test_field_grid_16();
    fn test_field_output_curves() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<skcms_B2A>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).output_curves) as usize - ptr as usize
            },
            280usize,
            concat!(
                "Offset of field: ",
                stringify!(skcms_B2A),
                "::",
                stringify!(output_curves)
            )
        );
    }
    test_field_output_curves();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct skcms_ICCProfile {
    pub buffer: *const u8,
    pub size: u32,
    pub data_color_space: u32,
    pub pcs: u32,
    pub tag_count: u32,
    pub has_trc: bool,
    pub trc: [skcms_Curve; 3usize],
    pub has_toXYZD50: bool,
    pub toXYZD50: skcms_Matrix3x3,
    pub has_A2B: bool,
    pub A2B: skcms_A2B,
    pub has_B2A: bool,
    pub B2A: skcms_B2A,
}
#[test]
fn bindgen_test_layout_skcms_ICCProfile() {
    assert_eq!(
        ::core::mem::size_of::<skcms_ICCProfile>(),
        1008usize,
        concat!("Size of: ", stringify!(skcms_ICCProfile))
    );
    assert_eq!(
        ::core::mem::align_of::<skcms_ICCProfile>(),
        8usize,
        concat!("Alignment of ", stringify!(skcms_ICCProfile))
    );
    fn test_field_buffer() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<skcms_ICCProfile>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(skcms_ICCProfile),
                "::",
                stringify!(buffer)
            )
        );
    }
    test_field_buffer();
    fn test_field_size() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<skcms_ICCProfile>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).size) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(skcms_ICCProfile),
                "::",
                stringify!(size)
            )
        );
    }
    test_field_size();
    fn test_field_data_color_space() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<skcms_ICCProfile>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).data_color_space) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(skcms_ICCProfile),
                "::",
                stringify!(data_color_space)
            )
        );
    }
    test_field_data_color_space();
    fn test_field_pcs() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<skcms_ICCProfile>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).pcs) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(skcms_ICCProfile),
                "::",
                stringify!(pcs)
            )
        );
    }
    test_field_pcs();
    fn test_field_tag_count() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<skcms_ICCProfile>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).tag_count) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(skcms_ICCProfile),
                "::",
                stringify!(tag_count)
            )
        );
    }
    test_field_tag_count();
    fn test_field_has_trc() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<skcms_ICCProfile>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).has_trc) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(skcms_ICCProfile),
                "::",
                stringify!(has_trc)
            )
        );
    }
    test_field_has_trc();
    fn test_field_trc() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<skcms_ICCProfile>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).trc) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(skcms_ICCProfile),
                "::",
                stringify!(trc)
            )
        );
    }
    test_field_trc();
    fn test_field_has_toXYZD50() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<skcms_ICCProfile>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).has_toXYZD50) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(skcms_ICCProfile),
                "::",
                stringify!(has_toXYZD50)
            )
        );
    }
    test_field_has_toXYZD50();
    fn test_field_toXYZD50() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<skcms_ICCProfile>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).toXYZD50) as usize - ptr as usize
            },
            132usize,
            concat!(
                "Offset of field: ",
                stringify!(skcms_ICCProfile),
                "::",
                stringify!(toXYZD50)
            )
        );
    }
    test_field_toXYZD50();
    fn test_field_has_A2B() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<skcms_ICCProfile>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).has_A2B) as usize - ptr as usize
            },
            168usize,
            concat!(
                "Offset of field: ",
                stringify!(skcms_ICCProfile),
                "::",
                stringify!(has_A2B)
            )
        );
    }
    test_field_has_A2B();
    fn test_field_A2B() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<skcms_ICCProfile>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).A2B) as usize - ptr as usize
            },
            176usize,
            concat!(
                "Offset of field: ",
                stringify!(skcms_ICCProfile),
                "::",
                stringify!(A2B)
            )
        );
    }
    test_field_A2B();
    fn test_field_has_B2A() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<skcms_ICCProfile>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).has_B2A) as usize - ptr as usize
            },
            592usize,
            concat!(
                "Offset of field: ",
                stringify!(skcms_ICCProfile),
                "::",
                stringify!(has_B2A)
            )
        );
    }
    test_field_has_B2A();
    fn test_field_B2A() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<skcms_ICCProfile>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).B2A) as usize - ptr as usize
            },
            600usize,
            concat!(
                "Offset of field: ",
                stringify!(skcms_ICCProfile),
                "::",
                stringify!(B2A)
            )
        );
    }
    test_field_B2A();
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum skcms_PixelFormat {
    skcms_PixelFormat_A_8 = 0,
    skcms_PixelFormat_A_8_ = 1,
    skcms_PixelFormat_G_8 = 2,
    skcms_PixelFormat_G_8_ = 3,
    skcms_PixelFormat_RGBA_8888_Palette8 = 4,
    skcms_PixelFormat_BGRA_8888_Palette8 = 5,
    skcms_PixelFormat_RGB_565 = 6,
    skcms_PixelFormat_BGR_565 = 7,
    skcms_PixelFormat_ABGR_4444 = 8,
    skcms_PixelFormat_ARGB_4444 = 9,
    skcms_PixelFormat_RGB_888 = 10,
    skcms_PixelFormat_BGR_888 = 11,
    skcms_PixelFormat_RGBA_8888 = 12,
    skcms_PixelFormat_BGRA_8888 = 13,
    skcms_PixelFormat_RGBA_8888_sRGB = 14,
    skcms_PixelFormat_BGRA_8888_sRGB = 15,
    skcms_PixelFormat_RGBA_1010102 = 16,
    skcms_PixelFormat_BGRA_1010102 = 17,
    skcms_PixelFormat_RGB_161616LE = 18,
    skcms_PixelFormat_BGR_161616LE = 19,
    skcms_PixelFormat_RGBA_16161616LE = 20,
    skcms_PixelFormat_BGRA_16161616LE = 21,
    skcms_PixelFormat_RGB_161616BE = 22,
    skcms_PixelFormat_BGR_161616BE = 23,
    skcms_PixelFormat_RGBA_16161616BE = 24,
    skcms_PixelFormat_BGRA_16161616BE = 25,
    skcms_PixelFormat_RGB_hhh_Norm = 26,
    skcms_PixelFormat_BGR_hhh_Norm = 27,
    skcms_PixelFormat_RGBA_hhhh_Norm = 28,
    skcms_PixelFormat_BGRA_hhhh_Norm = 29,
    skcms_PixelFormat_RGB_hhh = 30,
    skcms_PixelFormat_BGR_hhh = 31,
    skcms_PixelFormat_RGBA_hhhh = 32,
    skcms_PixelFormat_BGRA_hhhh = 33,
    skcms_PixelFormat_RGB_fff = 34,
    skcms_PixelFormat_BGR_fff = 35,
    skcms_PixelFormat_RGBA_ffff = 36,
    skcms_PixelFormat_BGRA_ffff = 37,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum skcms_AlphaFormat {
    skcms_AlphaFormat_Opaque = 0,
    skcms_AlphaFormat_Unpremul = 1,
    skcms_AlphaFormat_PremulAsEncoded = 2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkColorSpacePrimaries {
    pub fRX: f32,
    pub fRY: f32,
    pub fGX: f32,
    pub fGY: f32,
    pub fBX: f32,
    pub fBY: f32,
    pub fWX: f32,
    pub fWY: f32,
}
#[test]
fn bindgen_test_layout_SkColorSpacePrimaries() {
    assert_eq!(
        ::core::mem::size_of::<SkColorSpacePrimaries>(),
        32usize,
        concat!("Size of: ", stringify!(SkColorSpacePrimaries))
    );
    assert_eq!(
        ::core::mem::align_of::<SkColorSpacePrimaries>(),
        4usize,
        concat!("Alignment of ", stringify!(SkColorSpacePrimaries))
    );
    fn test_field_fRX() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkColorSpacePrimaries>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fRX) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SkColorSpacePrimaries),
                "::",
                stringify!(fRX)
            )
        );
    }
    test_field_fRX();
    fn test_field_fRY() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkColorSpacePrimaries>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fRY) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(SkColorSpacePrimaries),
                "::",
                stringify!(fRY)
            )
        );
    }
    test_field_fRY();
    fn test_field_fGX() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkColorSpacePrimaries>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fGX) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(SkColorSpacePrimaries),
                "::",
                stringify!(fGX)
            )
        );
    }
    test_field_fGX();
    fn test_field_fGY() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkColorSpacePrimaries>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fGY) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(SkColorSpacePrimaries),
                "::",
                stringify!(fGY)
            )
        );
    }
    test_field_fGY();
    fn test_field_fBX() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkColorSpacePrimaries>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fBX) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(SkColorSpacePrimaries),
                "::",
                stringify!(fBX)
            )
        );
    }
    test_field_fBX();
    fn test_field_fBY() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkColorSpacePrimaries>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fBY) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(SkColorSpacePrimaries),
                "::",
                stringify!(fBY)
            )
        );
    }
    test_field_fBY();
    fn test_field_fWX() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkColorSpacePrimaries>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fWX) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(SkColorSpacePrimaries),
                "::",
                stringify!(fWX)
            )
        );
    }
    test_field_fWX();
    fn test_field_fWY() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkColorSpacePrimaries>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fWY) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(SkColorSpacePrimaries),
                "::",
                stringify!(fWY)
            )
        );
    }
    test_field_fWY();
}
extern "C" {
    #[link_name = "\u{1}__ZNK21SkColorSpacePrimaries8toXYZD50EP15skcms_Matrix3x3"]
    pub fn SkColorSpacePrimaries_toXYZD50(
        this: *const SkColorSpacePrimaries,
        toXYZD50: *mut skcms_Matrix3x3,
    ) -> bool;
}
impl SkColorSpacePrimaries {
    #[inline]
    pub unsafe fn toXYZD50(&self, toXYZD50: *mut skcms_Matrix3x3) -> bool {
        SkColorSpacePrimaries_toXYZD50(self, toXYZD50)
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct SkColorSpace {
    pub _base: SkNVRefCnt,
    pub fTransferFnHash: u32,
    pub fToXYZD50Hash: u32,
    pub fTransferFn: skcms_TransferFunction,
    pub fToXYZD50: skcms_Matrix3x3,
    pub fInvTransferFn: skcms_TransferFunction,
    pub fFromXYZD50: skcms_Matrix3x3,
    pub fLazyDstFieldsOnce: SkOnce,
}
#[test]
fn bindgen_test_layout_SkColorSpace() {
    assert_eq!(
        ::core::mem::size_of::<SkColorSpace>(),
        144usize,
        concat!("Size of: ", stringify!(SkColorSpace))
    );
    assert_eq!(
        ::core::mem::align_of::<SkColorSpace>(),
        4usize,
        concat!("Alignment of ", stringify!(SkColorSpace))
    );
    fn test_field_fTransferFnHash() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkColorSpace>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fTransferFnHash) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(SkColorSpace),
                "::",
                stringify!(fTransferFnHash)
            )
        );
    }
    test_field_fTransferFnHash();
    fn test_field_fToXYZD50Hash() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkColorSpace>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fToXYZD50Hash) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(SkColorSpace),
                "::",
                stringify!(fToXYZD50Hash)
            )
        );
    }
    test_field_fToXYZD50Hash();
    fn test_field_fTransferFn() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkColorSpace>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fTransferFn) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(SkColorSpace),
                "::",
                stringify!(fTransferFn)
            )
        );
    }
    test_field_fTransferFn();
    fn test_field_fToXYZD50() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkColorSpace>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fToXYZD50) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(SkColorSpace),
                "::",
                stringify!(fToXYZD50)
            )
        );
    }
    test_field_fToXYZD50();
    fn test_field_fInvTransferFn() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkColorSpace>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fInvTransferFn) as usize - ptr as usize
            },
            76usize,
            concat!(
                "Offset of field: ",
                stringify!(SkColorSpace),
                "::",
                stringify!(fInvTransferFn)
            )
        );
    }
    test_field_fInvTransferFn();
    fn test_field_fFromXYZD50() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkColorSpace>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fFromXYZD50) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(SkColorSpace),
                "::",
                stringify!(fFromXYZD50)
            )
        );
    }
    test_field_fFromXYZD50();
    fn test_field_fLazyDstFieldsOnce() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkColorSpace>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fLazyDstFieldsOnce) as usize - ptr as usize
            },
            140usize,
            concat!(
                "Offset of field: ",
                stringify!(SkColorSpace),
                "::",
                stringify!(fLazyDstFieldsOnce)
            )
        );
    }
    test_field_fLazyDstFieldsOnce();
}
extern "C" {
    #[link_name = "\u{1}__ZN12SkColorSpace8MakeSRGBEv"]
    pub fn SkColorSpace_MakeSRGB() -> sk_sp<SkColorSpace>;
}
extern "C" {
    #[link_name = "\u{1}__ZN12SkColorSpace14MakeSRGBLinearEv"]
    pub fn SkColorSpace_MakeSRGBLinear() -> sk_sp<SkColorSpace>;
}
extern "C" {
    #[link_name = "\u{1}__ZN12SkColorSpace7MakeRGBERK22skcms_TransferFunctionRK15skcms_Matrix3x3"]
    pub fn SkColorSpace_MakeRGB(
        transferFn: *const skcms_TransferFunction,
        toXYZ: *const skcms_Matrix3x3,
    ) -> sk_sp<SkColorSpace>;
}
extern "C" {
    #[link_name = "\u{1}__ZN12SkColorSpace4MakeERK16skcms_ICCProfile"]
    pub fn SkColorSpace_Make(arg1: *const skcms_ICCProfile) -> sk_sp<SkColorSpace>;
}
extern "C" {
    #[link_name = "\u{1}__ZNK12SkColorSpace9toProfileEP16skcms_ICCProfile"]
    pub fn SkColorSpace_toProfile(this: *const SkColorSpace, arg1: *mut skcms_ICCProfile);
}
extern "C" {
    #[link_name = "\u{1}__ZNK12SkColorSpace16gammaCloseToSRGBEv"]
    pub fn SkColorSpace_gammaCloseToSRGB(this: *const SkColorSpace) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK12SkColorSpace13gammaIsLinearEv"]
    pub fn SkColorSpace_gammaIsLinear(this: *const SkColorSpace) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK12SkColorSpace21isNumericalTransferFnEP22skcms_TransferFunction"]
    pub fn SkColorSpace_isNumericalTransferFn(
        this: *const SkColorSpace,
        fn_: *mut skcms_TransferFunction,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK12SkColorSpace8toXYZD50EP15skcms_Matrix3x3"]
    pub fn SkColorSpace_toXYZD50(this: *const SkColorSpace, toXYZD50: *mut skcms_Matrix3x3)
        -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK12SkColorSpace15makeLinearGammaEv"]
    pub fn SkColorSpace_makeLinearGamma(this: *const SkColorSpace) -> sk_sp<SkColorSpace>;
}
extern "C" {
    #[link_name = "\u{1}__ZNK12SkColorSpace13makeSRGBGammaEv"]
    pub fn SkColorSpace_makeSRGBGamma(this: *const SkColorSpace) -> sk_sp<SkColorSpace>;
}
extern "C" {
    #[link_name = "\u{1}__ZNK12SkColorSpace13makeColorSpinEv"]
    pub fn SkColorSpace_makeColorSpin(this: *const SkColorSpace) -> sk_sp<SkColorSpace>;
}
extern "C" {
    #[link_name = "\u{1}__ZNK12SkColorSpace6isSRGBEv"]
    pub fn SkColorSpace_isSRGB(this: *const SkColorSpace) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK12SkColorSpace9serializeEv"]
    pub fn SkColorSpace_serialize(this: *const SkColorSpace) -> sk_sp<SkData>;
}
extern "C" {
    #[link_name = "\u{1}__ZNK12SkColorSpace13writeToMemoryEPv"]
    pub fn SkColorSpace_writeToMemory(
        this: *const SkColorSpace,
        memory: *mut ::core::ffi::c_void,
    ) -> usize;
}
extern "C" {
    #[link_name = "\u{1}__ZN12SkColorSpace11DeserializeEPKvm"]
    pub fn SkColorSpace_Deserialize(
        data: *const ::core::ffi::c_void,
        length: usize,
    ) -> sk_sp<SkColorSpace>;
}
extern "C" {
    #[link_name = "\u{1}__ZN12SkColorSpace6EqualsEPKS_S1_"]
    pub fn SkColorSpace_Equals(arg1: *const SkColorSpace, arg2: *const SkColorSpace) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK12SkColorSpace10transferFnEPf"]
    pub fn SkColorSpace_transferFn(this: *const SkColorSpace, gabcdef: *mut f32);
}
extern "C" {
    #[link_name = "\u{1}__ZNK12SkColorSpace10transferFnEP22skcms_TransferFunction"]
    pub fn SkColorSpace_transferFn1(this: *const SkColorSpace, fn_: *mut skcms_TransferFunction);
}
extern "C" {
    #[link_name = "\u{1}__ZNK12SkColorSpace13invTransferFnEP22skcms_TransferFunction"]
    pub fn SkColorSpace_invTransferFn(this: *const SkColorSpace, fn_: *mut skcms_TransferFunction);
}
extern "C" {
    #[link_name = "\u{1}__ZNK12SkColorSpace16gamutTransformToEPKS_P15skcms_Matrix3x3"]
    pub fn SkColorSpace_gamutTransformTo(
        this: *const SkColorSpace,
        dst: *const SkColorSpace,
        src_to_dst: *mut skcms_Matrix3x3,
    );
}
impl SkColorSpace {
    #[inline]
    pub unsafe fn MakeSRGB() -> sk_sp<SkColorSpace> {
        SkColorSpace_MakeSRGB()
    }
    #[inline]
    pub unsafe fn MakeSRGBLinear() -> sk_sp<SkColorSpace> {
        SkColorSpace_MakeSRGBLinear()
    }
    #[inline]
    pub unsafe fn MakeRGB(
        transferFn: *const skcms_TransferFunction,
        toXYZ: *const skcms_Matrix3x3,
    ) -> sk_sp<SkColorSpace> {
        SkColorSpace_MakeRGB(transferFn, toXYZ)
    }
    #[inline]
    pub unsafe fn Make(arg1: *const skcms_ICCProfile) -> sk_sp<SkColorSpace> {
        SkColorSpace_Make(arg1)
    }
    #[inline]
    pub unsafe fn toProfile(&self, arg1: *mut skcms_ICCProfile) {
        SkColorSpace_toProfile(self, arg1)
    }
    #[inline]
    pub unsafe fn gammaCloseToSRGB(&self) -> bool {
        SkColorSpace_gammaCloseToSRGB(self)
    }
    #[inline]
    pub unsafe fn gammaIsLinear(&self) -> bool {
        SkColorSpace_gammaIsLinear(self)
    }
    #[inline]
    pub unsafe fn isNumericalTransferFn(&self, fn_: *mut skcms_TransferFunction) -> bool {
        SkColorSpace_isNumericalTransferFn(self, fn_)
    }
    #[inline]
    pub unsafe fn toXYZD50(&self, toXYZD50: *mut skcms_Matrix3x3) -> bool {
        SkColorSpace_toXYZD50(self, toXYZD50)
    }
    #[inline]
    pub unsafe fn makeLinearGamma(&self) -> sk_sp<SkColorSpace> {
        SkColorSpace_makeLinearGamma(self)
    }
    #[inline]
    pub unsafe fn makeSRGBGamma(&self) -> sk_sp<SkColorSpace> {
        SkColorSpace_makeSRGBGamma(self)
    }
    #[inline]
    pub unsafe fn makeColorSpin(&self) -> sk_sp<SkColorSpace> {
        SkColorSpace_makeColorSpin(self)
    }
    #[inline]
    pub unsafe fn isSRGB(&self) -> bool {
        SkColorSpace_isSRGB(self)
    }
    #[inline]
    pub unsafe fn serialize(&self) -> sk_sp<SkData> {
        SkColorSpace_serialize(self)
    }
    #[inline]
    pub unsafe fn writeToMemory(&self, memory: *mut ::core::ffi::c_void) -> usize {
        SkColorSpace_writeToMemory(self, memory)
    }
    #[inline]
    pub unsafe fn Deserialize(
        data: *const ::core::ffi::c_void,
        length: usize,
    ) -> sk_sp<SkColorSpace> {
        SkColorSpace_Deserialize(data, length)
    }
    #[inline]
    pub unsafe fn Equals(arg1: *const SkColorSpace, arg2: *const SkColorSpace) -> bool {
        SkColorSpace_Equals(arg1, arg2)
    }
    #[inline]
    pub unsafe fn transferFn(&self, gabcdef: *mut f32) {
        SkColorSpace_transferFn(self, gabcdef)
    }
    #[inline]
    pub unsafe fn transferFn1(&self, fn_: *mut skcms_TransferFunction) {
        SkColorSpace_transferFn1(self, fn_)
    }
    #[inline]
    pub unsafe fn invTransferFn(&self, fn_: *mut skcms_TransferFunction) {
        SkColorSpace_invTransferFn(self, fn_)
    }
    #[inline]
    pub unsafe fn gamutTransformTo(
        &self,
        dst: *const SkColorSpace,
        src_to_dst: *mut skcms_Matrix3x3,
    ) {
        SkColorSpace_gamutTransformTo(self, dst, src_to_dst)
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct SkEncodedInfo {
    pub fWidth: ::std::os::raw::c_int,
    pub fHeight: ::std::os::raw::c_int,
    pub fColor: SkEncodedInfo_Color,
    pub fAlpha: SkEncodedInfo_Alpha,
    pub fBitsPerComponent: u8,
    pub fColorDepth: u8,
    pub fProfile: u64,
}
#[repr(C)]
pub struct SkEncodedInfo_ICCProfile {
    pub fProfile: skcms_ICCProfile,
    pub fData: sk_sp<SkData>,
}
#[test]
fn bindgen_test_layout_SkEncodedInfo_ICCProfile() {
    assert_eq!(
        ::core::mem::size_of::<SkEncodedInfo_ICCProfile>(),
        1016usize,
        concat!("Size of: ", stringify!(SkEncodedInfo_ICCProfile))
    );
    assert_eq!(
        ::core::mem::align_of::<SkEncodedInfo_ICCProfile>(),
        8usize,
        concat!("Alignment of ", stringify!(SkEncodedInfo_ICCProfile))
    );
    fn test_field_fProfile() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkEncodedInfo_ICCProfile>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fProfile) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SkEncodedInfo_ICCProfile),
                "::",
                stringify!(fProfile)
            )
        );
    }
    test_field_fProfile();
    fn test_field_fData() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkEncodedInfo_ICCProfile>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fData) as usize - ptr as usize
            },
            1008usize,
            concat!(
                "Offset of field: ",
                stringify!(SkEncodedInfo_ICCProfile),
                "::",
                stringify!(fData)
            )
        );
    }
    test_field_fData();
}
extern "C" {
    #[link_name = "\u{1}__ZN13SkEncodedInfo10ICCProfile4MakeE5sk_spI6SkDataE"]
    pub fn SkEncodedInfo_ICCProfile_Make(arg1: sk_sp<SkData>) -> u64;
}
extern "C" {
    #[link_name = "\u{1}__ZN13SkEncodedInfo10ICCProfile4MakeERK16skcms_ICCProfile"]
    pub fn SkEncodedInfo_ICCProfile_Make1(arg1: *const skcms_ICCProfile) -> u64;
}
impl SkEncodedInfo_ICCProfile {
    #[inline]
    pub unsafe fn Make(arg1: sk_sp<SkData>) -> u64 {
        SkEncodedInfo_ICCProfile_Make(arg1)
    }
    #[inline]
    pub unsafe fn Make1(arg1: *const skcms_ICCProfile) -> u64 {
        SkEncodedInfo_ICCProfile_Make1(arg1)
    }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkEncodedInfo_Alpha {
    kOpaque_Alpha = 0,
    kUnpremul_Alpha = 1,
    kBinary_Alpha = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkEncodedInfo_Color {
    kGray_Color = 0,
    kGrayAlpha_Color = 1,
    kXAlpha_Color = 2,
    k565_Color = 3,
    kPalette_Color = 4,
    kRGB_Color = 5,
    kRGBA_Color = 6,
    kBGR_Color = 7,
    kBGRX_Color = 8,
    kBGRA_Color = 9,
    kYUV_Color = 10,
    kYUVA_Color = 11,
    kInvertedCMYK_Color = 12,
    kYCCK_Color = 13,
}
#[test]
fn bindgen_test_layout_SkEncodedInfo() {
    assert_eq!(
        ::core::mem::size_of::<SkEncodedInfo>(),
        32usize,
        concat!("Size of: ", stringify!(SkEncodedInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<SkEncodedInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(SkEncodedInfo))
    );
    fn test_field_fWidth() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkEncodedInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fWidth) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SkEncodedInfo),
                "::",
                stringify!(fWidth)
            )
        );
    }
    test_field_fWidth();
    fn test_field_fHeight() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkEncodedInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fHeight) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(SkEncodedInfo),
                "::",
                stringify!(fHeight)
            )
        );
    }
    test_field_fHeight();
    fn test_field_fColor() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkEncodedInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fColor) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(SkEncodedInfo),
                "::",
                stringify!(fColor)
            )
        );
    }
    test_field_fColor();
    fn test_field_fAlpha() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkEncodedInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fAlpha) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(SkEncodedInfo),
                "::",
                stringify!(fAlpha)
            )
        );
    }
    test_field_fAlpha();
    fn test_field_fBitsPerComponent() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkEncodedInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fBitsPerComponent) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(SkEncodedInfo),
                "::",
                stringify!(fBitsPerComponent)
            )
        );
    }
    test_field_fBitsPerComponent();
    fn test_field_fColorDepth() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkEncodedInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fColorDepth) as usize - ptr as usize
            },
            17usize,
            concat!(
                "Offset of field: ",
                stringify!(SkEncodedInfo),
                "::",
                stringify!(fColorDepth)
            )
        );
    }
    test_field_fColorDepth();
    fn test_field_fProfile() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkEncodedInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fProfile) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(SkEncodedInfo),
                "::",
                stringify!(fProfile)
            )
        );
    }
    test_field_fProfile();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkNoncopyable {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_SkNoncopyable() {
    assert_eq!(
        ::core::mem::size_of::<SkNoncopyable>(),
        1usize,
        concat!("Size of: ", stringify!(SkNoncopyable))
    );
    assert_eq!(
        ::core::mem::align_of::<SkNoncopyable>(),
        1usize,
        concat!("Alignment of ", stringify!(SkNoncopyable))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkPngChunkReader {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct SkCodec__bindgen_vtable(::core::ffi::c_void);
#[repr(C)]
pub struct SkCodec {
    pub vtable_: *const SkCodec__bindgen_vtable,
    pub fEncodedInfo: SkEncodedInfo,
    pub fSrcXformFormat: SkCodec_XformFormat,
    pub fStream: u64,
    pub fNeedsRewind: bool,
    pub fOrigin: SkEncodedOrigin,
    pub fDstInfo: SkImageInfo,
    pub fOptions: SkCodec_Options,
    pub fXformTime: SkCodec_XformTime,
    pub fDstXformFormat: SkCodec_XformFormat,
    pub fDstProfile: skcms_ICCProfile,
    pub fDstXformAlphaFormat: skcms_AlphaFormat,
    pub fCurrScanline: ::std::os::raw::c_int,
    pub fStartedIncrementalDecode: bool,
    pub fAndroidCodecHandlesFrameIndex: bool,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkCodec_Result {
    Success = 0,
    IncompleteInput = 1,
    ErrorInInput = 2,
    InvalidConversion = 3,
    InvalidScale = 4,
    InvalidParameters = 5,
    InvalidInput = 6,
    CouldNotRewind = 7,
    InternalError = 8,
    Unimplemented = 9,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkCodec_SelectionPolicy {
    PreferStillImage = 0,
    PreferAnimation = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkCodec_ZeroInitialized {
    Yes = 0,
    No = 1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkCodec_Options {
    pub fZeroInitialized: SkCodec_ZeroInitialized,
    pub fSubset: *const SkIRect,
    pub fFrameIndex: ::std::os::raw::c_int,
    pub fPriorFrame: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_SkCodec_Options() {
    assert_eq!(
        ::core::mem::size_of::<SkCodec_Options>(),
        24usize,
        concat!("Size of: ", stringify!(SkCodec_Options))
    );
    assert_eq!(
        ::core::mem::align_of::<SkCodec_Options>(),
        8usize,
        concat!("Alignment of ", stringify!(SkCodec_Options))
    );
    fn test_field_fZeroInitialized() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkCodec_Options>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fZeroInitialized) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SkCodec_Options),
                "::",
                stringify!(fZeroInitialized)
            )
        );
    }
    test_field_fZeroInitialized();
    fn test_field_fSubset() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkCodec_Options>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fSubset) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(SkCodec_Options),
                "::",
                stringify!(fSubset)
            )
        );
    }
    test_field_fSubset();
    fn test_field_fFrameIndex() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkCodec_Options>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fFrameIndex) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(SkCodec_Options),
                "::",
                stringify!(fFrameIndex)
            )
        );
    }
    test_field_fFrameIndex();
    fn test_field_fPriorFrame() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkCodec_Options>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fPriorFrame) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(SkCodec_Options),
                "::",
                stringify!(fPriorFrame)
            )
        );
    }
    test_field_fPriorFrame();
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkCodec_SkScanlineOrder {
    TopDown = 0,
    BottomUp = 1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkCodec_FrameInfo {
    pub fRequiredFrame: ::std::os::raw::c_int,
    pub fDuration: ::std::os::raw::c_int,
    pub fFullyReceived: bool,
    pub fAlphaType: SkAlphaType,
    pub fHasAlphaWithinBounds: bool,
    pub fDisposalMethod: SkCodecAnimation_DisposalMethod,
    pub fBlend: SkCodecAnimation_Blend,
    pub fFrameRect: SkIRect,
}
#[test]
fn bindgen_test_layout_SkCodec_FrameInfo() {
    assert_eq!(
        ::core::mem::size_of::<SkCodec_FrameInfo>(),
        44usize,
        concat!("Size of: ", stringify!(SkCodec_FrameInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<SkCodec_FrameInfo>(),
        4usize,
        concat!("Alignment of ", stringify!(SkCodec_FrameInfo))
    );
    fn test_field_fRequiredFrame() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkCodec_FrameInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fRequiredFrame) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SkCodec_FrameInfo),
                "::",
                stringify!(fRequiredFrame)
            )
        );
    }
    test_field_fRequiredFrame();
    fn test_field_fDuration() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkCodec_FrameInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fDuration) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(SkCodec_FrameInfo),
                "::",
                stringify!(fDuration)
            )
        );
    }
    test_field_fDuration();
    fn test_field_fFullyReceived() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkCodec_FrameInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fFullyReceived) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(SkCodec_FrameInfo),
                "::",
                stringify!(fFullyReceived)
            )
        );
    }
    test_field_fFullyReceived();
    fn test_field_fAlphaType() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkCodec_FrameInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fAlphaType) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(SkCodec_FrameInfo),
                "::",
                stringify!(fAlphaType)
            )
        );
    }
    test_field_fAlphaType();
    fn test_field_fHasAlphaWithinBounds() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkCodec_FrameInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fHasAlphaWithinBounds) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(SkCodec_FrameInfo),
                "::",
                stringify!(fHasAlphaWithinBounds)
            )
        );
    }
    test_field_fHasAlphaWithinBounds();
    fn test_field_fDisposalMethod() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkCodec_FrameInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fDisposalMethod) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(SkCodec_FrameInfo),
                "::",
                stringify!(fDisposalMethod)
            )
        );
    }
    test_field_fDisposalMethod();
    fn test_field_fBlend() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkCodec_FrameInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fBlend) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(SkCodec_FrameInfo),
                "::",
                stringify!(fBlend)
            )
        );
    }
    test_field_fBlend();
    fn test_field_fFrameRect() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkCodec_FrameInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fFrameRect) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(SkCodec_FrameInfo),
                "::",
                stringify!(fFrameRect)
            )
        );
    }
    test_field_fFrameRect();
}
pub use self::skcms_PixelFormat as SkCodec_XformFormat;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkCodec_XformTime {
    kNo_XformTime = 0,
    kPalette_XformTime = 1,
    kDecodeRow_XformTime = 2,
}
pub const SkCodec_kNoFrame: ::std::os::raw::c_int = -1;
pub const SkCodec_kRepetitionCountInfinite: ::std::os::raw::c_int = -1;
#[test]
fn bindgen_test_layout_SkCodec() {
    assert_eq!(
        ::core::mem::size_of::<SkCodec>(),
        1144usize,
        concat!("Size of: ", stringify!(SkCodec))
    );
    assert_eq!(
        ::core::mem::align_of::<SkCodec>(),
        8usize,
        concat!("Alignment of ", stringify!(SkCodec))
    );
    fn test_field_fEncodedInfo() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkCodec>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fEncodedInfo) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(SkCodec),
                "::",
                stringify!(fEncodedInfo)
            )
        );
    }
    test_field_fEncodedInfo();
    fn test_field_fSrcXformFormat() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkCodec>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fSrcXformFormat) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(SkCodec),
                "::",
                stringify!(fSrcXformFormat)
            )
        );
    }
    test_field_fSrcXformFormat();
    fn test_field_fStream() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkCodec>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fStream) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(SkCodec),
                "::",
                stringify!(fStream)
            )
        );
    }
    test_field_fStream();
    fn test_field_fNeedsRewind() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkCodec>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fNeedsRewind) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(SkCodec),
                "::",
                stringify!(fNeedsRewind)
            )
        );
    }
    test_field_fNeedsRewind();
    fn test_field_fOrigin() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkCodec>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fOrigin) as usize - ptr as usize
            },
            60usize,
            concat!(
                "Offset of field: ",
                stringify!(SkCodec),
                "::",
                stringify!(fOrigin)
            )
        );
    }
    test_field_fOrigin();
    fn test_field_fDstInfo() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkCodec>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fDstInfo) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(SkCodec),
                "::",
                stringify!(fDstInfo)
            )
        );
    }
    test_field_fDstInfo();
    fn test_field_fOptions() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkCodec>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fOptions) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(SkCodec),
                "::",
                stringify!(fOptions)
            )
        );
    }
    test_field_fOptions();
    fn test_field_fXformTime() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkCodec>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fXformTime) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(SkCodec),
                "::",
                stringify!(fXformTime)
            )
        );
    }
    test_field_fXformTime();
    fn test_field_fDstXformFormat() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkCodec>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fDstXformFormat) as usize - ptr as usize
            },
            116usize,
            concat!(
                "Offset of field: ",
                stringify!(SkCodec),
                "::",
                stringify!(fDstXformFormat)
            )
        );
    }
    test_field_fDstXformFormat();
    fn test_field_fDstProfile() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkCodec>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fDstProfile) as usize - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(SkCodec),
                "::",
                stringify!(fDstProfile)
            )
        );
    }
    test_field_fDstProfile();
    fn test_field_fDstXformAlphaFormat() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkCodec>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fDstXformAlphaFormat) as usize - ptr as usize
            },
            1128usize,
            concat!(
                "Offset of field: ",
                stringify!(SkCodec),
                "::",
                stringify!(fDstXformAlphaFormat)
            )
        );
    }
    test_field_fDstXformAlphaFormat();
    fn test_field_fCurrScanline() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkCodec>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fCurrScanline) as usize - ptr as usize
            },
            1132usize,
            concat!(
                "Offset of field: ",
                stringify!(SkCodec),
                "::",
                stringify!(fCurrScanline)
            )
        );
    }
    test_field_fCurrScanline();
    fn test_field_fStartedIncrementalDecode() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkCodec>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fStartedIncrementalDecode) as usize - ptr as usize
            },
            1136usize,
            concat!(
                "Offset of field: ",
                stringify!(SkCodec),
                "::",
                stringify!(fStartedIncrementalDecode)
            )
        );
    }
    test_field_fStartedIncrementalDecode();
    fn test_field_fAndroidCodecHandlesFrameIndex() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkCodec>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fAndroidCodecHandlesFrameIndex) as usize - ptr as usize
            },
            1137usize,
            concat!(
                "Offset of field: ",
                stringify!(SkCodec),
                "::",
                stringify!(fAndroidCodecHandlesFrameIndex)
            )
        );
    }
    test_field_fAndroidCodecHandlesFrameIndex();
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkCodec14ResultToStringENS_6ResultE"]
    pub fn SkCodec_ResultToString(arg1: SkCodec_Result) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkCodec14MakeFromStreamENSt3__110unique_ptrI8SkStreamNS0_14default_deleteIS2_EEEEPNS_6ResultEP16SkPngChunkReaderNS_15SelectionPolicyE"]
    pub fn SkCodec_MakeFromStream(
        arg1: u64,
        arg2: *mut SkCodec_Result,
        arg3: *mut SkPngChunkReader,
        selectionPolicy: SkCodec_SelectionPolicy,
    ) -> u64;
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkCodec12MakeFromDataE5sk_spI6SkDataEP16SkPngChunkReader"]
    pub fn SkCodec_MakeFromData(arg1: sk_sp<SkData>, arg2: *mut SkPngChunkReader) -> u64;
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkCodec9getPixelsERK11SkImageInfoPvmPKNS_7OptionsE"]
    pub fn SkCodec_getPixels(
        this: *mut SkCodec,
        info: *const SkImageInfo,
        pixels: *mut ::core::ffi::c_void,
        rowBytes: usize,
        arg1: *const SkCodec_Options,
    ) -> SkCodec_Result;
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkCodec8getImageERK11SkImageInfoPKNS_7OptionsE"]
    pub fn SkCodec_getImage(
        this: *mut SkCodec,
        info: *const SkImageInfo,
        opts: *const SkCodec_Options,
    ) -> [u64; 2usize];
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkCodec8getImageEv"]
    pub fn SkCodec_getImage1(this: *mut SkCodec) -> [u64; 2usize];
}
extern "C" {
    #[link_name = "\u{1}__ZNK7SkCodec13queryYUVAInfoERKN16SkYUVAPixmapInfo18SupportedDataTypesEPS0_"]
    pub fn SkCodec_queryYUVAInfo(
        this: *const SkCodec,
        supportedDataTypes: *const SkYUVAPixmapInfo_SupportedDataTypes,
        yuvaPixmapInfo: *mut SkYUVAPixmapInfo,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkCodec13getYUVAPlanesERK13SkYUVAPixmaps"]
    pub fn SkCodec_getYUVAPlanes(
        this: *mut SkCodec,
        yuvaPixmaps: *const SkYUVAPixmaps,
    ) -> SkCodec_Result;
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkCodec22startIncrementalDecodeERK11SkImageInfoPvmPKNS_7OptionsE"]
    pub fn SkCodec_startIncrementalDecode(
        this: *mut SkCodec,
        dstInfo: *const SkImageInfo,
        dst: *mut ::core::ffi::c_void,
        rowBytes: usize,
        arg1: *const SkCodec_Options,
    ) -> SkCodec_Result;
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkCodec19startScanlineDecodeERK11SkImageInfoPKNS_7OptionsE"]
    pub fn SkCodec_startScanlineDecode(
        this: *mut SkCodec,
        dstInfo: *const SkImageInfo,
        options: *const SkCodec_Options,
    ) -> SkCodec_Result;
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkCodec12getScanlinesEPvim"]
    pub fn SkCodec_getScanlines(
        this: *mut SkCodec,
        dst: *mut ::core::ffi::c_void,
        countLines: ::std::os::raw::c_int,
        rowBytes: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkCodec13skipScanlinesEi"]
    pub fn SkCodec_skipScanlines(this: *mut SkCodec, countLines: ::std::os::raw::c_int) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK7SkCodec14outputScanlineEi"]
    pub fn SkCodec_outputScanline(
        this: *const SkCodec,
        inputScanline: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkCodec12getFrameInfoEv"]
    pub fn SkCodec_getFrameInfo(this: *mut SkCodec) -> u8;
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkCodec8RegisterEPFbPKvmEPFNSt3__110unique_ptrIS_NS4_14default_deleteIS_EEEENS5_I8SkStreamNS6_IS9_EEEEPNS_6ResultEE"]
    pub fn SkCodec_Register(
        peek: ::core::option::Option<
            unsafe extern "C" fn(arg1: *const ::core::ffi::c_void, arg2: usize) -> bool,
        >,
        make: ::core::option::Option<
            unsafe extern "C" fn(arg1: u64, arg2: *mut SkCodec_Result) -> u64,
        >,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkCodec17setSrcXformFormatE17skcms_PixelFormat"]
    pub fn SkCodec_setSrcXformFormat(this: *mut SkCodec, pixelFormat: SkCodec_XformFormat);
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkCodec14rewindIfNeededEv"]
    pub fn SkCodec_rewindIfNeeded(this: *mut SkCodec) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK7SkCodec15applyColorXformEPvPKvi"]
    pub fn SkCodec_applyColorXform(
        this: *const SkCodec,
        dst: *mut ::core::ffi::c_void,
        src: *const ::core::ffi::c_void,
        count: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkCodecC2EO13SkEncodedInfo17skcms_PixelFormatNSt3__110unique_ptrI8SkStreamNS3_14default_deleteIS5_EEEE15SkEncodedOrigin"]
    pub fn SkCodec_SkCodec(
        this: *mut SkCodec,
        arg1: *mut SkEncodedInfo,
        srcFormat: SkCodec_XformFormat,
        arg2: u64,
        arg3: SkEncodedOrigin,
    );
}
impl SkCodec {
    #[inline]
    pub unsafe fn ResultToString(arg1: SkCodec_Result) -> *const ::std::os::raw::c_char {
        SkCodec_ResultToString(arg1)
    }
    #[inline]
    pub unsafe fn MakeFromStream(
        arg1: u64,
        arg2: *mut SkCodec_Result,
        arg3: *mut SkPngChunkReader,
        selectionPolicy: SkCodec_SelectionPolicy,
    ) -> u64 {
        SkCodec_MakeFromStream(arg1, arg2, arg3, selectionPolicy)
    }
    #[inline]
    pub unsafe fn MakeFromData(arg1: sk_sp<SkData>, arg2: *mut SkPngChunkReader) -> u64 {
        SkCodec_MakeFromData(arg1, arg2)
    }
    #[inline]
    pub unsafe fn getPixels(
        &mut self,
        info: *const SkImageInfo,
        pixels: *mut ::core::ffi::c_void,
        rowBytes: usize,
        arg1: *const SkCodec_Options,
    ) -> SkCodec_Result {
        SkCodec_getPixels(self, info, pixels, rowBytes, arg1)
    }
    #[inline]
    pub unsafe fn getImage(
        &mut self,
        info: *const SkImageInfo,
        opts: *const SkCodec_Options,
    ) -> [u64; 2usize] {
        SkCodec_getImage(self, info, opts)
    }
    #[inline]
    pub unsafe fn getImage1(&mut self) -> [u64; 2usize] {
        SkCodec_getImage1(self)
    }
    #[inline]
    pub unsafe fn queryYUVAInfo(
        &self,
        supportedDataTypes: *const SkYUVAPixmapInfo_SupportedDataTypes,
        yuvaPixmapInfo: *mut SkYUVAPixmapInfo,
    ) -> bool {
        SkCodec_queryYUVAInfo(self, supportedDataTypes, yuvaPixmapInfo)
    }
    #[inline]
    pub unsafe fn getYUVAPlanes(&mut self, yuvaPixmaps: *const SkYUVAPixmaps) -> SkCodec_Result {
        SkCodec_getYUVAPlanes(self, yuvaPixmaps)
    }
    #[inline]
    pub unsafe fn startIncrementalDecode(
        &mut self,
        dstInfo: *const SkImageInfo,
        dst: *mut ::core::ffi::c_void,
        rowBytes: usize,
        arg1: *const SkCodec_Options,
    ) -> SkCodec_Result {
        SkCodec_startIncrementalDecode(self, dstInfo, dst, rowBytes, arg1)
    }
    #[inline]
    pub unsafe fn startScanlineDecode(
        &mut self,
        dstInfo: *const SkImageInfo,
        options: *const SkCodec_Options,
    ) -> SkCodec_Result {
        SkCodec_startScanlineDecode(self, dstInfo, options)
    }
    #[inline]
    pub unsafe fn getScanlines(
        &mut self,
        dst: *mut ::core::ffi::c_void,
        countLines: ::std::os::raw::c_int,
        rowBytes: usize,
    ) -> ::std::os::raw::c_int {
        SkCodec_getScanlines(self, dst, countLines, rowBytes)
    }
    #[inline]
    pub unsafe fn skipScanlines(&mut self, countLines: ::std::os::raw::c_int) -> bool {
        SkCodec_skipScanlines(self, countLines)
    }
    #[inline]
    pub unsafe fn outputScanline(
        &self,
        inputScanline: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        SkCodec_outputScanline(self, inputScanline)
    }
    #[inline]
    pub unsafe fn getFrameInfo(&mut self) -> u8 {
        SkCodec_getFrameInfo(self)
    }
    #[inline]
    pub unsafe fn Register(
        peek: ::core::option::Option<
            unsafe extern "C" fn(arg1: *const ::core::ffi::c_void, arg2: usize) -> bool,
        >,
        make: ::core::option::Option<
            unsafe extern "C" fn(arg1: u64, arg2: *mut SkCodec_Result) -> u64,
        >,
    ) {
        SkCodec_Register(peek, make)
    }
    #[inline]
    pub unsafe fn setSrcXformFormat(&mut self, pixelFormat: SkCodec_XformFormat) {
        SkCodec_setSrcXformFormat(self, pixelFormat)
    }
    #[inline]
    pub unsafe fn rewindIfNeeded(&mut self) -> bool {
        SkCodec_rewindIfNeeded(self)
    }
    #[inline]
    pub unsafe fn applyColorXform(
        &self,
        dst: *mut ::core::ffi::c_void,
        src: *const ::core::ffi::c_void,
        count: ::std::os::raw::c_int,
    ) {
        SkCodec_applyColorXform(self, dst, src, count)
    }
    #[inline]
    pub unsafe fn new(
        arg1: *mut SkEncodedInfo,
        srcFormat: SkCodec_XformFormat,
        arg2: u64,
        arg3: SkEncodedOrigin,
    ) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkCodec_SkCodec(__bindgen_tmp.as_mut_ptr(), arg1, srcFormat, arg2, arg3);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkCodecD1Ev"]
    pub fn SkCodec_SkCodec_destructor(this: *mut SkCodec);
}
extern "C" {
    #[link_name = "\u{1}__ZNK7SkCodec16onOutputScanlineEi"]
    pub fn SkCodec_onOutputScanline(
        this: *mut ::core::ffi::c_void,
        inputScanline: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkCodec19conversionSupportedERK11SkImageInfobb"]
    pub fn SkCodec_conversionSupported(
        this: *mut ::core::ffi::c_void,
        dst: *const SkImageInfo,
        srcIsOpaque: bool,
        needsColorXform: bool,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__Z21SkAnnotateRectWithURLP8SkCanvasRK6SkRectP6SkData"]
    pub fn SkAnnotateRectWithURL(arg1: *mut SkCanvas, arg2: *const SkRect, arg3: *mut SkData);
}
extern "C" {
    #[link_name = "\u{1}__Z26SkAnnotateNamedDestinationP8SkCanvasRK7SkPointP6SkData"]
    pub fn SkAnnotateNamedDestination(arg1: *mut SkCanvas, arg2: *const SkPoint, arg3: *mut SkData);
}
extern "C" {
    #[link_name = "\u{1}__Z27SkAnnotateLinkToDestinationP8SkCanvasRK6SkRectP6SkData"]
    pub fn SkAnnotateLinkToDestination(arg1: *mut SkCanvas, arg2: *const SkRect, arg3: *mut SkData);
}
impl SkBlendMode {
    pub const LastCoeffMode: SkBlendMode = SkBlendMode::Screen;
}
impl SkBlendMode {
    pub const LastSeparableMode: SkBlendMode = SkBlendMode::Multiply;
}
impl SkBlendMode {
    pub const LastMode: SkBlendMode = SkBlendMode::Luminosity;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkBlendMode {
    Clear = 0,
    Src = 1,
    Dst = 2,
    SrcOver = 3,
    DstOver = 4,
    SrcIn = 5,
    DstIn = 6,
    SrcOut = 7,
    DstOut = 8,
    SrcATop = 9,
    DstATop = 10,
    Xor = 11,
    Plus = 12,
    Modulate = 13,
    Screen = 14,
    Overlay = 15,
    Darken = 16,
    Lighten = 17,
    ColorDodge = 18,
    ColorBurn = 19,
    HardLight = 20,
    SoftLight = 21,
    Difference = 22,
    Exclusion = 23,
    Multiply = 24,
    Hue = 25,
    Saturation = 26,
    Color = 27,
    Luminosity = 28,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkBlendModeCoeff {
    Zero = 0,
    One = 1,
    SC = 2,
    ISC = 3,
    DC = 4,
    IDC = 5,
    SA = 6,
    ISA = 7,
    DA = 8,
    IDA = 9,
    CoeffCount = 10,
}
extern "C" {
    #[link_name = "\u{1}__Z19SkBlendMode_AsCoeff11SkBlendModeP16SkBlendModeCoeffS1_"]
    pub fn SkBlendMode_AsCoeff(
        mode: SkBlendMode,
        src: *mut SkBlendModeCoeff,
        dst: *mut SkBlendModeCoeff,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__Z16SkBlendMode_Name11SkBlendMode"]
    pub fn SkBlendMode_Name(blendMode: SkBlendMode) -> *const ::std::os::raw::c_char;
}
impl SkClipOp {
    pub const Max_EnumValue: SkClipOp = SkClipOp::Intersect;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkClipOp {
    Difference = 0,
    Intersect = 1,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkTextEncoding {
    kUTF8 = 0,
    kUTF16 = 1,
    kUTF32 = 2,
    kGlyphID = 3,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkFontHinting {
    None = 0,
    Slight = 1,
    Normal = 2,
    Full = 3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkV2 {
    pub x: f32,
    pub y: f32,
}
#[test]
fn bindgen_test_layout_SkV2() {
    assert_eq!(
        ::core::mem::size_of::<SkV2>(),
        8usize,
        concat!("Size of: ", stringify!(SkV2))
    );
    assert_eq!(
        ::core::mem::align_of::<SkV2>(),
        4usize,
        concat!("Alignment of ", stringify!(SkV2))
    );
    fn test_field_x() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkV2>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).x) as usize - ptr as usize
            },
            0usize,
            concat!("Offset of field: ", stringify!(SkV2), "::", stringify!(x))
        );
    }
    test_field_x();
    fn test_field_y() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkV2>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize
            },
            4usize,
            concat!("Offset of field: ", stringify!(SkV2), "::", stringify!(y))
        );
    }
    test_field_y();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkV3 {
    pub x: f32,
    pub y: f32,
    pub z: f32,
}
#[test]
fn bindgen_test_layout_SkV3() {
    assert_eq!(
        ::core::mem::size_of::<SkV3>(),
        12usize,
        concat!("Size of: ", stringify!(SkV3))
    );
    assert_eq!(
        ::core::mem::align_of::<SkV3>(),
        4usize,
        concat!("Alignment of ", stringify!(SkV3))
    );
    fn test_field_x() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkV3>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).x) as usize - ptr as usize
            },
            0usize,
            concat!("Offset of field: ", stringify!(SkV3), "::", stringify!(x))
        );
    }
    test_field_x();
    fn test_field_y() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkV3>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize
            },
            4usize,
            concat!("Offset of field: ", stringify!(SkV3), "::", stringify!(y))
        );
    }
    test_field_y();
    fn test_field_z() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkV3>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).z) as usize - ptr as usize
            },
            8usize,
            concat!("Offset of field: ", stringify!(SkV3), "::", stringify!(z))
        );
    }
    test_field_z();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkV4 {
    pub x: f32,
    pub y: f32,
    pub z: f32,
    pub w: f32,
}
#[test]
fn bindgen_test_layout_SkV4() {
    assert_eq!(
        ::core::mem::size_of::<SkV4>(),
        16usize,
        concat!("Size of: ", stringify!(SkV4))
    );
    assert_eq!(
        ::core::mem::align_of::<SkV4>(),
        4usize,
        concat!("Alignment of ", stringify!(SkV4))
    );
    fn test_field_x() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkV4>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).x) as usize - ptr as usize
            },
            0usize,
            concat!("Offset of field: ", stringify!(SkV4), "::", stringify!(x))
        );
    }
    test_field_x();
    fn test_field_y() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkV4>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize
            },
            4usize,
            concat!("Offset of field: ", stringify!(SkV4), "::", stringify!(y))
        );
    }
    test_field_y();
    fn test_field_z() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkV4>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).z) as usize - ptr as usize
            },
            8usize,
            concat!("Offset of field: ", stringify!(SkV4), "::", stringify!(z))
        );
    }
    test_field_z();
    fn test_field_w() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkV4>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).w) as usize - ptr as usize
            },
            12usize,
            concat!("Offset of field: ", stringify!(SkV4), "::", stringify!(w))
        );
    }
    test_field_w();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkM44 {
    pub fMat: [SkScalar; 16usize],
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkM44_Uninitialized_Constructor {
    kUninitialized_Constructor = 0,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkM44_NaN_Constructor {
    kNaN_Constructor = 0,
}
#[test]
fn bindgen_test_layout_SkM44() {
    assert_eq!(
        ::core::mem::size_of::<SkM44>(),
        64usize,
        concat!("Size of: ", stringify!(SkM44))
    );
    assert_eq!(
        ::core::mem::align_of::<SkM44>(),
        4usize,
        concat!("Alignment of ", stringify!(SkM44))
    );
    fn test_field_fMat() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkM44>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fMat) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SkM44),
                "::",
                stringify!(fMat)
            )
        );
    }
    test_field_fMat();
}
extern "C" {
    #[link_name = "\u{1}__ZN5SkM4410RectToRectERK6SkRectS2_"]
    pub fn SkM44_RectToRect(src: *const SkRect, dst: *const SkRect) -> SkM44;
}
extern "C" {
    #[link_name = "\u{1}__ZN5SkM446LookAtERK4SkV3S2_S2_"]
    pub fn SkM44_LookAt(eye: *const SkV3, center: *const SkV3, up: *const SkV3) -> SkM44;
}
extern "C" {
    #[link_name = "\u{1}__ZN5SkM4411PerspectiveEfff"]
    pub fn SkM44_Perspective(near: f32, far: f32, angle: f32) -> SkM44;
}
extern "C" {
    #[link_name = "\u{1}__ZNK5SkM4411getRowMajorEPf"]
    pub fn SkM44_getRowMajor(this: *const SkM44, v: *mut SkScalar);
}
extern "C" {
    #[link_name = "\u{1}__ZN5SkM4419setRotateUnitSinCosE4SkV3ff"]
    pub fn SkM44_setRotateUnitSinCos(
        this: *mut SkM44,
        axis: SkV3,
        sinAngle: SkScalar,
        cosAngle: SkScalar,
    ) -> *mut SkM44;
}
extern "C" {
    #[link_name = "\u{1}__ZN5SkM449setRotateE4SkV3f"]
    pub fn SkM44_setRotate(this: *mut SkM44, axis: SkV3, radians: SkScalar) -> *mut SkM44;
}
extern "C" {
    #[link_name = "\u{1}__ZN5SkM449setConcatERKS_S1_"]
    pub fn SkM44_setConcat(this: *mut SkM44, a: *const SkM44, b: *const SkM44) -> *mut SkM44;
}
extern "C" {
    #[link_name = "\u{1}__ZN5SkM4420normalizePerspectiveEv"]
    pub fn SkM44_normalizePerspective(this: *mut SkM44);
}
extern "C" {
    #[link_name = "\u{1}__ZNK5SkM446invertEPS_"]
    pub fn SkM44_invert(this: *const SkM44, inverse: *mut SkM44) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK5SkM449transposeEv"]
    pub fn SkM44_transpose(this: *const SkM44) -> SkM44;
}
extern "C" {
    #[link_name = "\u{1}__ZNK5SkM444dumpEv"]
    pub fn SkM44_dump(this: *const SkM44);
}
extern "C" {
    #[link_name = "\u{1}__ZNK5SkM443mapEffff"]
    pub fn SkM44_map(this: *const SkM44, x: f32, y: f32, z: f32, w: f32) -> SkV4;
}
extern "C" {
    #[link_name = "\u{1}__ZN5SkM4412preTranslateEfff"]
    pub fn SkM44_preTranslate(
        this: *mut SkM44,
        x: SkScalar,
        y: SkScalar,
        z: SkScalar,
    ) -> *mut SkM44;
}
extern "C" {
    #[link_name = "\u{1}__ZN5SkM4413postTranslateEfff"]
    pub fn SkM44_postTranslate(
        this: *mut SkM44,
        x: SkScalar,
        y: SkScalar,
        z: SkScalar,
    ) -> *mut SkM44;
}
extern "C" {
    #[link_name = "\u{1}__ZN5SkM448preScaleEff"]
    pub fn SkM44_preScale(this: *mut SkM44, x: SkScalar, y: SkScalar) -> *mut SkM44;
}
extern "C" {
    #[link_name = "\u{1}__ZN5SkM448preScaleEfff"]
    pub fn SkM44_preScale1(this: *mut SkM44, x: SkScalar, y: SkScalar, z: SkScalar) -> *mut SkM44;
}
extern "C" {
    #[link_name = "\u{1}__ZN5SkM449preConcatERK8SkMatrix"]
    pub fn SkM44_preConcat(this: *mut SkM44, arg1: *const SkMatrix) -> *mut SkM44;
}
impl SkM44 {
    #[inline]
    pub unsafe fn RectToRect(src: *const SkRect, dst: *const SkRect) -> SkM44 {
        SkM44_RectToRect(src, dst)
    }
    #[inline]
    pub unsafe fn LookAt(eye: *const SkV3, center: *const SkV3, up: *const SkV3) -> SkM44 {
        SkM44_LookAt(eye, center, up)
    }
    #[inline]
    pub unsafe fn Perspective(near: f32, far: f32, angle: f32) -> SkM44 {
        SkM44_Perspective(near, far, angle)
    }
    #[inline]
    pub unsafe fn getRowMajor(&self, v: *mut SkScalar) {
        SkM44_getRowMajor(self, v)
    }
    #[inline]
    pub unsafe fn setRotateUnitSinCos(
        &mut self,
        axis: SkV3,
        sinAngle: SkScalar,
        cosAngle: SkScalar,
    ) -> *mut SkM44 {
        SkM44_setRotateUnitSinCos(self, axis, sinAngle, cosAngle)
    }
    #[inline]
    pub unsafe fn setRotate(&mut self, axis: SkV3, radians: SkScalar) -> *mut SkM44 {
        SkM44_setRotate(self, axis, radians)
    }
    #[inline]
    pub unsafe fn setConcat(&mut self, a: *const SkM44, b: *const SkM44) -> *mut SkM44 {
        SkM44_setConcat(self, a, b)
    }
    #[inline]
    pub unsafe fn normalizePerspective(&mut self) {
        SkM44_normalizePerspective(self)
    }
    #[inline]
    pub unsafe fn invert(&self, inverse: *mut SkM44) -> bool {
        SkM44_invert(self, inverse)
    }
    #[inline]
    pub unsafe fn transpose(&self) -> SkM44 {
        SkM44_transpose(self)
    }
    #[inline]
    pub unsafe fn dump(&self) {
        SkM44_dump(self)
    }
    #[inline]
    pub unsafe fn map(&self, x: f32, y: f32, z: f32, w: f32) -> SkV4 {
        SkM44_map(self, x, y, z, w)
    }
    #[inline]
    pub unsafe fn preTranslate(&mut self, x: SkScalar, y: SkScalar, z: SkScalar) -> *mut SkM44 {
        SkM44_preTranslate(self, x, y, z)
    }
    #[inline]
    pub unsafe fn postTranslate(&mut self, x: SkScalar, y: SkScalar, z: SkScalar) -> *mut SkM44 {
        SkM44_postTranslate(self, x, y, z)
    }
    #[inline]
    pub unsafe fn preScale(&mut self, x: SkScalar, y: SkScalar) -> *mut SkM44 {
        SkM44_preScale(self, x, y)
    }
    #[inline]
    pub unsafe fn preScale1(&mut self, x: SkScalar, y: SkScalar, z: SkScalar) -> *mut SkM44 {
        SkM44_preScale1(self, x, y, z)
    }
    #[inline]
    pub unsafe fn preConcat(&mut self, arg1: *const SkMatrix) -> *mut SkM44 {
        SkM44_preConcat(self, arg1)
    }
}
#[repr(C)]
pub struct SkPaint {
    pub fPathEffect: sk_sp<SkPathEffect>,
    pub fShader: sk_sp<SkShader>,
    pub fMaskFilter: sk_sp<SkMaskFilter>,
    pub fColorFilter: sk_sp<SkColorFilter>,
    pub fImageFilter: sk_sp<SkImageFilter>,
    pub fBlender: sk_sp<SkBlender>,
    pub fColor4f: SkColor4f,
    pub fWidth: SkScalar,
    pub fMiterLimit: SkScalar,
    pub __bindgen_anon_1: SkPaint__bindgen_ty_1,
}
#[repr(u8)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkPaint_Style {
    Fill = 0,
    Stroke = 1,
    StrokeAndFill = 2,
}
impl SkPaint_Cap {
    pub const Last: SkPaint_Cap = SkPaint_Cap::Square;
}
impl SkPaint_Cap {
    pub const Default: SkPaint_Cap = SkPaint_Cap::Butt;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkPaint_Cap {
    Butt = 0,
    Round = 1,
    Square = 2,
}
impl SkPaint_Join {
    pub const Last: SkPaint_Join = SkPaint_Join::Bevel;
}
impl SkPaint_Join {
    pub const Default: SkPaint_Join = SkPaint_Join::Miter;
}
#[repr(u8)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkPaint_Join {
    Miter = 0,
    Round = 1,
    Bevel = 2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SkPaint__bindgen_ty_1 {
    pub fBitfields: SkPaint__bindgen_ty_1__bindgen_ty_1,
    pub fBitfieldsUInt: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct SkPaint__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_SkPaint__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SkPaint__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(SkPaint__bindgen_ty_1__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<SkPaint__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(SkPaint__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
impl SkPaint__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn fAntiAlias(&self) -> ::std::os::raw::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fAntiAlias(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fDither(&self) -> ::std::os::raw::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fDither(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fCapType(&self) -> ::std::os::raw::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_fCapType(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn fJoinType(&self) -> ::std::os::raw::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_fJoinType(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn fStyle(&self) -> ::std::os::raw::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_fStyle(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn fPadding(&self) -> ::std::os::raw::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_fPadding(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        fAntiAlias: ::std::os::raw::c_uint,
        fDither: ::std::os::raw::c_uint,
        fCapType: ::std::os::raw::c_uint,
        fJoinType: ::std::os::raw::c_uint,
        fStyle: ::std::os::raw::c_uint,
        fPadding: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let fAntiAlias: u32 = unsafe { ::core::mem::transmute(fAntiAlias) };
            fAntiAlias as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let fDither: u32 = unsafe { ::core::mem::transmute(fDither) };
            fDither as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let fCapType: u32 = unsafe { ::core::mem::transmute(fCapType) };
            fCapType as u64
        });
        __bindgen_bitfield_unit.set(4usize, 2u8, {
            let fJoinType: u32 = unsafe { ::core::mem::transmute(fJoinType) };
            fJoinType as u64
        });
        __bindgen_bitfield_unit.set(6usize, 2u8, {
            let fStyle: u32 = unsafe { ::core::mem::transmute(fStyle) };
            fStyle as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let fPadding: u32 = unsafe { ::core::mem::transmute(fPadding) };
            fPadding as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SkPaint__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SkPaint__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(SkPaint__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<SkPaint__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(SkPaint__bindgen_ty_1))
    );
    fn test_field_fBitfields() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkPaint__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fBitfields) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SkPaint__bindgen_ty_1),
                "::",
                stringify!(fBitfields)
            )
        );
    }
    test_field_fBitfields();
    fn test_field_fBitfieldsUInt() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkPaint__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fBitfieldsUInt) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SkPaint__bindgen_ty_1),
                "::",
                stringify!(fBitfieldsUInt)
            )
        );
    }
    test_field_fBitfieldsUInt();
}
pub const SkPaint_kStyleCount: ::std::os::raw::c_int = 3;
pub const SkPaint_kCapCount: ::std::os::raw::c_int = 3;
pub const SkPaint_kJoinCount: ::std::os::raw::c_int = 3;
#[test]
fn bindgen_test_layout_SkPaint() {
    assert_eq!(
        ::core::mem::size_of::<SkPaint>(),
        80usize,
        concat!("Size of: ", stringify!(SkPaint))
    );
    assert_eq!(
        ::core::mem::align_of::<SkPaint>(),
        8usize,
        concat!("Alignment of ", stringify!(SkPaint))
    );
    fn test_field_fPathEffect() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkPaint>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fPathEffect) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SkPaint),
                "::",
                stringify!(fPathEffect)
            )
        );
    }
    test_field_fPathEffect();
    fn test_field_fShader() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkPaint>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fShader) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(SkPaint),
                "::",
                stringify!(fShader)
            )
        );
    }
    test_field_fShader();
    fn test_field_fMaskFilter() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkPaint>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fMaskFilter) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(SkPaint),
                "::",
                stringify!(fMaskFilter)
            )
        );
    }
    test_field_fMaskFilter();
    fn test_field_fColorFilter() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkPaint>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fColorFilter) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(SkPaint),
                "::",
                stringify!(fColorFilter)
            )
        );
    }
    test_field_fColorFilter();
    fn test_field_fImageFilter() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkPaint>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fImageFilter) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(SkPaint),
                "::",
                stringify!(fImageFilter)
            )
        );
    }
    test_field_fImageFilter();
    fn test_field_fBlender() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkPaint>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fBlender) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(SkPaint),
                "::",
                stringify!(fBlender)
            )
        );
    }
    test_field_fBlender();
    fn test_field_fColor4f() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkPaint>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fColor4f) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(SkPaint),
                "::",
                stringify!(fColor4f)
            )
        );
    }
    test_field_fColor4f();
    fn test_field_fWidth() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkPaint>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fWidth) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(SkPaint),
                "::",
                stringify!(fWidth)
            )
        );
    }
    test_field_fWidth();
    fn test_field_fMiterLimit() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkPaint>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fMiterLimit) as usize - ptr as usize
            },
            68usize,
            concat!(
                "Offset of field: ",
                stringify!(SkPaint),
                "::",
                stringify!(fMiterLimit)
            )
        );
    }
    test_field_fMiterLimit();
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkPaint5resetEv"]
    pub fn SkPaint_reset(this: *mut SkPaint);
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkPaint8setStyleENS_5StyleE"]
    pub fn SkPaint_setStyle(this: *mut SkPaint, style: SkPaint_Style);
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkPaint9setStrokeEb"]
    pub fn SkPaint_setStroke(this: *mut SkPaint, arg1: bool);
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkPaint8setColorEj"]
    pub fn SkPaint_setColor(this: *mut SkPaint, color: SkColor);
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkPaint8setColorERK8SkRGBA4fIL11SkAlphaType3EEP12SkColorSpace"]
    pub fn SkPaint_setColor1(
        this: *mut SkPaint,
        color: *const SkColor4f,
        colorSpace: *mut SkColorSpace,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkPaint9setAlphafEf"]
    pub fn SkPaint_setAlphaf(this: *mut SkPaint, a: f32);
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkPaint7setARGBEjjjj"]
    pub fn SkPaint_setARGB(this: *mut SkPaint, a: U8CPU, r: U8CPU, g: U8CPU, b: U8CPU);
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkPaint14setStrokeWidthEf"]
    pub fn SkPaint_setStrokeWidth(this: *mut SkPaint, width: SkScalar);
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkPaint14setStrokeMiterEf"]
    pub fn SkPaint_setStrokeMiter(this: *mut SkPaint, miter: SkScalar);
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkPaint12setStrokeCapENS_3CapE"]
    pub fn SkPaint_setStrokeCap(this: *mut SkPaint, cap: SkPaint_Cap);
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkPaint13setStrokeJoinENS_4JoinE"]
    pub fn SkPaint_setStrokeJoin(this: *mut SkPaint, join: SkPaint_Join);
}
extern "C" {
    #[link_name = "\u{1}__ZNK7SkPaint11getFillPathERK6SkPathPS0_PK6SkRectf"]
    pub fn SkPaint_getFillPath(
        this: *const SkPaint,
        src: *const SkPath,
        dst: *mut SkPath,
        cullRect: *const SkRect,
        resScale: SkScalar,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK7SkPaint11getFillPathERK6SkPathPS0_PK6SkRectRK8SkMatrix"]
    pub fn SkPaint_getFillPath1(
        this: *const SkPaint,
        src: *const SkPath,
        dst: *mut SkPath,
        cullRect: *const SkRect,
        ctm: *const SkMatrix,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK7SkPaint9refShaderEv"]
    pub fn SkPaint_refShader(this: *const SkPaint) -> sk_sp<SkShader>;
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkPaint9setShaderE5sk_spI8SkShaderE"]
    pub fn SkPaint_setShader(this: *mut SkPaint, shader: sk_sp<SkShader>);
}
extern "C" {
    #[link_name = "\u{1}__ZNK7SkPaint14refColorFilterEv"]
    pub fn SkPaint_refColorFilter(this: *const SkPaint) -> sk_sp<SkColorFilter>;
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkPaint14setColorFilterE5sk_spI13SkColorFilterE"]
    pub fn SkPaint_setColorFilter(this: *mut SkPaint, colorFilter: sk_sp<SkColorFilter>);
}
extern "C" {
    #[link_name = "\u{1}__ZNK7SkPaint11asBlendModeEv"]
    pub fn SkPaint_asBlendMode(this: *const SkPaint) -> [u32; 2usize];
}
extern "C" {
    #[link_name = "\u{1}__ZNK7SkPaint15getBlendMode_orE11SkBlendMode"]
    pub fn SkPaint_getBlendMode_or(this: *const SkPaint, defaultMode: SkBlendMode) -> SkBlendMode;
}
extern "C" {
    #[link_name = "\u{1}__ZNK7SkPaint9isSrcOverEv"]
    pub fn SkPaint_isSrcOver(this: *const SkPaint) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkPaint12setBlendModeE11SkBlendMode"]
    pub fn SkPaint_setBlendMode(this: *mut SkPaint, mode: SkBlendMode);
}
extern "C" {
    #[link_name = "\u{1}__ZNK7SkPaint10refBlenderEv"]
    pub fn SkPaint_refBlender(this: *const SkPaint) -> sk_sp<SkBlender>;
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkPaint10setBlenderE5sk_spI9SkBlenderE"]
    pub fn SkPaint_setBlender(this: *mut SkPaint, blender: sk_sp<SkBlender>);
}
extern "C" {
    #[link_name = "\u{1}__ZNK7SkPaint13refPathEffectEv"]
    pub fn SkPaint_refPathEffect(this: *const SkPaint) -> sk_sp<SkPathEffect>;
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkPaint13setPathEffectE5sk_spI12SkPathEffectE"]
    pub fn SkPaint_setPathEffect(this: *mut SkPaint, pathEffect: sk_sp<SkPathEffect>);
}
extern "C" {
    #[link_name = "\u{1}__ZNK7SkPaint13refMaskFilterEv"]
    pub fn SkPaint_refMaskFilter(this: *const SkPaint) -> sk_sp<SkMaskFilter>;
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkPaint13setMaskFilterE5sk_spI12SkMaskFilterE"]
    pub fn SkPaint_setMaskFilter(this: *mut SkPaint, maskFilter: sk_sp<SkMaskFilter>);
}
extern "C" {
    #[link_name = "\u{1}__ZNK7SkPaint14refImageFilterEv"]
    pub fn SkPaint_refImageFilter(this: *const SkPaint) -> sk_sp<SkImageFilter>;
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkPaint14setImageFilterE5sk_spI13SkImageFilterE"]
    pub fn SkPaint_setImageFilter(this: *mut SkPaint, imageFilter: sk_sp<SkImageFilter>);
}
extern "C" {
    #[link_name = "\u{1}__ZNK7SkPaint13nothingToDrawEv"]
    pub fn SkPaint_nothingToDraw(this: *const SkPaint) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK7SkPaint20canComputeFastBoundsEv"]
    pub fn SkPaint_canComputeFastBounds(this: *const SkPaint) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK7SkPaint17computeFastBoundsERK6SkRectPS0_"]
    pub fn SkPaint_computeFastBounds(
        this: *const SkPaint,
        orig: *const SkRect,
        storage: *mut SkRect,
    ) -> *const SkRect;
}
extern "C" {
    #[link_name = "\u{1}__ZNK7SkPaint19doComputeFastBoundsERK6SkRectPS0_NS_5StyleE"]
    pub fn SkPaint_doComputeFastBounds(
        this: *const SkPaint,
        orig: *const SkRect,
        storage: *mut SkRect,
        style: SkPaint_Style,
    ) -> *const SkRect;
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkPaintC1Ev"]
    pub fn SkPaint_SkPaint(this: *mut SkPaint);
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkPaintC1ERK8SkRGBA4fIL11SkAlphaType3EEP12SkColorSpace"]
    pub fn SkPaint_SkPaint1(
        this: *mut SkPaint,
        color: *const SkColor4f,
        colorSpace: *mut SkColorSpace,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkPaintC1ERKS_"]
    pub fn SkPaint_SkPaint2(this: *mut SkPaint, paint: *const SkPaint);
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkPaintC1EOS_"]
    pub fn SkPaint_SkPaint3(this: *mut SkPaint, paint: *mut SkPaint);
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkPaintD1Ev"]
    pub fn SkPaint_SkPaint_destructor(this: *mut SkPaint);
}
impl SkPaint {
    #[inline]
    pub unsafe fn reset(&mut self) {
        SkPaint_reset(self)
    }
    #[inline]
    pub unsafe fn setStyle(&mut self, style: SkPaint_Style) {
        SkPaint_setStyle(self, style)
    }
    #[inline]
    pub unsafe fn setStroke(&mut self, arg1: bool) {
        SkPaint_setStroke(self, arg1)
    }
    #[inline]
    pub unsafe fn setColor(&mut self, color: SkColor) {
        SkPaint_setColor(self, color)
    }
    #[inline]
    pub unsafe fn setColor1(&mut self, color: *const SkColor4f, colorSpace: *mut SkColorSpace) {
        SkPaint_setColor1(self, color, colorSpace)
    }
    #[inline]
    pub unsafe fn setAlphaf(&mut self, a: f32) {
        SkPaint_setAlphaf(self, a)
    }
    #[inline]
    pub unsafe fn setARGB(&mut self, a: U8CPU, r: U8CPU, g: U8CPU, b: U8CPU) {
        SkPaint_setARGB(self, a, r, g, b)
    }
    #[inline]
    pub unsafe fn setStrokeWidth(&mut self, width: SkScalar) {
        SkPaint_setStrokeWidth(self, width)
    }
    #[inline]
    pub unsafe fn setStrokeMiter(&mut self, miter: SkScalar) {
        SkPaint_setStrokeMiter(self, miter)
    }
    #[inline]
    pub unsafe fn setStrokeCap(&mut self, cap: SkPaint_Cap) {
        SkPaint_setStrokeCap(self, cap)
    }
    #[inline]
    pub unsafe fn setStrokeJoin(&mut self, join: SkPaint_Join) {
        SkPaint_setStrokeJoin(self, join)
    }
    #[inline]
    pub unsafe fn getFillPath(
        &self,
        src: *const SkPath,
        dst: *mut SkPath,
        cullRect: *const SkRect,
        resScale: SkScalar,
    ) -> bool {
        SkPaint_getFillPath(self, src, dst, cullRect, resScale)
    }
    #[inline]
    pub unsafe fn getFillPath1(
        &self,
        src: *const SkPath,
        dst: *mut SkPath,
        cullRect: *const SkRect,
        ctm: *const SkMatrix,
    ) -> bool {
        SkPaint_getFillPath1(self, src, dst, cullRect, ctm)
    }
    #[inline]
    pub unsafe fn refShader(&self) -> sk_sp<SkShader> {
        SkPaint_refShader(self)
    }
    #[inline]
    pub unsafe fn setShader(&mut self, shader: sk_sp<SkShader>) {
        SkPaint_setShader(self, shader)
    }
    #[inline]
    pub unsafe fn refColorFilter(&self) -> sk_sp<SkColorFilter> {
        SkPaint_refColorFilter(self)
    }
    #[inline]
    pub unsafe fn setColorFilter(&mut self, colorFilter: sk_sp<SkColorFilter>) {
        SkPaint_setColorFilter(self, colorFilter)
    }
    #[inline]
    pub unsafe fn asBlendMode(&self) -> [u32; 2usize] {
        SkPaint_asBlendMode(self)
    }
    #[inline]
    pub unsafe fn getBlendMode_or(&self, defaultMode: SkBlendMode) -> SkBlendMode {
        SkPaint_getBlendMode_or(self, defaultMode)
    }
    #[inline]
    pub unsafe fn isSrcOver(&self) -> bool {
        SkPaint_isSrcOver(self)
    }
    #[inline]
    pub unsafe fn setBlendMode(&mut self, mode: SkBlendMode) {
        SkPaint_setBlendMode(self, mode)
    }
    #[inline]
    pub unsafe fn refBlender(&self) -> sk_sp<SkBlender> {
        SkPaint_refBlender(self)
    }
    #[inline]
    pub unsafe fn setBlender(&mut self, blender: sk_sp<SkBlender>) {
        SkPaint_setBlender(self, blender)
    }
    #[inline]
    pub unsafe fn refPathEffect(&self) -> sk_sp<SkPathEffect> {
        SkPaint_refPathEffect(self)
    }
    #[inline]
    pub unsafe fn setPathEffect(&mut self, pathEffect: sk_sp<SkPathEffect>) {
        SkPaint_setPathEffect(self, pathEffect)
    }
    #[inline]
    pub unsafe fn refMaskFilter(&self) -> sk_sp<SkMaskFilter> {
        SkPaint_refMaskFilter(self)
    }
    #[inline]
    pub unsafe fn setMaskFilter(&mut self, maskFilter: sk_sp<SkMaskFilter>) {
        SkPaint_setMaskFilter(self, maskFilter)
    }
    #[inline]
    pub unsafe fn refImageFilter(&self) -> sk_sp<SkImageFilter> {
        SkPaint_refImageFilter(self)
    }
    #[inline]
    pub unsafe fn setImageFilter(&mut self, imageFilter: sk_sp<SkImageFilter>) {
        SkPaint_setImageFilter(self, imageFilter)
    }
    #[inline]
    pub unsafe fn nothingToDraw(&self) -> bool {
        SkPaint_nothingToDraw(self)
    }
    #[inline]
    pub unsafe fn canComputeFastBounds(&self) -> bool {
        SkPaint_canComputeFastBounds(self)
    }
    #[inline]
    pub unsafe fn computeFastBounds(
        &self,
        orig: *const SkRect,
        storage: *mut SkRect,
    ) -> *const SkRect {
        SkPaint_computeFastBounds(self, orig, storage)
    }
    #[inline]
    pub unsafe fn doComputeFastBounds(
        &self,
        orig: *const SkRect,
        storage: *mut SkRect,
        style: SkPaint_Style,
    ) -> *const SkRect {
        SkPaint_doComputeFastBounds(self, orig, storage, style)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkPaint_SkPaint(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(color: *const SkColor4f, colorSpace: *mut SkColorSpace) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkPaint_SkPaint1(__bindgen_tmp.as_mut_ptr(), color, colorSpace);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(paint: *const SkPaint) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkPaint_SkPaint2(__bindgen_tmp.as_mut_ptr(), paint);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new3(paint: *mut SkPaint) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkPaint_SkPaint3(__bindgen_tmp.as_mut_ptr(), paint);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        SkPaint_SkPaint_destructor(self)
    }
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct SkRasterHandleAllocator {
    pub _bindgen_opaque_blob: u64,
}
pub type SkRasterHandleAllocator_Handle = *mut ::core::ffi::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkRasterHandleAllocator_Rec {
    pub fReleaseProc: ::core::option::Option<
        unsafe extern "C" fn(pixels: *mut ::core::ffi::c_void, ctx: *mut ::core::ffi::c_void),
    >,
    pub fReleaseCtx: *mut ::core::ffi::c_void,
    pub fPixels: *mut ::core::ffi::c_void,
    pub fRowBytes: usize,
    pub fHandle: SkRasterHandleAllocator_Handle,
}
#[test]
fn bindgen_test_layout_SkRasterHandleAllocator_Rec() {
    assert_eq!(
        ::core::mem::size_of::<SkRasterHandleAllocator_Rec>(),
        40usize,
        concat!("Size of: ", stringify!(SkRasterHandleAllocator_Rec))
    );
    assert_eq!(
        ::core::mem::align_of::<SkRasterHandleAllocator_Rec>(),
        8usize,
        concat!("Alignment of ", stringify!(SkRasterHandleAllocator_Rec))
    );
    fn test_field_fReleaseProc() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkRasterHandleAllocator_Rec>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fReleaseProc) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SkRasterHandleAllocator_Rec),
                "::",
                stringify!(fReleaseProc)
            )
        );
    }
    test_field_fReleaseProc();
    fn test_field_fReleaseCtx() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkRasterHandleAllocator_Rec>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fReleaseCtx) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(SkRasterHandleAllocator_Rec),
                "::",
                stringify!(fReleaseCtx)
            )
        );
    }
    test_field_fReleaseCtx();
    fn test_field_fPixels() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkRasterHandleAllocator_Rec>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fPixels) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(SkRasterHandleAllocator_Rec),
                "::",
                stringify!(fPixels)
            )
        );
    }
    test_field_fPixels();
    fn test_field_fRowBytes() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkRasterHandleAllocator_Rec>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fRowBytes) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(SkRasterHandleAllocator_Rec),
                "::",
                stringify!(fRowBytes)
            )
        );
    }
    test_field_fRowBytes();
    fn test_field_fHandle() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkRasterHandleAllocator_Rec>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fHandle) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(SkRasterHandleAllocator_Rec),
                "::",
                stringify!(fHandle)
            )
        );
    }
    test_field_fHandle();
}
#[test]
fn bindgen_test_layout_SkRasterHandleAllocator() {
    assert_eq!(
        ::core::mem::size_of::<SkRasterHandleAllocator>(),
        8usize,
        concat!("Size of: ", stringify!(SkRasterHandleAllocator))
    );
    assert_eq!(
        ::core::mem::align_of::<SkRasterHandleAllocator>(),
        8usize,
        concat!("Alignment of ", stringify!(SkRasterHandleAllocator))
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN23SkRasterHandleAllocator10MakeCanvasENSt3__110unique_ptrIS_NS0_14default_deleteIS_EEEERK11SkImageInfoPKNS_3RecEPK14SkSurfaceProps"]
    pub fn SkRasterHandleAllocator_MakeCanvas(
        arg1: u64,
        arg2: *const SkImageInfo,
        rec: *const SkRasterHandleAllocator_Rec,
        props: *const SkSurfaceProps,
    ) -> u64;
}
impl SkRasterHandleAllocator {
    #[inline]
    pub unsafe fn MakeCanvas(
        arg1: u64,
        arg2: *const SkImageInfo,
        rec: *const SkRasterHandleAllocator_Rec,
        props: *const SkSurfaceProps,
    ) -> u64 {
        SkRasterHandleAllocator_MakeCanvas(arg1, arg2, rec, props)
    }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkPixelGeometry {
    kUnknown_SkPixelGeometry = 0,
    kRGB_H_SkPixelGeometry = 1,
    kBGR_H_SkPixelGeometry = 2,
    kRGB_V_SkPixelGeometry = 3,
    kBGR_V_SkPixelGeometry = 4,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkSurfaceProps {
    pub fFlags: u32,
    pub fPixelGeometry: SkPixelGeometry,
}
pub const SkSurfaceProps_Flags_kUseDeviceIndependentFonts_Flag: SkSurfaceProps_Flags = 1;
pub const SkSurfaceProps_Flags_kDynamicMSAA_Flag: SkSurfaceProps_Flags = 2;
pub type SkSurfaceProps_Flags = ::std::os::raw::c_uint;
extern "C" {
    #[link_name = "\u{1}__ZN14SkSurfaceProps27kUseDistanceFieldFonts_FlagE"]
    pub static SkSurfaceProps_kUseDistanceFieldFonts_Flag: SkSurfaceProps_Flags;
}
#[test]
fn bindgen_test_layout_SkSurfaceProps() {
    assert_eq!(
        ::core::mem::size_of::<SkSurfaceProps>(),
        8usize,
        concat!("Size of: ", stringify!(SkSurfaceProps))
    );
    assert_eq!(
        ::core::mem::align_of::<SkSurfaceProps>(),
        4usize,
        concat!("Alignment of ", stringify!(SkSurfaceProps))
    );
    fn test_field_fFlags() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkSurfaceProps>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fFlags) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SkSurfaceProps),
                "::",
                stringify!(fFlags)
            )
        );
    }
    test_field_fFlags();
    fn test_field_fPixelGeometry() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkSurfaceProps>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fPixelGeometry) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(SkSurfaceProps),
                "::",
                stringify!(fPixelGeometry)
            )
        );
    }
    test_field_fPixelGeometry();
}
extern "C" {
    #[link_name = "\u{1}__ZN14SkSurfacePropsC1Ev"]
    pub fn SkSurfaceProps_SkSurfaceProps(this: *mut SkSurfaceProps);
}
extern "C" {
    #[link_name = "\u{1}__ZN14SkSurfacePropsC1Ej15SkPixelGeometry"]
    pub fn SkSurfaceProps_SkSurfaceProps1(
        this: *mut SkSurfaceProps,
        flags: u32,
        arg1: SkPixelGeometry,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN14SkSurfacePropsC1ERKS_"]
    pub fn SkSurfaceProps_SkSurfaceProps2(this: *mut SkSurfaceProps, arg1: *const SkSurfaceProps);
}
impl SkSurfaceProps {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkSurfaceProps_SkSurfaceProps(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(flags: u32, arg1: SkPixelGeometry) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkSurfaceProps_SkSurfaceProps1(__bindgen_tmp.as_mut_ptr(), flags, arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(arg1: *const SkSurfaceProps) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkSurfaceProps_SkSurfaceProps2(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct SkDeque {
    pub _bindgen_opaque_blob: [u64; 7usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkDeque_Block {
    _unused: [u8; 0],
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct SkDeque_Iter {
    pub _bindgen_opaque_blob: [u64; 3usize],
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkDeque_Iter_IterStart {
    kFront_IterStart = 0,
    kBack_IterStart = 1,
}
#[test]
fn bindgen_test_layout_SkDeque_Iter() {
    assert_eq!(
        ::core::mem::size_of::<SkDeque_Iter>(),
        24usize,
        concat!("Size of: ", stringify!(SkDeque_Iter))
    );
    assert_eq!(
        ::core::mem::align_of::<SkDeque_Iter>(),
        8usize,
        concat!("Alignment of ", stringify!(SkDeque_Iter))
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkDeque4Iter4nextEv"]
    pub fn SkDeque_Iter_next(this: *mut SkDeque_Iter) -> *mut ::core::ffi::c_void;
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkDeque4Iter4prevEv"]
    pub fn SkDeque_Iter_prev(this: *mut SkDeque_Iter) -> *mut ::core::ffi::c_void;
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkDeque4Iter5resetERKS_NS0_9IterStartE"]
    pub fn SkDeque_Iter_reset(
        this: *mut SkDeque_Iter,
        d: *const SkDeque,
        startLoc: SkDeque_Iter_IterStart,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkDeque4IterC1Ev"]
    pub fn SkDeque_Iter_Iter(this: *mut SkDeque_Iter);
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkDeque4IterC1ERKS_NS0_9IterStartE"]
    pub fn SkDeque_Iter_Iter1(
        this: *mut SkDeque_Iter,
        d: *const SkDeque,
        startLoc: SkDeque_Iter_IterStart,
    );
}
impl SkDeque_Iter {
    #[inline]
    pub unsafe fn next(&mut self) -> *mut ::core::ffi::c_void {
        SkDeque_Iter_next(self)
    }
    #[inline]
    pub unsafe fn prev(&mut self) -> *mut ::core::ffi::c_void {
        SkDeque_Iter_prev(self)
    }
    #[inline]
    pub unsafe fn reset(&mut self, d: *const SkDeque, startLoc: SkDeque_Iter_IterStart) {
        SkDeque_Iter_reset(self, d, startLoc)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkDeque_Iter_Iter(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(d: *const SkDeque, startLoc: SkDeque_Iter_IterStart) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkDeque_Iter_Iter1(__bindgen_tmp.as_mut_ptr(), d, startLoc);
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct SkDeque_F2BIter {
    pub _bindgen_opaque_blob: [u64; 3usize],
}
pub type SkDeque_F2BIter_INHERITED = SkDeque_Iter;
#[test]
fn bindgen_test_layout_SkDeque_F2BIter() {
    assert_eq!(
        ::core::mem::size_of::<SkDeque_F2BIter>(),
        24usize,
        concat!("Size of: ", stringify!(SkDeque_F2BIter))
    );
    assert_eq!(
        ::core::mem::align_of::<SkDeque_F2BIter>(),
        8usize,
        concat!("Alignment of ", stringify!(SkDeque_F2BIter))
    );
}
#[test]
fn bindgen_test_layout_SkDeque() {
    assert_eq!(
        ::core::mem::size_of::<SkDeque>(),
        56usize,
        concat!("Size of: ", stringify!(SkDeque))
    );
    assert_eq!(
        ::core::mem::align_of::<SkDeque>(),
        8usize,
        concat!("Alignment of ", stringify!(SkDeque))
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkDeque10push_frontEv"]
    pub fn SkDeque_push_front(this: *mut SkDeque) -> *mut ::core::ffi::c_void;
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkDeque9push_backEv"]
    pub fn SkDeque_push_back(this: *mut SkDeque) -> *mut ::core::ffi::c_void;
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkDeque9pop_frontEv"]
    pub fn SkDeque_pop_front(this: *mut SkDeque);
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkDeque8pop_backEv"]
    pub fn SkDeque_pop_back(this: *mut SkDeque);
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkDequeC1Emi"]
    pub fn SkDeque_SkDeque(this: *mut SkDeque, elemSize: usize, allocCount: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkDequeC1EmPvmi"]
    pub fn SkDeque_SkDeque1(
        this: *mut SkDeque,
        elemSize: usize,
        storage: *mut ::core::ffi::c_void,
        storageSize: usize,
        allocCount: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkDequeD1Ev"]
    pub fn SkDeque_SkDeque_destructor(this: *mut SkDeque);
}
impl SkDeque {
    #[inline]
    pub unsafe fn push_front(&mut self) -> *mut ::core::ffi::c_void {
        SkDeque_push_front(self)
    }
    #[inline]
    pub unsafe fn push_back(&mut self) -> *mut ::core::ffi::c_void {
        SkDeque_push_back(self)
    }
    #[inline]
    pub unsafe fn pop_front(&mut self) {
        SkDeque_pop_front(self)
    }
    #[inline]
    pub unsafe fn pop_back(&mut self) {
        SkDeque_pop_back(self)
    }
    #[inline]
    pub unsafe fn new(elemSize: usize, allocCount: ::std::os::raw::c_int) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkDeque_SkDeque(__bindgen_tmp.as_mut_ptr(), elemSize, allocCount);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(
        elemSize: usize,
        storage: *mut ::core::ffi::c_void,
        storageSize: usize,
        allocCount: ::std::os::raw::c_int,
    ) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkDeque_SkDeque1(
            __bindgen_tmp.as_mut_ptr(),
            elemSize,
            storage,
            storageSize,
            allocCount,
        );
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        SkDeque_SkDeque_destructor(self)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sktext_GlyphRunBuilder {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sktext_GlyphRunList {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GrRecordingContext {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkBaseDevice {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkDrawShadowRec {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkMesh {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkSpecialImage {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkSurface_Base {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct skgpu_graphite_Recorder {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct SkCanvas__bindgen_vtable(::core::ffi::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct SkCanvas {
    pub vtable_: *const SkCanvas__bindgen_vtable,
    pub fMCRecStorage: [isize; 384usize],
    pub fMCStack: SkDeque,
    pub fMCRec: *mut SkCanvas_MCRec,
    pub fBaseDevice: sk_sp<SkBaseDevice>,
    pub fProps: SkSurfaceProps,
    pub fSaveCount: ::std::os::raw::c_int,
    pub fAllocator: u64,
    pub fSurfaceBase: *mut SkSurface_Base,
    pub fClipRestrictionRect: SkIRect,
    pub fClipRestrictionSaveCount: ::std::os::raw::c_int,
    pub fQuickRejectBounds: SkRect,
    pub fScratchGlyphRunBuilder: u64,
}
pub const SkCanvas_SaveLayerFlagsSet_kPreserveLCDText_SaveLayerFlag: SkCanvas_SaveLayerFlagsSet = 2;
pub const SkCanvas_SaveLayerFlagsSet_kInitWithPrevious_SaveLayerFlag: SkCanvas_SaveLayerFlagsSet =
    4;
pub const SkCanvas_SaveLayerFlagsSet_kF16ColorType: SkCanvas_SaveLayerFlagsSet = 16;
pub type SkCanvas_SaveLayerFlagsSet = ::std::os::raw::c_uint;
pub type SkCanvas_SaveLayerFlags = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkCanvas_SaveLayerRec {
    pub fBounds: *const SkRect,
    pub fPaint: *const SkPaint,
    pub fBackdrop: *const SkImageFilter,
    pub fSaveLayerFlags: SkCanvas_SaveLayerFlags,
    pub fExperimentalBackdropScale: SkScalar,
}
#[test]
fn bindgen_test_layout_SkCanvas_SaveLayerRec() {
    assert_eq!(
        ::core::mem::size_of::<SkCanvas_SaveLayerRec>(),
        32usize,
        concat!("Size of: ", stringify!(SkCanvas_SaveLayerRec))
    );
    assert_eq!(
        ::core::mem::align_of::<SkCanvas_SaveLayerRec>(),
        8usize,
        concat!("Alignment of ", stringify!(SkCanvas_SaveLayerRec))
    );
    fn test_field_fBounds() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkCanvas_SaveLayerRec>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fBounds) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SkCanvas_SaveLayerRec),
                "::",
                stringify!(fBounds)
            )
        );
    }
    test_field_fBounds();
    fn test_field_fPaint() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkCanvas_SaveLayerRec>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fPaint) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(SkCanvas_SaveLayerRec),
                "::",
                stringify!(fPaint)
            )
        );
    }
    test_field_fPaint();
    fn test_field_fBackdrop() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkCanvas_SaveLayerRec>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fBackdrop) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(SkCanvas_SaveLayerRec),
                "::",
                stringify!(fBackdrop)
            )
        );
    }
    test_field_fBackdrop();
    fn test_field_fSaveLayerFlags() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkCanvas_SaveLayerRec>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fSaveLayerFlags) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(SkCanvas_SaveLayerRec),
                "::",
                stringify!(fSaveLayerFlags)
            )
        );
    }
    test_field_fSaveLayerFlags();
    fn test_field_fExperimentalBackdropScale() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkCanvas_SaveLayerRec>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fExperimentalBackdropScale) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(SkCanvas_SaveLayerRec),
                "::",
                stringify!(fExperimentalBackdropScale)
            )
        );
    }
    test_field_fExperimentalBackdropScale();
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkCanvas_PointMode {
    Points = 0,
    Lines = 1,
    Polygon = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkCanvas_SrcRectConstraint {
    Strict = 0,
    Fast = 1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkCanvas_Lattice {
    pub fXDivs: *const ::std::os::raw::c_int,
    pub fYDivs: *const ::std::os::raw::c_int,
    pub fRectTypes: *const SkCanvas_Lattice_RectType,
    pub fXCount: ::std::os::raw::c_int,
    pub fYCount: ::std::os::raw::c_int,
    pub fBounds: *const SkIRect,
    pub fColors: *const SkColor,
}
#[repr(u8)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkCanvas_Lattice_RectType {
    Default = 0,
    Transparent = 1,
    FixedColor = 2,
}
#[test]
fn bindgen_test_layout_SkCanvas_Lattice() {
    assert_eq!(
        ::core::mem::size_of::<SkCanvas_Lattice>(),
        48usize,
        concat!("Size of: ", stringify!(SkCanvas_Lattice))
    );
    assert_eq!(
        ::core::mem::align_of::<SkCanvas_Lattice>(),
        8usize,
        concat!("Alignment of ", stringify!(SkCanvas_Lattice))
    );
    fn test_field_fXDivs() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkCanvas_Lattice>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fXDivs) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SkCanvas_Lattice),
                "::",
                stringify!(fXDivs)
            )
        );
    }
    test_field_fXDivs();
    fn test_field_fYDivs() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkCanvas_Lattice>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fYDivs) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(SkCanvas_Lattice),
                "::",
                stringify!(fYDivs)
            )
        );
    }
    test_field_fYDivs();
    fn test_field_fRectTypes() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkCanvas_Lattice>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fRectTypes) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(SkCanvas_Lattice),
                "::",
                stringify!(fRectTypes)
            )
        );
    }
    test_field_fRectTypes();
    fn test_field_fXCount() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkCanvas_Lattice>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fXCount) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(SkCanvas_Lattice),
                "::",
                stringify!(fXCount)
            )
        );
    }
    test_field_fXCount();
    fn test_field_fYCount() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkCanvas_Lattice>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fYCount) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(SkCanvas_Lattice),
                "::",
                stringify!(fYCount)
            )
        );
    }
    test_field_fYCount();
    fn test_field_fBounds() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkCanvas_Lattice>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fBounds) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(SkCanvas_Lattice),
                "::",
                stringify!(fBounds)
            )
        );
    }
    test_field_fBounds();
    fn test_field_fColors() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkCanvas_Lattice>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fColors) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(SkCanvas_Lattice),
                "::",
                stringify!(fColors)
            )
        );
    }
    test_field_fColors();
}
pub const SkCanvas_QuadAAFlags_kLeft_QuadAAFlag: SkCanvas_QuadAAFlags = 1;
pub const SkCanvas_QuadAAFlags_kTop_QuadAAFlag: SkCanvas_QuadAAFlags = 2;
pub const SkCanvas_QuadAAFlags_kRight_QuadAAFlag: SkCanvas_QuadAAFlags = 4;
pub const SkCanvas_QuadAAFlags_kBottom_QuadAAFlag: SkCanvas_QuadAAFlags = 8;
pub const SkCanvas_QuadAAFlags_kNone_QuadAAFlags: SkCanvas_QuadAAFlags = 0;
pub const SkCanvas_QuadAAFlags_kAll_QuadAAFlags: SkCanvas_QuadAAFlags = 15;
pub type SkCanvas_QuadAAFlags = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug)]
pub struct SkCanvas_ImageSetEntry {
    pub fImage: sk_sp<SkImage>,
    pub fSrcRect: SkRect,
    pub fDstRect: SkRect,
    pub fMatrixIndex: ::std::os::raw::c_int,
    pub fAlpha: f32,
    pub fAAFlags: ::std::os::raw::c_uint,
    pub fHasClip: bool,
}
#[test]
fn bindgen_test_layout_SkCanvas_ImageSetEntry() {
    assert_eq!(
        ::core::mem::size_of::<SkCanvas_ImageSetEntry>(),
        56usize,
        concat!("Size of: ", stringify!(SkCanvas_ImageSetEntry))
    );
    assert_eq!(
        ::core::mem::align_of::<SkCanvas_ImageSetEntry>(),
        8usize,
        concat!("Alignment of ", stringify!(SkCanvas_ImageSetEntry))
    );
    fn test_field_fImage() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkCanvas_ImageSetEntry>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fImage) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SkCanvas_ImageSetEntry),
                "::",
                stringify!(fImage)
            )
        );
    }
    test_field_fImage();
    fn test_field_fSrcRect() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkCanvas_ImageSetEntry>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fSrcRect) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(SkCanvas_ImageSetEntry),
                "::",
                stringify!(fSrcRect)
            )
        );
    }
    test_field_fSrcRect();
    fn test_field_fDstRect() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkCanvas_ImageSetEntry>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fDstRect) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(SkCanvas_ImageSetEntry),
                "::",
                stringify!(fDstRect)
            )
        );
    }
    test_field_fDstRect();
    fn test_field_fMatrixIndex() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkCanvas_ImageSetEntry>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fMatrixIndex) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(SkCanvas_ImageSetEntry),
                "::",
                stringify!(fMatrixIndex)
            )
        );
    }
    test_field_fMatrixIndex();
    fn test_field_fAlpha() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkCanvas_ImageSetEntry>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fAlpha) as usize - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(SkCanvas_ImageSetEntry),
                "::",
                stringify!(fAlpha)
            )
        );
    }
    test_field_fAlpha();
    fn test_field_fAAFlags() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkCanvas_ImageSetEntry>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fAAFlags) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(SkCanvas_ImageSetEntry),
                "::",
                stringify!(fAAFlags)
            )
        );
    }
    test_field_fAAFlags();
    fn test_field_fHasClip() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkCanvas_ImageSetEntry>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fHasClip) as usize - ptr as usize
            },
            52usize,
            concat!(
                "Offset of field: ",
                stringify!(SkCanvas_ImageSetEntry),
                "::",
                stringify!(fHasClip)
            )
        );
    }
    test_field_fHasClip();
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas13ImageSetEntryC1E5sk_spIK7SkImageERK6SkRectS7_ifjb"]
    pub fn SkCanvas_ImageSetEntry_ImageSetEntry(
        this: *mut SkCanvas_ImageSetEntry,
        image: sk_sp<SkImage>,
        srcRect: *const SkRect,
        dstRect: *const SkRect,
        matrixIndex: ::std::os::raw::c_int,
        alpha: f32,
        aaFlags: ::std::os::raw::c_uint,
        hasClip: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas13ImageSetEntryC1E5sk_spIK7SkImageERK6SkRectS7_fj"]
    pub fn SkCanvas_ImageSetEntry_ImageSetEntry1(
        this: *mut SkCanvas_ImageSetEntry,
        image: sk_sp<SkImage>,
        srcRect: *const SkRect,
        dstRect: *const SkRect,
        alpha: f32,
        aaFlags: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas13ImageSetEntryC1Ev"]
    pub fn SkCanvas_ImageSetEntry_ImageSetEntry2(this: *mut SkCanvas_ImageSetEntry);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas13ImageSetEntryC1ERKS0_"]
    pub fn SkCanvas_ImageSetEntry_ImageSetEntry3(
        this: *mut SkCanvas_ImageSetEntry,
        arg1: *const SkCanvas_ImageSetEntry,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas13ImageSetEntryD1Ev"]
    pub fn SkCanvas_ImageSetEntry_ImageSetEntry_destructor(this: *mut SkCanvas_ImageSetEntry);
}
impl SkCanvas_ImageSetEntry {
    #[inline]
    pub unsafe fn new(
        image: sk_sp<SkImage>,
        srcRect: *const SkRect,
        dstRect: *const SkRect,
        matrixIndex: ::std::os::raw::c_int,
        alpha: f32,
        aaFlags: ::std::os::raw::c_uint,
        hasClip: bool,
    ) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkCanvas_ImageSetEntry_ImageSetEntry(
            __bindgen_tmp.as_mut_ptr(),
            image,
            srcRect,
            dstRect,
            matrixIndex,
            alpha,
            aaFlags,
            hasClip,
        );
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(
        image: sk_sp<SkImage>,
        srcRect: *const SkRect,
        dstRect: *const SkRect,
        alpha: f32,
        aaFlags: ::std::os::raw::c_uint,
    ) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkCanvas_ImageSetEntry_ImageSetEntry1(
            __bindgen_tmp.as_mut_ptr(),
            image,
            srcRect,
            dstRect,
            alpha,
            aaFlags,
        );
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2() -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkCanvas_ImageSetEntry_ImageSetEntry2(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new3(arg1: *const SkCanvas_ImageSetEntry) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkCanvas_ImageSetEntry_ImageSetEntry3(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        SkCanvas_ImageSetEntry_ImageSetEntry_destructor(self)
    }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkCanvas_SaveLayerStrategy {
    kFullLayer_SaveLayerStrategy = 0,
    kNoLayer_SaveLayerStrategy = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkCanvas_ClipEdgeStyle {
    kHard_ClipEdgeStyle = 0,
    kSoft_ClipEdgeStyle = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkCanvas_ShaderOverrideOpacity {
    kNone_ShaderOverrideOpacity = 0,
    kOpaque_ShaderOverrideOpacity = 1,
    kNotOpaque_ShaderOverrideOpacity = 2,
}
#[repr(u8)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkCanvas_CheckForOverwrite {
    kNo = 0,
    kYes = 1,
}
#[repr(C)]
pub struct SkCanvas_Layer {
    pub fDevice: sk_sp<SkBaseDevice>,
    pub fImageFilter: sk_sp<SkImageFilter>,
    pub fPaint: SkPaint,
    pub fDiscard: bool,
}
#[test]
fn bindgen_test_layout_SkCanvas_Layer() {
    assert_eq!(
        ::core::mem::size_of::<SkCanvas_Layer>(),
        104usize,
        concat!("Size of: ", stringify!(SkCanvas_Layer))
    );
    assert_eq!(
        ::core::mem::align_of::<SkCanvas_Layer>(),
        8usize,
        concat!("Alignment of ", stringify!(SkCanvas_Layer))
    );
    fn test_field_fDevice() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkCanvas_Layer>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fDevice) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SkCanvas_Layer),
                "::",
                stringify!(fDevice)
            )
        );
    }
    test_field_fDevice();
    fn test_field_fImageFilter() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkCanvas_Layer>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fImageFilter) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(SkCanvas_Layer),
                "::",
                stringify!(fImageFilter)
            )
        );
    }
    test_field_fImageFilter();
    fn test_field_fPaint() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkCanvas_Layer>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fPaint) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(SkCanvas_Layer),
                "::",
                stringify!(fPaint)
            )
        );
    }
    test_field_fPaint();
    fn test_field_fDiscard() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkCanvas_Layer>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fDiscard) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(SkCanvas_Layer),
                "::",
                stringify!(fDiscard)
            )
        );
    }
    test_field_fDiscard();
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas5LayerC1E5sk_spI12SkBaseDeviceES1_I13SkImageFilterERK7SkPaint"]
    pub fn SkCanvas_Layer_Layer(
        this: *mut SkCanvas_Layer,
        device: sk_sp<SkBaseDevice>,
        imageFilter: sk_sp<SkImageFilter>,
        paint: *const SkPaint,
    );
}
impl SkCanvas_Layer {
    #[inline]
    pub unsafe fn new(
        device: sk_sp<SkBaseDevice>,
        imageFilter: sk_sp<SkImageFilter>,
        paint: *const SkPaint,
    ) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkCanvas_Layer_Layer(__bindgen_tmp.as_mut_ptr(), device, imageFilter, paint);
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct SkCanvas_BackImage {
    pub fImage: sk_sp<SkSpecialImage>,
    pub fLoc: SkIPoint,
}
#[test]
fn bindgen_test_layout_SkCanvas_BackImage() {
    assert_eq!(
        ::core::mem::size_of::<SkCanvas_BackImage>(),
        16usize,
        concat!("Size of: ", stringify!(SkCanvas_BackImage))
    );
    assert_eq!(
        ::core::mem::align_of::<SkCanvas_BackImage>(),
        8usize,
        concat!("Alignment of ", stringify!(SkCanvas_BackImage))
    );
    fn test_field_fImage() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkCanvas_BackImage>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fImage) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SkCanvas_BackImage),
                "::",
                stringify!(fImage)
            )
        );
    }
    test_field_fImage();
    fn test_field_fLoc() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkCanvas_BackImage>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fLoc) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(SkCanvas_BackImage),
                "::",
                stringify!(fLoc)
            )
        );
    }
    test_field_fLoc();
}
#[repr(C)]
#[derive(Debug)]
pub struct SkCanvas_MCRec {
    pub fLayer: u64,
    pub fDevice: *mut SkBaseDevice,
    pub fBackImage: u64,
    pub fMatrix: SkM44,
    pub fDeferredSaveCount: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_SkCanvas_MCRec() {
    assert_eq!(
        ::core::mem::size_of::<SkCanvas_MCRec>(),
        96usize,
        concat!("Size of: ", stringify!(SkCanvas_MCRec))
    );
    assert_eq!(
        ::core::mem::align_of::<SkCanvas_MCRec>(),
        8usize,
        concat!("Alignment of ", stringify!(SkCanvas_MCRec))
    );
    fn test_field_fLayer() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkCanvas_MCRec>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fLayer) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SkCanvas_MCRec),
                "::",
                stringify!(fLayer)
            )
        );
    }
    test_field_fLayer();
    fn test_field_fDevice() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkCanvas_MCRec>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fDevice) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(SkCanvas_MCRec),
                "::",
                stringify!(fDevice)
            )
        );
    }
    test_field_fDevice();
    fn test_field_fBackImage() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkCanvas_MCRec>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fBackImage) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(SkCanvas_MCRec),
                "::",
                stringify!(fBackImage)
            )
        );
    }
    test_field_fBackImage();
    fn test_field_fMatrix() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkCanvas_MCRec>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fMatrix) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(SkCanvas_MCRec),
                "::",
                stringify!(fMatrix)
            )
        );
    }
    test_field_fMatrix();
    fn test_field_fDeferredSaveCount() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkCanvas_MCRec>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fDeferredSaveCount) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(SkCanvas_MCRec),
                "::",
                stringify!(fDeferredSaveCount)
            )
        );
    }
    test_field_fDeferredSaveCount();
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas5MCRec8newLayerE5sk_spI12SkBaseDeviceES1_I13SkImageFilterERK7SkPaint"]
    pub fn SkCanvas_MCRec_newLayer(
        this: *mut SkCanvas_MCRec,
        layerDevice: sk_sp<SkBaseDevice>,
        filter: sk_sp<SkImageFilter>,
        restorePaint: *const SkPaint,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas5MCRec5resetEP12SkBaseDevice"]
    pub fn SkCanvas_MCRec_reset(this: *mut SkCanvas_MCRec, device: *mut SkBaseDevice);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas5MCRecC1EP12SkBaseDevice"]
    pub fn SkCanvas_MCRec_MCRec(this: *mut SkCanvas_MCRec, device: *mut SkBaseDevice);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas5MCRecC1EPKS0_"]
    pub fn SkCanvas_MCRec_MCRec1(this: *mut SkCanvas_MCRec, prev: *const SkCanvas_MCRec);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas5MCRecD1Ev"]
    pub fn SkCanvas_MCRec_MCRec_destructor(this: *mut SkCanvas_MCRec);
}
impl SkCanvas_MCRec {
    #[inline]
    pub unsafe fn newLayer(
        &mut self,
        layerDevice: sk_sp<SkBaseDevice>,
        filter: sk_sp<SkImageFilter>,
        restorePaint: *const SkPaint,
    ) {
        SkCanvas_MCRec_newLayer(self, layerDevice, filter, restorePaint)
    }
    #[inline]
    pub unsafe fn reset(&mut self, device: *mut SkBaseDevice) {
        SkCanvas_MCRec_reset(self, device)
    }
    #[inline]
    pub unsafe fn new(device: *mut SkBaseDevice) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkCanvas_MCRec_MCRec(__bindgen_tmp.as_mut_ptr(), device);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(prev: *const SkCanvas_MCRec) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkCanvas_MCRec_MCRec1(__bindgen_tmp.as_mut_ptr(), prev);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        SkCanvas_MCRec_MCRec_destructor(self)
    }
}
#[repr(u8)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkCanvas_DeviceCompatibleWithFilter {
    kUnknown = 0,
    kYes = 1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkCanvas_AutoUpdateQRBounds {
    _unused: [u8; 0],
}
pub type SkCanvas_INHERITED = SkRefCnt;
pub const SkCanvas_kMCRecSize: ::std::os::raw::c_int = 96;
pub const SkCanvas_kMCRecCount: ::std::os::raw::c_int = 32;
#[test]
fn bindgen_test_layout_SkCanvas() {
    assert_eq!(
        ::core::mem::size_of::<SkCanvas>(),
        3232usize,
        concat!("Size of: ", stringify!(SkCanvas))
    );
    assert_eq!(
        ::core::mem::align_of::<SkCanvas>(),
        8usize,
        concat!("Alignment of ", stringify!(SkCanvas))
    );
    fn test_field_fMCRecStorage() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkCanvas>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fMCRecStorage) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(SkCanvas),
                "::",
                stringify!(fMCRecStorage)
            )
        );
    }
    test_field_fMCRecStorage();
    fn test_field_fMCStack() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkCanvas>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fMCStack) as usize - ptr as usize
            },
            3080usize,
            concat!(
                "Offset of field: ",
                stringify!(SkCanvas),
                "::",
                stringify!(fMCStack)
            )
        );
    }
    test_field_fMCStack();
    fn test_field_fMCRec() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkCanvas>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fMCRec) as usize - ptr as usize
            },
            3136usize,
            concat!(
                "Offset of field: ",
                stringify!(SkCanvas),
                "::",
                stringify!(fMCRec)
            )
        );
    }
    test_field_fMCRec();
    fn test_field_fBaseDevice() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkCanvas>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fBaseDevice) as usize - ptr as usize
            },
            3144usize,
            concat!(
                "Offset of field: ",
                stringify!(SkCanvas),
                "::",
                stringify!(fBaseDevice)
            )
        );
    }
    test_field_fBaseDevice();
    fn test_field_fProps() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkCanvas>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fProps) as usize - ptr as usize
            },
            3152usize,
            concat!(
                "Offset of field: ",
                stringify!(SkCanvas),
                "::",
                stringify!(fProps)
            )
        );
    }
    test_field_fProps();
    fn test_field_fSaveCount() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkCanvas>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fSaveCount) as usize - ptr as usize
            },
            3160usize,
            concat!(
                "Offset of field: ",
                stringify!(SkCanvas),
                "::",
                stringify!(fSaveCount)
            )
        );
    }
    test_field_fSaveCount();
    fn test_field_fAllocator() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkCanvas>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fAllocator) as usize - ptr as usize
            },
            3168usize,
            concat!(
                "Offset of field: ",
                stringify!(SkCanvas),
                "::",
                stringify!(fAllocator)
            )
        );
    }
    test_field_fAllocator();
    fn test_field_fSurfaceBase() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkCanvas>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fSurfaceBase) as usize - ptr as usize
            },
            3176usize,
            concat!(
                "Offset of field: ",
                stringify!(SkCanvas),
                "::",
                stringify!(fSurfaceBase)
            )
        );
    }
    test_field_fSurfaceBase();
    fn test_field_fClipRestrictionRect() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkCanvas>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fClipRestrictionRect) as usize - ptr as usize
            },
            3184usize,
            concat!(
                "Offset of field: ",
                stringify!(SkCanvas),
                "::",
                stringify!(fClipRestrictionRect)
            )
        );
    }
    test_field_fClipRestrictionRect();
    fn test_field_fClipRestrictionSaveCount() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkCanvas>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fClipRestrictionSaveCount) as usize - ptr as usize
            },
            3200usize,
            concat!(
                "Offset of field: ",
                stringify!(SkCanvas),
                "::",
                stringify!(fClipRestrictionSaveCount)
            )
        );
    }
    test_field_fClipRestrictionSaveCount();
    fn test_field_fQuickRejectBounds() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkCanvas>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fQuickRejectBounds) as usize - ptr as usize
            },
            3204usize,
            concat!(
                "Offset of field: ",
                stringify!(SkCanvas),
                "::",
                stringify!(fQuickRejectBounds)
            )
        );
    }
    test_field_fQuickRejectBounds();
    fn test_field_fScratchGlyphRunBuilder() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkCanvas>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fScratchGlyphRunBuilder) as usize - ptr as usize
            },
            3224usize,
            concat!(
                "Offset of field: ",
                stringify!(SkCanvas),
                "::",
                stringify!(fScratchGlyphRunBuilder)
            )
        );
    }
    test_field_fScratchGlyphRunBuilder();
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas16MakeRasterDirectERK11SkImageInfoPvmPK14SkSurfaceProps"]
    pub fn SkCanvas_MakeRasterDirect(
        info: *const SkImageInfo,
        pixels: *mut ::core::ffi::c_void,
        rowBytes: usize,
        props: *const SkSurfaceProps,
    ) -> u64;
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkCanvas9imageInfoEv"]
    pub fn SkCanvas_imageInfo(this: *const SkCanvas) -> SkImageInfo;
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkCanvas8getPropsEP14SkSurfaceProps"]
    pub fn SkCanvas_getProps(this: *const SkCanvas, props: *mut SkSurfaceProps) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkCanvas12getBasePropsEv"]
    pub fn SkCanvas_getBaseProps(this: *const SkCanvas) -> SkSurfaceProps;
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkCanvas11getTopPropsEv"]
    pub fn SkCanvas_getTopProps(this: *const SkCanvas) -> SkSurfaceProps;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas5flushEv"]
    pub fn SkCanvas_flush(this: *mut SkCanvas);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas11makeSurfaceERK11SkImageInfoPK14SkSurfaceProps"]
    pub fn SkCanvas_makeSurface(
        this: *mut SkCanvas,
        info: *const SkImageInfo,
        props: *const SkSurfaceProps,
    ) -> sk_sp<SkSurface>;
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkCanvas10getSurfaceEv"]
    pub fn SkCanvas_getSurface(this: *const SkCanvas) -> *mut SkSurface;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas20accessTopLayerPixelsEP11SkImageInfoPmP8SkIPoint"]
    pub fn SkCanvas_accessTopLayerPixels(
        this: *mut SkCanvas,
        info: *mut SkImageInfo,
        rowBytes: *mut usize,
        origin: *mut SkIPoint,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkCanvas21accessTopRasterHandleEv"]
    pub fn SkCanvas_accessTopRasterHandle(this: *const SkCanvas) -> SkRasterHandleAllocator_Handle;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas10peekPixelsEP8SkPixmap"]
    pub fn SkCanvas_peekPixels(this: *mut SkCanvas, pixmap: *mut SkPixmap) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas10readPixelsERK11SkImageInfoPvmii"]
    pub fn SkCanvas_readPixels(
        this: *mut SkCanvas,
        dstInfo: *const SkImageInfo,
        dstPixels: *mut ::core::ffi::c_void,
        dstRowBytes: usize,
        srcX: ::std::os::raw::c_int,
        srcY: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas10readPixelsERK8SkPixmapii"]
    pub fn SkCanvas_readPixels1(
        this: *mut SkCanvas,
        pixmap: *const SkPixmap,
        srcX: ::std::os::raw::c_int,
        srcY: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas10readPixelsERK8SkBitmapii"]
    pub fn SkCanvas_readPixels2(
        this: *mut SkCanvas,
        bitmap: *const SkBitmap,
        srcX: ::std::os::raw::c_int,
        srcY: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas11writePixelsERK11SkImageInfoPKvmii"]
    pub fn SkCanvas_writePixels(
        this: *mut SkCanvas,
        info: *const SkImageInfo,
        pixels: *const ::core::ffi::c_void,
        rowBytes: usize,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas11writePixelsERK8SkBitmapii"]
    pub fn SkCanvas_writePixels1(
        this: *mut SkCanvas,
        bitmap: *const SkBitmap,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas4saveEv"]
    pub fn SkCanvas_save(this: *mut SkCanvas) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas9saveLayerEPK6SkRectPK7SkPaint"]
    pub fn SkCanvas_saveLayer(
        this: *mut SkCanvas,
        bounds: *const SkRect,
        paint: *const SkPaint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas14saveLayerAlphaEPK6SkRectj"]
    pub fn SkCanvas_saveLayerAlpha(
        this: *mut SkCanvas,
        bounds: *const SkRect,
        alpha: U8CPU,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas9saveLayerERKNS_12SaveLayerRecE"]
    pub fn SkCanvas_saveLayer1(
        this: *mut SkCanvas,
        layerRec: *const SkCanvas_SaveLayerRec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas7restoreEv"]
    pub fn SkCanvas_restore(this: *mut SkCanvas);
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkCanvas12getSaveCountEv"]
    pub fn SkCanvas_getSaveCount(this: *const SkCanvas) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas14restoreToCountEi"]
    pub fn SkCanvas_restoreToCount(this: *mut SkCanvas, saveCount: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas9translateEff"]
    pub fn SkCanvas_translate(this: *mut SkCanvas, dx: SkScalar, dy: SkScalar);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas5scaleEff"]
    pub fn SkCanvas_scale(this: *mut SkCanvas, sx: SkScalar, sy: SkScalar);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas6rotateEf"]
    pub fn SkCanvas_rotate(this: *mut SkCanvas, degrees: SkScalar);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas6rotateEfff"]
    pub fn SkCanvas_rotate1(this: *mut SkCanvas, degrees: SkScalar, px: SkScalar, py: SkScalar);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas4skewEff"]
    pub fn SkCanvas_skew(this: *mut SkCanvas, sx: SkScalar, sy: SkScalar);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas6concatERK8SkMatrix"]
    pub fn SkCanvas_concat(this: *mut SkCanvas, matrix: *const SkMatrix);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas6concatERK5SkM44"]
    pub fn SkCanvas_concat1(this: *mut SkCanvas, arg1: *const SkM44);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas9setMatrixERK5SkM44"]
    pub fn SkCanvas_setMatrix(this: *mut SkCanvas, matrix: *const SkM44);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas9setMatrixERK8SkMatrix"]
    pub fn SkCanvas_setMatrix1(this: *mut SkCanvas, matrix: *const SkMatrix);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas11resetMatrixEv"]
    pub fn SkCanvas_resetMatrix(this: *mut SkCanvas);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas8clipRectERK6SkRect8SkClipOpb"]
    pub fn SkCanvas_clipRect(
        this: *mut SkCanvas,
        rect: *const SkRect,
        op: SkClipOp,
        doAntiAlias: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas41androidFramework_setDeviceClipRestrictionERK7SkIRect"]
    pub fn SkCanvas_androidFramework_setDeviceClipRestriction(
        this: *mut SkCanvas,
        rect: *const SkIRect,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas9clipRRectERK7SkRRect8SkClipOpb"]
    pub fn SkCanvas_clipRRect(
        this: *mut SkCanvas,
        rrect: *const SkRRect,
        op: SkClipOp,
        doAntiAlias: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas8clipPathERK6SkPath8SkClipOpb"]
    pub fn SkCanvas_clipPath(
        this: *mut SkCanvas,
        path: *const SkPath,
        op: SkClipOp,
        doAntiAlias: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas10clipShaderE5sk_spI8SkShaderE8SkClipOp"]
    pub fn SkCanvas_clipShader(this: *mut SkCanvas, arg1: sk_sp<SkShader>, arg2: SkClipOp);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas10clipRegionERK8SkRegion8SkClipOp"]
    pub fn SkCanvas_clipRegion(this: *mut SkCanvas, deviceRgn: *const SkRegion, op: SkClipOp);
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkCanvas11quickRejectERK6SkRect"]
    pub fn SkCanvas_quickReject(this: *const SkCanvas, rect: *const SkRect) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkCanvas11quickRejectERK6SkPath"]
    pub fn SkCanvas_quickReject1(this: *const SkCanvas, path: *const SkPath) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkCanvas18getLocalClipBoundsEv"]
    pub fn SkCanvas_getLocalClipBounds(this: *const SkCanvas) -> SkRect;
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkCanvas19getDeviceClipBoundsEv"]
    pub fn SkCanvas_getDeviceClipBounds(this: *const SkCanvas) -> SkIRect;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas9drawColorERK8SkRGBA4fIL11SkAlphaType3EE11SkBlendMode"]
    pub fn SkCanvas_drawColor(this: *mut SkCanvas, color: *const SkColor4f, mode: SkBlendMode);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas9drawPaintERK7SkPaint"]
    pub fn SkCanvas_drawPaint(this: *mut SkCanvas, paint: *const SkPaint);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas10drawPointsENS_9PointModeEmPK7SkPointRK7SkPaint"]
    pub fn SkCanvas_drawPoints(
        this: *mut SkCanvas,
        mode: SkCanvas_PointMode,
        count: usize,
        pts: *const SkPoint,
        paint: *const SkPaint,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas9drawPointEffRK7SkPaint"]
    pub fn SkCanvas_drawPoint(this: *mut SkCanvas, x: SkScalar, y: SkScalar, paint: *const SkPaint);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas8drawLineEffffRK7SkPaint"]
    pub fn SkCanvas_drawLine(
        this: *mut SkCanvas,
        x0: SkScalar,
        y0: SkScalar,
        x1: SkScalar,
        y1: SkScalar,
        paint: *const SkPaint,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas8drawRectERK6SkRectRK7SkPaint"]
    pub fn SkCanvas_drawRect(this: *mut SkCanvas, rect: *const SkRect, paint: *const SkPaint);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas10drawRegionERK8SkRegionRK7SkPaint"]
    pub fn SkCanvas_drawRegion(this: *mut SkCanvas, region: *const SkRegion, paint: *const SkPaint);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas8drawOvalERK6SkRectRK7SkPaint"]
    pub fn SkCanvas_drawOval(this: *mut SkCanvas, oval: *const SkRect, paint: *const SkPaint);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas9drawRRectERK7SkRRectRK7SkPaint"]
    pub fn SkCanvas_drawRRect(this: *mut SkCanvas, rrect: *const SkRRect, paint: *const SkPaint);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas10drawDRRectERK7SkRRectS2_RK7SkPaint"]
    pub fn SkCanvas_drawDRRect(
        this: *mut SkCanvas,
        outer: *const SkRRect,
        inner: *const SkRRect,
        paint: *const SkPaint,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas10drawCircleEfffRK7SkPaint"]
    pub fn SkCanvas_drawCircle(
        this: *mut SkCanvas,
        cx: SkScalar,
        cy: SkScalar,
        radius: SkScalar,
        paint: *const SkPaint,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas7drawArcERK6SkRectffbRK7SkPaint"]
    pub fn SkCanvas_drawArc(
        this: *mut SkCanvas,
        oval: *const SkRect,
        startAngle: SkScalar,
        sweepAngle: SkScalar,
        useCenter: bool,
        paint: *const SkPaint,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas13drawRoundRectERK6SkRectffRK7SkPaint"]
    pub fn SkCanvas_drawRoundRect(
        this: *mut SkCanvas,
        rect: *const SkRect,
        rx: SkScalar,
        ry: SkScalar,
        paint: *const SkPaint,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas8drawPathERK6SkPathRK7SkPaint"]
    pub fn SkCanvas_drawPath(this: *mut SkCanvas, path: *const SkPath, paint: *const SkPaint);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas9drawImageEPK7SkImageffRK17SkSamplingOptionsPK7SkPaint"]
    pub fn SkCanvas_drawImage(
        this: *mut SkCanvas,
        arg1: *const SkImage,
        x: SkScalar,
        y: SkScalar,
        arg2: *const SkSamplingOptions,
        arg3: *const SkPaint,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas13drawImageRectEPK7SkImageRK6SkRectS5_RK17SkSamplingOptionsPK7SkPaintNS_17SrcRectConstraintE"]
    pub fn SkCanvas_drawImageRect(
        this: *mut SkCanvas,
        arg1: *const SkImage,
        src: *const SkRect,
        dst: *const SkRect,
        arg2: *const SkSamplingOptions,
        arg3: *const SkPaint,
        arg4: SkCanvas_SrcRectConstraint,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas13drawImageRectEPK7SkImageRK6SkRectRK17SkSamplingOptionsPK7SkPaint"]
    pub fn SkCanvas_drawImageRect1(
        this: *mut SkCanvas,
        arg1: *const SkImage,
        dst: *const SkRect,
        arg2: *const SkSamplingOptions,
        arg3: *const SkPaint,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas13drawImageNineEPK7SkImageRK7SkIRectRK6SkRect12SkFilterModePK7SkPaint"]
    pub fn SkCanvas_drawImageNine(
        this: *mut SkCanvas,
        image: *const SkImage,
        center: *const SkIRect,
        dst: *const SkRect,
        filter: SkFilterMode,
        paint: *const SkPaint,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas16drawImageLatticeEPK7SkImageRKNS_7LatticeERK6SkRect12SkFilterModePK7SkPaint"]
    pub fn SkCanvas_drawImageLattice(
        this: *mut SkCanvas,
        image: *const SkImage,
        lattice: *const SkCanvas_Lattice,
        dst: *const SkRect,
        filter: SkFilterMode,
        paint: *const SkPaint,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas27experimental_DrawEdgeAAQuadERK6SkRectPK7SkPointNS_11QuadAAFlagsERK8SkRGBA4fIL11SkAlphaType3EE11SkBlendMode"]
    pub fn SkCanvas_experimental_DrawEdgeAAQuad(
        this: *mut SkCanvas,
        rect: *const SkRect,
        clip: *const SkPoint,
        aaFlags: SkCanvas_QuadAAFlags,
        color: *const SkColor4f,
        mode: SkBlendMode,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas31experimental_DrawEdgeAAImageSetEPKNS_13ImageSetEntryEiPK7SkPointPK8SkMatrixRK17SkSamplingOptionsPK7SkPaintNS_17SrcRectConstraintE"]
    pub fn SkCanvas_experimental_DrawEdgeAAImageSet(
        this: *mut SkCanvas,
        imageSet: *const SkCanvas_ImageSetEntry,
        cnt: ::std::os::raw::c_int,
        dstClips: *const SkPoint,
        preViewMatrices: *const SkMatrix,
        arg1: *const SkSamplingOptions,
        paint: *const SkPaint,
        constraint: SkCanvas_SrcRectConstraint,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas14drawSimpleTextEPKvm14SkTextEncodingffRK6SkFontRK7SkPaint"]
    pub fn SkCanvas_drawSimpleText(
        this: *mut SkCanvas,
        text: *const ::core::ffi::c_void,
        byteLength: usize,
        encoding: SkTextEncoding,
        x: SkScalar,
        y: SkScalar,
        font: *const SkFont,
        paint: *const SkPaint,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas10drawGlyphsEiPKtPK7SkPointPKjiPKcS2_RK6SkFontRK7SkPaint"]
    pub fn SkCanvas_drawGlyphs(
        this: *mut SkCanvas,
        count: ::std::os::raw::c_int,
        glyphs: *const SkGlyphID,
        positions: *const SkPoint,
        clusters: *const u32,
        textByteCount: ::std::os::raw::c_int,
        utf8text: *const ::std::os::raw::c_char,
        origin: SkPoint,
        font: *const SkFont,
        paint: *const SkPaint,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas10drawGlyphsEiPKtPK7SkPointS2_RK6SkFontRK7SkPaint"]
    pub fn SkCanvas_drawGlyphs1(
        this: *mut SkCanvas,
        count: ::std::os::raw::c_int,
        glyphs: *const SkGlyphID,
        positions: *const SkPoint,
        origin: SkPoint,
        font: *const SkFont,
        paint: *const SkPaint,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas10drawGlyphsEiPKtPK9SkRSXform7SkPointRK6SkFontRK7SkPaint"]
    pub fn SkCanvas_drawGlyphs2(
        this: *mut SkCanvas,
        count: ::std::os::raw::c_int,
        glyphs: *const SkGlyphID,
        xforms: *const SkRSXform,
        origin: SkPoint,
        font: *const SkFont,
        paint: *const SkPaint,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas12drawTextBlobEPK10SkTextBlobffRK7SkPaint"]
    pub fn SkCanvas_drawTextBlob(
        this: *mut SkCanvas,
        blob: *const SkTextBlob,
        x: SkScalar,
        y: SkScalar,
        paint: *const SkPaint,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas11drawPictureEPK9SkPicturePK8SkMatrixPK7SkPaint"]
    pub fn SkCanvas_drawPicture(
        this: *mut SkCanvas,
        picture: *const SkPicture,
        matrix: *const SkMatrix,
        paint: *const SkPaint,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas12drawVerticesEPK10SkVertices11SkBlendModeRK7SkPaint"]
    pub fn SkCanvas_drawVertices(
        this: *mut SkCanvas,
        vertices: *const SkVertices,
        mode: SkBlendMode,
        paint: *const SkPaint,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas12drawVerticesERK5sk_spI10SkVerticesE11SkBlendModeRK7SkPaint"]
    pub fn SkCanvas_drawVertices1(
        this: *mut SkCanvas,
        vertices: *const sk_sp<SkVertices>,
        mode: SkBlendMode,
        paint: *const SkPaint,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas8drawMeshERK6SkMesh5sk_spI9SkBlenderERK7SkPaint"]
    pub fn SkCanvas_drawMesh(
        this: *mut SkCanvas,
        mesh: *const SkMesh,
        blender: sk_sp<SkBlender>,
        paint: *const SkPaint,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas9drawPatchEPK7SkPointPKjS2_11SkBlendModeRK7SkPaint"]
    pub fn SkCanvas_drawPatch(
        this: *mut SkCanvas,
        cubics: *const SkPoint,
        colors: *const SkColor,
        texCoords: *const SkPoint,
        mode: SkBlendMode,
        paint: *const SkPaint,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas9drawAtlasEPK7SkImagePK9SkRSXformPK6SkRectPKji11SkBlendModeRK17SkSamplingOptionsS8_PK7SkPaint"]
    pub fn SkCanvas_drawAtlas(
        this: *mut SkCanvas,
        atlas: *const SkImage,
        xform: *const SkRSXform,
        tex: *const SkRect,
        colors: *const SkColor,
        count: ::std::os::raw::c_int,
        mode: SkBlendMode,
        sampling: *const SkSamplingOptions,
        cullRect: *const SkRect,
        paint: *const SkPaint,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas12drawDrawableEP10SkDrawablePK8SkMatrix"]
    pub fn SkCanvas_drawDrawable(
        this: *mut SkCanvas,
        drawable: *mut SkDrawable,
        matrix: *const SkMatrix,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas12drawDrawableEP10SkDrawableff"]
    pub fn SkCanvas_drawDrawable1(
        this: *mut SkCanvas,
        drawable: *mut SkDrawable,
        x: SkScalar,
        y: SkScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas14drawAnnotationERK6SkRectPKcP6SkData"]
    pub fn SkCanvas_drawAnnotation(
        this: *mut SkCanvas,
        rect: *const SkRect,
        key: *const ::std::os::raw::c_char,
        value: *mut SkData,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkCanvas16getLocalToDeviceEv"]
    pub fn SkCanvas_getLocalToDevice(this: *const SkCanvas) -> SkM44;
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkCanvas14getTotalMatrixEv"]
    pub fn SkCanvas_getTotalMatrix(this: *const SkCanvas) -> SkMatrix;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas29temporary_internal_getRgnClipEP8SkRegion"]
    pub fn SkCanvas_temporary_internal_getRgnClip(this: *mut SkCanvas, region: *mut SkRegion);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas23private_draw_shadow_recERK6SkPathRK15SkDrawShadowRec"]
    pub fn SkCanvas_private_draw_shadow_rec(
        this: *mut SkCanvas,
        arg1: *const SkPath,
        arg2: *const SkDrawShadowRec,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvasC1Ev"]
    pub fn SkCanvas_SkCanvas(this: *mut SkCanvas);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvasC1EiiPK14SkSurfaceProps"]
    pub fn SkCanvas_SkCanvas1(
        this: *mut SkCanvas,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        props: *const SkSurfaceProps,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvasC1E5sk_spI12SkBaseDeviceE"]
    pub fn SkCanvas_SkCanvas2(this: *mut SkCanvas, device: sk_sp<SkBaseDevice>);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvasC1ERK8SkBitmap"]
    pub fn SkCanvas_SkCanvas3(this: *mut SkCanvas, bitmap: *const SkBitmap);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvasC1ERK8SkBitmapRK14SkSurfaceProps"]
    pub fn SkCanvas_SkCanvas4(
        this: *mut SkCanvas,
        bitmap: *const SkBitmap,
        props: *const SkSurfaceProps,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvasC1ERK7SkIRect"]
    pub fn SkCanvas_SkCanvas5(this: *mut SkCanvas, bounds: *const SkIRect);
}
impl SkCanvas {
    #[inline]
    pub unsafe fn MakeRasterDirect(
        info: *const SkImageInfo,
        pixels: *mut ::core::ffi::c_void,
        rowBytes: usize,
        props: *const SkSurfaceProps,
    ) -> u64 {
        SkCanvas_MakeRasterDirect(info, pixels, rowBytes, props)
    }
    #[inline]
    pub unsafe fn imageInfo(&self) -> SkImageInfo {
        SkCanvas_imageInfo(self)
    }
    #[inline]
    pub unsafe fn getProps(&self, props: *mut SkSurfaceProps) -> bool {
        SkCanvas_getProps(self, props)
    }
    #[inline]
    pub unsafe fn getBaseProps(&self) -> SkSurfaceProps {
        SkCanvas_getBaseProps(self)
    }
    #[inline]
    pub unsafe fn getTopProps(&self) -> SkSurfaceProps {
        SkCanvas_getTopProps(self)
    }
    #[inline]
    pub unsafe fn flush(&mut self) {
        SkCanvas_flush(self)
    }
    #[inline]
    pub unsafe fn makeSurface(
        &mut self,
        info: *const SkImageInfo,
        props: *const SkSurfaceProps,
    ) -> sk_sp<SkSurface> {
        SkCanvas_makeSurface(self, info, props)
    }
    #[inline]
    pub unsafe fn getSurface(&self) -> *mut SkSurface {
        SkCanvas_getSurface(self)
    }
    #[inline]
    pub unsafe fn accessTopLayerPixels(
        &mut self,
        info: *mut SkImageInfo,
        rowBytes: *mut usize,
        origin: *mut SkIPoint,
    ) -> *mut ::core::ffi::c_void {
        SkCanvas_accessTopLayerPixels(self, info, rowBytes, origin)
    }
    #[inline]
    pub unsafe fn accessTopRasterHandle(&self) -> SkRasterHandleAllocator_Handle {
        SkCanvas_accessTopRasterHandle(self)
    }
    #[inline]
    pub unsafe fn peekPixels(&mut self, pixmap: *mut SkPixmap) -> bool {
        SkCanvas_peekPixels(self, pixmap)
    }
    #[inline]
    pub unsafe fn readPixels(
        &mut self,
        dstInfo: *const SkImageInfo,
        dstPixels: *mut ::core::ffi::c_void,
        dstRowBytes: usize,
        srcX: ::std::os::raw::c_int,
        srcY: ::std::os::raw::c_int,
    ) -> bool {
        SkCanvas_readPixels(self, dstInfo, dstPixels, dstRowBytes, srcX, srcY)
    }
    #[inline]
    pub unsafe fn readPixels1(
        &mut self,
        pixmap: *const SkPixmap,
        srcX: ::std::os::raw::c_int,
        srcY: ::std::os::raw::c_int,
    ) -> bool {
        SkCanvas_readPixels1(self, pixmap, srcX, srcY)
    }
    #[inline]
    pub unsafe fn readPixels2(
        &mut self,
        bitmap: *const SkBitmap,
        srcX: ::std::os::raw::c_int,
        srcY: ::std::os::raw::c_int,
    ) -> bool {
        SkCanvas_readPixels2(self, bitmap, srcX, srcY)
    }
    #[inline]
    pub unsafe fn writePixels(
        &mut self,
        info: *const SkImageInfo,
        pixels: *const ::core::ffi::c_void,
        rowBytes: usize,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
    ) -> bool {
        SkCanvas_writePixels(self, info, pixels, rowBytes, x, y)
    }
    #[inline]
    pub unsafe fn writePixels1(
        &mut self,
        bitmap: *const SkBitmap,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
    ) -> bool {
        SkCanvas_writePixels1(self, bitmap, x, y)
    }
    #[inline]
    pub unsafe fn save(&mut self) -> ::std::os::raw::c_int {
        SkCanvas_save(self)
    }
    #[inline]
    pub unsafe fn saveLayer(
        &mut self,
        bounds: *const SkRect,
        paint: *const SkPaint,
    ) -> ::std::os::raw::c_int {
        SkCanvas_saveLayer(self, bounds, paint)
    }
    #[inline]
    pub unsafe fn saveLayerAlpha(
        &mut self,
        bounds: *const SkRect,
        alpha: U8CPU,
    ) -> ::std::os::raw::c_int {
        SkCanvas_saveLayerAlpha(self, bounds, alpha)
    }
    #[inline]
    pub unsafe fn saveLayer1(
        &mut self,
        layerRec: *const SkCanvas_SaveLayerRec,
    ) -> ::std::os::raw::c_int {
        SkCanvas_saveLayer1(self, layerRec)
    }
    #[inline]
    pub unsafe fn restore(&mut self) {
        SkCanvas_restore(self)
    }
    #[inline]
    pub unsafe fn getSaveCount(&self) -> ::std::os::raw::c_int {
        SkCanvas_getSaveCount(self)
    }
    #[inline]
    pub unsafe fn restoreToCount(&mut self, saveCount: ::std::os::raw::c_int) {
        SkCanvas_restoreToCount(self, saveCount)
    }
    #[inline]
    pub unsafe fn translate(&mut self, dx: SkScalar, dy: SkScalar) {
        SkCanvas_translate(self, dx, dy)
    }
    #[inline]
    pub unsafe fn scale(&mut self, sx: SkScalar, sy: SkScalar) {
        SkCanvas_scale(self, sx, sy)
    }
    #[inline]
    pub unsafe fn rotate(&mut self, degrees: SkScalar) {
        SkCanvas_rotate(self, degrees)
    }
    #[inline]
    pub unsafe fn rotate1(&mut self, degrees: SkScalar, px: SkScalar, py: SkScalar) {
        SkCanvas_rotate1(self, degrees, px, py)
    }
    #[inline]
    pub unsafe fn skew(&mut self, sx: SkScalar, sy: SkScalar) {
        SkCanvas_skew(self, sx, sy)
    }
    #[inline]
    pub unsafe fn concat(&mut self, matrix: *const SkMatrix) {
        SkCanvas_concat(self, matrix)
    }
    #[inline]
    pub unsafe fn concat1(&mut self, arg1: *const SkM44) {
        SkCanvas_concat1(self, arg1)
    }
    #[inline]
    pub unsafe fn setMatrix(&mut self, matrix: *const SkM44) {
        SkCanvas_setMatrix(self, matrix)
    }
    #[inline]
    pub unsafe fn setMatrix1(&mut self, matrix: *const SkMatrix) {
        SkCanvas_setMatrix1(self, matrix)
    }
    #[inline]
    pub unsafe fn resetMatrix(&mut self) {
        SkCanvas_resetMatrix(self)
    }
    #[inline]
    pub unsafe fn clipRect(&mut self, rect: *const SkRect, op: SkClipOp, doAntiAlias: bool) {
        SkCanvas_clipRect(self, rect, op, doAntiAlias)
    }
    #[inline]
    pub unsafe fn androidFramework_setDeviceClipRestriction(&mut self, rect: *const SkIRect) {
        SkCanvas_androidFramework_setDeviceClipRestriction(self, rect)
    }
    #[inline]
    pub unsafe fn clipRRect(&mut self, rrect: *const SkRRect, op: SkClipOp, doAntiAlias: bool) {
        SkCanvas_clipRRect(self, rrect, op, doAntiAlias)
    }
    #[inline]
    pub unsafe fn clipPath(&mut self, path: *const SkPath, op: SkClipOp, doAntiAlias: bool) {
        SkCanvas_clipPath(self, path, op, doAntiAlias)
    }
    #[inline]
    pub unsafe fn clipShader(&mut self, arg1: sk_sp<SkShader>, arg2: SkClipOp) {
        SkCanvas_clipShader(self, arg1, arg2)
    }
    #[inline]
    pub unsafe fn clipRegion(&mut self, deviceRgn: *const SkRegion, op: SkClipOp) {
        SkCanvas_clipRegion(self, deviceRgn, op)
    }
    #[inline]
    pub unsafe fn quickReject(&self, rect: *const SkRect) -> bool {
        SkCanvas_quickReject(self, rect)
    }
    #[inline]
    pub unsafe fn quickReject1(&self, path: *const SkPath) -> bool {
        SkCanvas_quickReject1(self, path)
    }
    #[inline]
    pub unsafe fn getLocalClipBounds(&self) -> SkRect {
        SkCanvas_getLocalClipBounds(self)
    }
    #[inline]
    pub unsafe fn getDeviceClipBounds(&self) -> SkIRect {
        SkCanvas_getDeviceClipBounds(self)
    }
    #[inline]
    pub unsafe fn drawColor(&mut self, color: *const SkColor4f, mode: SkBlendMode) {
        SkCanvas_drawColor(self, color, mode)
    }
    #[inline]
    pub unsafe fn drawPaint(&mut self, paint: *const SkPaint) {
        SkCanvas_drawPaint(self, paint)
    }
    #[inline]
    pub unsafe fn drawPoints(
        &mut self,
        mode: SkCanvas_PointMode,
        count: usize,
        pts: *const SkPoint,
        paint: *const SkPaint,
    ) {
        SkCanvas_drawPoints(self, mode, count, pts, paint)
    }
    #[inline]
    pub unsafe fn drawPoint(&mut self, x: SkScalar, y: SkScalar, paint: *const SkPaint) {
        SkCanvas_drawPoint(self, x, y, paint)
    }
    #[inline]
    pub unsafe fn drawLine(
        &mut self,
        x0: SkScalar,
        y0: SkScalar,
        x1: SkScalar,
        y1: SkScalar,
        paint: *const SkPaint,
    ) {
        SkCanvas_drawLine(self, x0, y0, x1, y1, paint)
    }
    #[inline]
    pub unsafe fn drawRect(&mut self, rect: *const SkRect, paint: *const SkPaint) {
        SkCanvas_drawRect(self, rect, paint)
    }
    #[inline]
    pub unsafe fn drawRegion(&mut self, region: *const SkRegion, paint: *const SkPaint) {
        SkCanvas_drawRegion(self, region, paint)
    }
    #[inline]
    pub unsafe fn drawOval(&mut self, oval: *const SkRect, paint: *const SkPaint) {
        SkCanvas_drawOval(self, oval, paint)
    }
    #[inline]
    pub unsafe fn drawRRect(&mut self, rrect: *const SkRRect, paint: *const SkPaint) {
        SkCanvas_drawRRect(self, rrect, paint)
    }
    #[inline]
    pub unsafe fn drawDRRect(
        &mut self,
        outer: *const SkRRect,
        inner: *const SkRRect,
        paint: *const SkPaint,
    ) {
        SkCanvas_drawDRRect(self, outer, inner, paint)
    }
    #[inline]
    pub unsafe fn drawCircle(
        &mut self,
        cx: SkScalar,
        cy: SkScalar,
        radius: SkScalar,
        paint: *const SkPaint,
    ) {
        SkCanvas_drawCircle(self, cx, cy, radius, paint)
    }
    #[inline]
    pub unsafe fn drawArc(
        &mut self,
        oval: *const SkRect,
        startAngle: SkScalar,
        sweepAngle: SkScalar,
        useCenter: bool,
        paint: *const SkPaint,
    ) {
        SkCanvas_drawArc(self, oval, startAngle, sweepAngle, useCenter, paint)
    }
    #[inline]
    pub unsafe fn drawRoundRect(
        &mut self,
        rect: *const SkRect,
        rx: SkScalar,
        ry: SkScalar,
        paint: *const SkPaint,
    ) {
        SkCanvas_drawRoundRect(self, rect, rx, ry, paint)
    }
    #[inline]
    pub unsafe fn drawPath(&mut self, path: *const SkPath, paint: *const SkPaint) {
        SkCanvas_drawPath(self, path, paint)
    }
    #[inline]
    pub unsafe fn drawImage(
        &mut self,
        arg1: *const SkImage,
        x: SkScalar,
        y: SkScalar,
        arg2: *const SkSamplingOptions,
        arg3: *const SkPaint,
    ) {
        SkCanvas_drawImage(self, arg1, x, y, arg2, arg3)
    }
    #[inline]
    pub unsafe fn drawImageRect(
        &mut self,
        arg1: *const SkImage,
        src: *const SkRect,
        dst: *const SkRect,
        arg2: *const SkSamplingOptions,
        arg3: *const SkPaint,
        arg4: SkCanvas_SrcRectConstraint,
    ) {
        SkCanvas_drawImageRect(self, arg1, src, dst, arg2, arg3, arg4)
    }
    #[inline]
    pub unsafe fn drawImageRect1(
        &mut self,
        arg1: *const SkImage,
        dst: *const SkRect,
        arg2: *const SkSamplingOptions,
        arg3: *const SkPaint,
    ) {
        SkCanvas_drawImageRect1(self, arg1, dst, arg2, arg3)
    }
    #[inline]
    pub unsafe fn drawImageNine(
        &mut self,
        image: *const SkImage,
        center: *const SkIRect,
        dst: *const SkRect,
        filter: SkFilterMode,
        paint: *const SkPaint,
    ) {
        SkCanvas_drawImageNine(self, image, center, dst, filter, paint)
    }
    #[inline]
    pub unsafe fn drawImageLattice(
        &mut self,
        image: *const SkImage,
        lattice: *const SkCanvas_Lattice,
        dst: *const SkRect,
        filter: SkFilterMode,
        paint: *const SkPaint,
    ) {
        SkCanvas_drawImageLattice(self, image, lattice, dst, filter, paint)
    }
    #[inline]
    pub unsafe fn experimental_DrawEdgeAAQuad(
        &mut self,
        rect: *const SkRect,
        clip: *const SkPoint,
        aaFlags: SkCanvas_QuadAAFlags,
        color: *const SkColor4f,
        mode: SkBlendMode,
    ) {
        SkCanvas_experimental_DrawEdgeAAQuad(self, rect, clip, aaFlags, color, mode)
    }
    #[inline]
    pub unsafe fn experimental_DrawEdgeAAImageSet(
        &mut self,
        imageSet: *const SkCanvas_ImageSetEntry,
        cnt: ::std::os::raw::c_int,
        dstClips: *const SkPoint,
        preViewMatrices: *const SkMatrix,
        arg1: *const SkSamplingOptions,
        paint: *const SkPaint,
        constraint: SkCanvas_SrcRectConstraint,
    ) {
        SkCanvas_experimental_DrawEdgeAAImageSet(
            self,
            imageSet,
            cnt,
            dstClips,
            preViewMatrices,
            arg1,
            paint,
            constraint,
        )
    }
    #[inline]
    pub unsafe fn drawSimpleText(
        &mut self,
        text: *const ::core::ffi::c_void,
        byteLength: usize,
        encoding: SkTextEncoding,
        x: SkScalar,
        y: SkScalar,
        font: *const SkFont,
        paint: *const SkPaint,
    ) {
        SkCanvas_drawSimpleText(self, text, byteLength, encoding, x, y, font, paint)
    }
    #[inline]
    pub unsafe fn drawGlyphs(
        &mut self,
        count: ::std::os::raw::c_int,
        glyphs: *const SkGlyphID,
        positions: *const SkPoint,
        clusters: *const u32,
        textByteCount: ::std::os::raw::c_int,
        utf8text: *const ::std::os::raw::c_char,
        origin: SkPoint,
        font: *const SkFont,
        paint: *const SkPaint,
    ) {
        SkCanvas_drawGlyphs(
            self,
            count,
            glyphs,
            positions,
            clusters,
            textByteCount,
            utf8text,
            origin,
            font,
            paint,
        )
    }
    #[inline]
    pub unsafe fn drawGlyphs1(
        &mut self,
        count: ::std::os::raw::c_int,
        glyphs: *const SkGlyphID,
        positions: *const SkPoint,
        origin: SkPoint,
        font: *const SkFont,
        paint: *const SkPaint,
    ) {
        SkCanvas_drawGlyphs1(self, count, glyphs, positions, origin, font, paint)
    }
    #[inline]
    pub unsafe fn drawGlyphs2(
        &mut self,
        count: ::std::os::raw::c_int,
        glyphs: *const SkGlyphID,
        xforms: *const SkRSXform,
        origin: SkPoint,
        font: *const SkFont,
        paint: *const SkPaint,
    ) {
        SkCanvas_drawGlyphs2(self, count, glyphs, xforms, origin, font, paint)
    }
    #[inline]
    pub unsafe fn drawTextBlob(
        &mut self,
        blob: *const SkTextBlob,
        x: SkScalar,
        y: SkScalar,
        paint: *const SkPaint,
    ) {
        SkCanvas_drawTextBlob(self, blob, x, y, paint)
    }
    #[inline]
    pub unsafe fn drawPicture(
        &mut self,
        picture: *const SkPicture,
        matrix: *const SkMatrix,
        paint: *const SkPaint,
    ) {
        SkCanvas_drawPicture(self, picture, matrix, paint)
    }
    #[inline]
    pub unsafe fn drawVertices(
        &mut self,
        vertices: *const SkVertices,
        mode: SkBlendMode,
        paint: *const SkPaint,
    ) {
        SkCanvas_drawVertices(self, vertices, mode, paint)
    }
    #[inline]
    pub unsafe fn drawVertices1(
        &mut self,
        vertices: *const sk_sp<SkVertices>,
        mode: SkBlendMode,
        paint: *const SkPaint,
    ) {
        SkCanvas_drawVertices1(self, vertices, mode, paint)
    }
    #[inline]
    pub unsafe fn drawMesh(
        &mut self,
        mesh: *const SkMesh,
        blender: sk_sp<SkBlender>,
        paint: *const SkPaint,
    ) {
        SkCanvas_drawMesh(self, mesh, blender, paint)
    }
    #[inline]
    pub unsafe fn drawPatch(
        &mut self,
        cubics: *const SkPoint,
        colors: *const SkColor,
        texCoords: *const SkPoint,
        mode: SkBlendMode,
        paint: *const SkPaint,
    ) {
        SkCanvas_drawPatch(self, cubics, colors, texCoords, mode, paint)
    }
    #[inline]
    pub unsafe fn drawAtlas(
        &mut self,
        atlas: *const SkImage,
        xform: *const SkRSXform,
        tex: *const SkRect,
        colors: *const SkColor,
        count: ::std::os::raw::c_int,
        mode: SkBlendMode,
        sampling: *const SkSamplingOptions,
        cullRect: *const SkRect,
        paint: *const SkPaint,
    ) {
        SkCanvas_drawAtlas(
            self, atlas, xform, tex, colors, count, mode, sampling, cullRect, paint,
        )
    }
    #[inline]
    pub unsafe fn drawDrawable(&mut self, drawable: *mut SkDrawable, matrix: *const SkMatrix) {
        SkCanvas_drawDrawable(self, drawable, matrix)
    }
    #[inline]
    pub unsafe fn drawDrawable1(&mut self, drawable: *mut SkDrawable, x: SkScalar, y: SkScalar) {
        SkCanvas_drawDrawable1(self, drawable, x, y)
    }
    #[inline]
    pub unsafe fn drawAnnotation(
        &mut self,
        rect: *const SkRect,
        key: *const ::std::os::raw::c_char,
        value: *mut SkData,
    ) {
        SkCanvas_drawAnnotation(self, rect, key, value)
    }
    #[inline]
    pub unsafe fn getLocalToDevice(&self) -> SkM44 {
        SkCanvas_getLocalToDevice(self)
    }
    #[inline]
    pub unsafe fn getTotalMatrix(&self) -> SkMatrix {
        SkCanvas_getTotalMatrix(self)
    }
    #[inline]
    pub unsafe fn temporary_internal_getRgnClip(&mut self, region: *mut SkRegion) {
        SkCanvas_temporary_internal_getRgnClip(self, region)
    }
    #[inline]
    pub unsafe fn private_draw_shadow_rec(
        &mut self,
        arg1: *const SkPath,
        arg2: *const SkDrawShadowRec,
    ) {
        SkCanvas_private_draw_shadow_rec(self, arg1, arg2)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkCanvas_SkCanvas(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        props: *const SkSurfaceProps,
    ) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkCanvas_SkCanvas1(__bindgen_tmp.as_mut_ptr(), width, height, props);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(device: sk_sp<SkBaseDevice>) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkCanvas_SkCanvas2(__bindgen_tmp.as_mut_ptr(), device);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new3(bitmap: *const SkBitmap) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkCanvas_SkCanvas3(__bindgen_tmp.as_mut_ptr(), bitmap);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new4(bitmap: *const SkBitmap, props: *const SkSurfaceProps) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkCanvas_SkCanvas4(__bindgen_tmp.as_mut_ptr(), bitmap, props);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new5(bounds: *const SkIRect) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkCanvas_SkCanvas5(__bindgen_tmp.as_mut_ptr(), bounds);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvasD1Ev"]
    pub fn SkCanvas_SkCanvas_destructor(this: *mut SkCanvas);
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkCanvas16getBaseLayerSizeEv"]
    pub fn SkCanvas_getBaseLayerSize(this: *mut ::core::ffi::c_void) -> SkISize;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas16recordingContextEv"]
    pub fn SkCanvas_recordingContext(this: *mut ::core::ffi::c_void) -> *mut GrRecordingContext;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas8recorderEv"]
    pub fn SkCanvas_recorder(this: *mut ::core::ffi::c_void) -> *mut skgpu_graphite_Recorder;
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkCanvas11isClipEmptyEv"]
    pub fn SkCanvas_isClipEmpty(this: *mut ::core::ffi::c_void) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkCanvas10isClipRectEv"]
    pub fn SkCanvas_isClipRect(this: *mut ::core::ffi::c_void) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas12onNewSurfaceERK11SkImageInfoRK14SkSurfaceProps"]
    pub fn SkCanvas_onNewSurface(
        this: *mut ::core::ffi::c_void,
        info: *const SkImageInfo,
        props: *const SkSurfaceProps,
    ) -> sk_sp<SkSurface>;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas12onPeekPixelsEP8SkPixmap"]
    pub fn SkCanvas_onPeekPixels(this: *mut ::core::ffi::c_void, pixmap: *mut SkPixmap) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas22onAccessTopLayerPixelsEP8SkPixmap"]
    pub fn SkCanvas_onAccessTopLayerPixels(
        this: *mut ::core::ffi::c_void,
        pixmap: *mut SkPixmap,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkCanvas11onImageInfoEv"]
    pub fn SkCanvas_onImageInfo(this: *mut ::core::ffi::c_void) -> SkImageInfo;
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkCanvas10onGetPropsEP14SkSurfacePropsb"]
    pub fn SkCanvas_onGetProps(
        this: *mut ::core::ffi::c_void,
        props: *mut SkSurfaceProps,
        top: bool,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas7onFlushEv"]
    pub fn SkCanvas_onFlush(this: *mut ::core::ffi::c_void);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas11onDrawPaintERK7SkPaint"]
    pub fn SkCanvas_onDrawPaint(this: *mut ::core::ffi::c_void, paint: *const SkPaint);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas12onDrawBehindERK7SkPaint"]
    pub fn SkCanvas_onDrawBehind(this: *mut ::core::ffi::c_void, paint: *const SkPaint);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas10onDrawRectERK6SkRectRK7SkPaint"]
    pub fn SkCanvas_onDrawRect(
        this: *mut ::core::ffi::c_void,
        rect: *const SkRect,
        paint: *const SkPaint,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas11onDrawRRectERK7SkRRectRK7SkPaint"]
    pub fn SkCanvas_onDrawRRect(
        this: *mut ::core::ffi::c_void,
        rrect: *const SkRRect,
        paint: *const SkPaint,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas12onDrawDRRectERK7SkRRectS2_RK7SkPaint"]
    pub fn SkCanvas_onDrawDRRect(
        this: *mut ::core::ffi::c_void,
        outer: *const SkRRect,
        inner: *const SkRRect,
        paint: *const SkPaint,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas10onDrawOvalERK6SkRectRK7SkPaint"]
    pub fn SkCanvas_onDrawOval(
        this: *mut ::core::ffi::c_void,
        rect: *const SkRect,
        paint: *const SkPaint,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas9onDrawArcERK6SkRectffbRK7SkPaint"]
    pub fn SkCanvas_onDrawArc(
        this: *mut ::core::ffi::c_void,
        rect: *const SkRect,
        startAngle: SkScalar,
        sweepAngle: SkScalar,
        useCenter: bool,
        paint: *const SkPaint,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas10onDrawPathERK6SkPathRK7SkPaint"]
    pub fn SkCanvas_onDrawPath(
        this: *mut ::core::ffi::c_void,
        path: *const SkPath,
        paint: *const SkPaint,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas12onDrawRegionERK8SkRegionRK7SkPaint"]
    pub fn SkCanvas_onDrawRegion(
        this: *mut ::core::ffi::c_void,
        region: *const SkRegion,
        paint: *const SkPaint,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas14onDrawTextBlobEPK10SkTextBlobffRK7SkPaint"]
    pub fn SkCanvas_onDrawTextBlob(
        this: *mut ::core::ffi::c_void,
        blob: *const SkTextBlob,
        x: SkScalar,
        y: SkScalar,
        paint: *const SkPaint,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas18onDrawGlyphRunListERKN6sktext12GlyphRunListERK7SkPaint"]
    pub fn SkCanvas_onDrawGlyphRunList(
        this: *mut ::core::ffi::c_void,
        glyphRunList: *const sktext_GlyphRunList,
        paint: *const SkPaint,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas11onDrawPatchEPK7SkPointPKjS2_11SkBlendModeRK7SkPaint"]
    pub fn SkCanvas_onDrawPatch(
        this: *mut ::core::ffi::c_void,
        cubics: *const SkPoint,
        colors: *const SkColor,
        texCoords: *const SkPoint,
        mode: SkBlendMode,
        paint: *const SkPaint,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas12onDrawPointsENS_9PointModeEmPK7SkPointRK7SkPaint"]
    pub fn SkCanvas_onDrawPoints(
        this: *mut ::core::ffi::c_void,
        mode: SkCanvas_PointMode,
        count: usize,
        pts: *const SkPoint,
        paint: *const SkPaint,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas12onDrawImage2EPK7SkImageffRK17SkSamplingOptionsPK7SkPaint"]
    pub fn SkCanvas_onDrawImage2(
        this: *mut ::core::ffi::c_void,
        arg1: *const SkImage,
        dx: SkScalar,
        dy: SkScalar,
        arg2: *const SkSamplingOptions,
        arg3: *const SkPaint,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas16onDrawImageRect2EPK7SkImageRK6SkRectS5_RK17SkSamplingOptionsPK7SkPaintNS_17SrcRectConstraintE"]
    pub fn SkCanvas_onDrawImageRect2(
        this: *mut ::core::ffi::c_void,
        arg1: *const SkImage,
        src: *const SkRect,
        dst: *const SkRect,
        arg2: *const SkSamplingOptions,
        arg3: *const SkPaint,
        arg4: SkCanvas_SrcRectConstraint,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas19onDrawImageLattice2EPK7SkImageRKNS_7LatticeERK6SkRect12SkFilterModePK7SkPaint"]
    pub fn SkCanvas_onDrawImageLattice2(
        this: *mut ::core::ffi::c_void,
        arg1: *const SkImage,
        arg2: *const SkCanvas_Lattice,
        dst: *const SkRect,
        arg3: SkFilterMode,
        arg4: *const SkPaint,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas12onDrawAtlas2EPK7SkImagePK9SkRSXformPK6SkRectPKji11SkBlendModeRK17SkSamplingOptionsS8_PK7SkPaint"]
    pub fn SkCanvas_onDrawAtlas2(
        this: *mut ::core::ffi::c_void,
        arg1: *const SkImage,
        arg2: *const SkRSXform,
        src: *const SkRect,
        arg3: *const SkColor,
        count: ::std::os::raw::c_int,
        arg4: SkBlendMode,
        arg5: *const SkSamplingOptions,
        cull: *const SkRect,
        arg6: *const SkPaint,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas21onDrawEdgeAAImageSet2EPKNS_13ImageSetEntryEiPK7SkPointPK8SkMatrixRK17SkSamplingOptionsPK7SkPaintNS_17SrcRectConstraintE"]
    pub fn SkCanvas_onDrawEdgeAAImageSet2(
        this: *mut ::core::ffi::c_void,
        imageSet: *const SkCanvas_ImageSetEntry,
        count: ::std::os::raw::c_int,
        dstClips: *const SkPoint,
        preViewMatrices: *const SkMatrix,
        arg1: *const SkSamplingOptions,
        arg2: *const SkPaint,
        arg3: SkCanvas_SrcRectConstraint,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas20onDrawVerticesObjectEPK10SkVertices11SkBlendModeRK7SkPaint"]
    pub fn SkCanvas_onDrawVerticesObject(
        this: *mut ::core::ffi::c_void,
        vertices: *const SkVertices,
        mode: SkBlendMode,
        paint: *const SkPaint,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas10onDrawMeshERK6SkMesh5sk_spI9SkBlenderERK7SkPaint"]
    pub fn SkCanvas_onDrawMesh(
        this: *mut ::core::ffi::c_void,
        arg1: *const SkMesh,
        arg2: sk_sp<SkBlender>,
        arg3: *const SkPaint,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas16onDrawAnnotationERK6SkRectPKcP6SkData"]
    pub fn SkCanvas_onDrawAnnotation(
        this: *mut ::core::ffi::c_void,
        rect: *const SkRect,
        key: *const ::std::os::raw::c_char,
        value: *mut SkData,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas15onDrawShadowRecERK6SkPathRK15SkDrawShadowRec"]
    pub fn SkCanvas_onDrawShadowRec(
        this: *mut ::core::ffi::c_void,
        arg1: *const SkPath,
        arg2: *const SkDrawShadowRec,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas14onDrawDrawableEP10SkDrawablePK8SkMatrix"]
    pub fn SkCanvas_onDrawDrawable(
        this: *mut ::core::ffi::c_void,
        drawable: *mut SkDrawable,
        matrix: *const SkMatrix,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas13onDrawPictureEPK9SkPicturePK8SkMatrixPK7SkPaint"]
    pub fn SkCanvas_onDrawPicture(
        this: *mut ::core::ffi::c_void,
        picture: *const SkPicture,
        matrix: *const SkMatrix,
        paint: *const SkPaint,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas16onDrawEdgeAAQuadERK6SkRectPK7SkPointNS_11QuadAAFlagsERK8SkRGBA4fIL11SkAlphaType3EE11SkBlendMode"]
    pub fn SkCanvas_onDrawEdgeAAQuad(
        this: *mut ::core::ffi::c_void,
        rect: *const SkRect,
        clip: *const SkPoint,
        aaFlags: SkCanvas_QuadAAFlags,
        color: *const SkColor4f,
        mode: SkBlendMode,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas10onClipRectERK6SkRect8SkClipOpNS_13ClipEdgeStyleE"]
    pub fn SkCanvas_onClipRect(
        this: *mut ::core::ffi::c_void,
        rect: *const SkRect,
        op: SkClipOp,
        edgeStyle: SkCanvas_ClipEdgeStyle,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas11onClipRRectERK7SkRRect8SkClipOpNS_13ClipEdgeStyleE"]
    pub fn SkCanvas_onClipRRect(
        this: *mut ::core::ffi::c_void,
        rrect: *const SkRRect,
        op: SkClipOp,
        edgeStyle: SkCanvas_ClipEdgeStyle,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas10onClipPathERK6SkPath8SkClipOpNS_13ClipEdgeStyleE"]
    pub fn SkCanvas_onClipPath(
        this: *mut ::core::ffi::c_void,
        path: *const SkPath,
        op: SkClipOp,
        edgeStyle: SkCanvas_ClipEdgeStyle,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas12onClipShaderE5sk_spI8SkShaderE8SkClipOp"]
    pub fn SkCanvas_onClipShader(
        this: *mut ::core::ffi::c_void,
        arg1: sk_sp<SkShader>,
        arg2: SkClipOp,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas12onClipRegionERK8SkRegion8SkClipOp"]
    pub fn SkCanvas_onClipRegion(
        this: *mut ::core::ffi::c_void,
        deviceRgn: *const SkRegion,
        op: SkClipOp,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas11onResetClipEv"]
    pub fn SkCanvas_onResetClip(this: *mut ::core::ffi::c_void);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkCanvas9onDiscardEv"]
    pub fn SkCanvas_onDiscard(this: *mut ::core::ffi::c_void);
}
#[repr(C)]
#[derive(Debug)]
pub struct SkAutoCanvasRestore {
    pub fCanvas: *mut SkCanvas,
    pub fSaveCount: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_SkAutoCanvasRestore() {
    assert_eq!(
        ::core::mem::size_of::<SkAutoCanvasRestore>(),
        16usize,
        concat!("Size of: ", stringify!(SkAutoCanvasRestore))
    );
    assert_eq!(
        ::core::mem::align_of::<SkAutoCanvasRestore>(),
        8usize,
        concat!("Alignment of ", stringify!(SkAutoCanvasRestore))
    );
    fn test_field_fCanvas() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkAutoCanvasRestore>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fCanvas) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SkAutoCanvasRestore),
                "::",
                stringify!(fCanvas)
            )
        );
    }
    test_field_fCanvas();
    fn test_field_fSaveCount() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkAutoCanvasRestore>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fSaveCount) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(SkAutoCanvasRestore),
                "::",
                stringify!(fSaveCount)
            )
        );
    }
    test_field_fSaveCount();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkSerialProcs {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkDeserialProcs {
    _unused: [u8; 0],
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct SkFlattenable {
    pub _bindgen_opaque_blob: [u64; 2usize],
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkFlattenable_Type {
    SkColorFilter = 0,
    SkBlender = 1,
    SkDrawable = 2,
    SkDrawLooper = 3,
    SkImageFilter = 4,
    SkMaskFilter = 5,
    SkPathEffect = 6,
    SkShader = 7,
}
pub type SkFlattenable_Factory =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut SkReadBuffer) -> sk_sp<SkFlattenable>>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkFlattenable_PrivateInitializer {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_SkFlattenable_PrivateInitializer() {
    assert_eq!(
        ::core::mem::size_of::<SkFlattenable_PrivateInitializer>(),
        1usize,
        concat!("Size of: ", stringify!(SkFlattenable_PrivateInitializer))
    );
    assert_eq!(
        ::core::mem::align_of::<SkFlattenable_PrivateInitializer>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(SkFlattenable_PrivateInitializer)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN13SkFlattenable18PrivateInitializer11InitEffectsEv"]
    pub fn SkFlattenable_PrivateInitializer_InitEffects();
}
extern "C" {
    #[link_name = "\u{1}__ZN13SkFlattenable18PrivateInitializer16InitImageFiltersEv"]
    pub fn SkFlattenable_PrivateInitializer_InitImageFilters();
}
impl SkFlattenable_PrivateInitializer {
    #[inline]
    pub unsafe fn InitEffects() {
        SkFlattenable_PrivateInitializer_InitEffects()
    }
    #[inline]
    pub unsafe fn InitImageFilters() {
        SkFlattenable_PrivateInitializer_InitImageFilters()
    }
}
pub type SkFlattenable_INHERITED = SkRefCnt;
#[test]
fn bindgen_test_layout_SkFlattenable() {
    assert_eq!(
        ::core::mem::size_of::<SkFlattenable>(),
        16usize,
        concat!("Size of: ", stringify!(SkFlattenable))
    );
    assert_eq!(
        ::core::mem::align_of::<SkFlattenable>(),
        8usize,
        concat!("Alignment of ", stringify!(SkFlattenable))
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN13SkFlattenable13NameToFactoryEPKc"]
    pub fn SkFlattenable_NameToFactory(
        name: *const ::std::os::raw::c_char,
    ) -> SkFlattenable_Factory;
}
extern "C" {
    #[link_name = "\u{1}__ZN13SkFlattenable13FactoryToNameEPF5sk_spIS_ER12SkReadBufferE"]
    pub fn SkFlattenable_FactoryToName(
        arg1: SkFlattenable_Factory,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}__ZN13SkFlattenable8RegisterEPKcPF5sk_spIS_ER12SkReadBufferE"]
    pub fn SkFlattenable_Register(name: *const ::std::os::raw::c_char, arg1: SkFlattenable_Factory);
}
extern "C" {
    #[link_name = "\u{1}__ZNK13SkFlattenable9serializeEPK13SkSerialProcs"]
    pub fn SkFlattenable_serialize(
        this: *const SkFlattenable,
        arg1: *const SkSerialProcs,
    ) -> sk_sp<SkData>;
}
extern "C" {
    #[link_name = "\u{1}__ZNK13SkFlattenable9serializeEPvmPK13SkSerialProcs"]
    pub fn SkFlattenable_serialize1(
        this: *const SkFlattenable,
        memory: *mut ::core::ffi::c_void,
        memory_size: usize,
        arg1: *const SkSerialProcs,
    ) -> usize;
}
extern "C" {
    #[link_name = "\u{1}__ZN13SkFlattenable11DeserializeENS_4TypeEPKvmPK15SkDeserialProcs"]
    pub fn SkFlattenable_Deserialize(
        arg1: SkFlattenable_Type,
        data: *const ::core::ffi::c_void,
        length: usize,
        procs: *const SkDeserialProcs,
    ) -> sk_sp<SkFlattenable>;
}
impl SkFlattenable {
    #[inline]
    pub unsafe fn NameToFactory(name: *const ::std::os::raw::c_char) -> SkFlattenable_Factory {
        SkFlattenable_NameToFactory(name)
    }
    #[inline]
    pub unsafe fn FactoryToName(arg1: SkFlattenable_Factory) -> *const ::std::os::raw::c_char {
        SkFlattenable_FactoryToName(arg1)
    }
    #[inline]
    pub unsafe fn Register(name: *const ::std::os::raw::c_char, arg1: SkFlattenable_Factory) {
        SkFlattenable_Register(name, arg1)
    }
    #[inline]
    pub unsafe fn serialize(&self, arg1: *const SkSerialProcs) -> sk_sp<SkData> {
        SkFlattenable_serialize(self, arg1)
    }
    #[inline]
    pub unsafe fn serialize1(
        &self,
        memory: *mut ::core::ffi::c_void,
        memory_size: usize,
        arg1: *const SkSerialProcs,
    ) -> usize {
        SkFlattenable_serialize1(self, memory, memory_size, arg1)
    }
    #[inline]
    pub unsafe fn Deserialize(
        arg1: SkFlattenable_Type,
        data: *const ::core::ffi::c_void,
        length: usize,
        procs: *const SkDeserialProcs,
    ) -> sk_sp<SkFlattenable> {
        SkFlattenable_Deserialize(arg1, data, length, procs)
    }
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct SkColorFilter {
    pub _bindgen_opaque_blob: [u64; 2usize],
}
pub type SkColorFilter_INHERITED = SkFlattenable;
#[test]
fn bindgen_test_layout_SkColorFilter() {
    assert_eq!(
        ::core::mem::size_of::<SkColorFilter>(),
        16usize,
        concat!("Size of: ", stringify!(SkColorFilter))
    );
    assert_eq!(
        ::core::mem::align_of::<SkColorFilter>(),
        8usize,
        concat!("Alignment of ", stringify!(SkColorFilter))
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNK13SkColorFilter12asAColorModeEPjP11SkBlendMode"]
    pub fn SkColorFilter_asAColorMode(
        this: *const SkColorFilter,
        color: *mut SkColor,
        mode: *mut SkBlendMode,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK13SkColorFilter14asAColorMatrixEPf"]
    pub fn SkColorFilter_asAColorMatrix(this: *const SkColorFilter, matrix: *mut f32) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK13SkColorFilter16isAlphaUnchangedEv"]
    pub fn SkColorFilter_isAlphaUnchanged(this: *const SkColorFilter) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK13SkColorFilter11filterColorEj"]
    pub fn SkColorFilter_filterColor(this: *const SkColorFilter, arg1: SkColor) -> SkColor;
}
extern "C" {
    #[link_name = "\u{1}__ZNK13SkColorFilter13filterColor4fERK8SkRGBA4fIL11SkAlphaType3EEP12SkColorSpaceS6_"]
    pub fn SkColorFilter_filterColor4f(
        this: *const SkColorFilter,
        srcColor: *const SkColor4f,
        srcCS: *mut SkColorSpace,
        dstCS: *mut SkColorSpace,
    ) -> SkColor4f;
}
extern "C" {
    #[link_name = "\u{1}__ZNK13SkColorFilter12makeComposedE5sk_spIS_E"]
    pub fn SkColorFilter_makeComposed(
        this: *const SkColorFilter,
        inner: sk_sp<SkColorFilter>,
    ) -> sk_sp<SkColorFilter>;
}
extern "C" {
    #[link_name = "\u{1}__ZN13SkColorFilter11DeserializeEPKvmPK15SkDeserialProcs"]
    pub fn SkColorFilter_Deserialize(
        data: *const ::core::ffi::c_void,
        size: usize,
        procs: *const SkDeserialProcs,
    ) -> sk_sp<SkColorFilter>;
}
impl SkColorFilter {
    #[inline]
    pub unsafe fn asAColorMode(&self, color: *mut SkColor, mode: *mut SkBlendMode) -> bool {
        SkColorFilter_asAColorMode(self, color, mode)
    }
    #[inline]
    pub unsafe fn asAColorMatrix(&self, matrix: *mut f32) -> bool {
        SkColorFilter_asAColorMatrix(self, matrix)
    }
    #[inline]
    pub unsafe fn isAlphaUnchanged(&self) -> bool {
        SkColorFilter_isAlphaUnchanged(self)
    }
    #[inline]
    pub unsafe fn filterColor(&self, arg1: SkColor) -> SkColor {
        SkColorFilter_filterColor(self, arg1)
    }
    #[inline]
    pub unsafe fn filterColor4f(
        &self,
        srcColor: *const SkColor4f,
        srcCS: *mut SkColorSpace,
        dstCS: *mut SkColorSpace,
    ) -> SkColor4f {
        SkColorFilter_filterColor4f(self, srcColor, srcCS, dstCS)
    }
    #[inline]
    pub unsafe fn makeComposed(&self, inner: sk_sp<SkColorFilter>) -> sk_sp<SkColorFilter> {
        SkColorFilter_makeComposed(self, inner)
    }
    #[inline]
    pub unsafe fn Deserialize(
        data: *const ::core::ffi::c_void,
        size: usize,
        procs: *const SkDeserialProcs,
    ) -> sk_sp<SkColorFilter> {
        SkColorFilter_Deserialize(data, size, procs)
    }
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkPathFillType {
    Winding = 0,
    EvenOdd = 1,
    InverseWinding = 2,
    InverseEvenOdd = 3,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkPathDirection {
    CW = 0,
    CCW = 1,
}
pub const SkPathSegmentMask_kLine_SkPathSegmentMask: SkPathSegmentMask = 1;
pub const SkPathSegmentMask_kQuad_SkPathSegmentMask: SkPathSegmentMask = 2;
pub const SkPathSegmentMask_kConic_SkPathSegmentMask: SkPathSegmentMask = 4;
pub const SkPathSegmentMask_kCubic_SkPathSegmentMask: SkPathSegmentMask = 8;
pub type SkPathSegmentMask = ::std::os::raw::c_uint;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkPathVerb {
    Move = 0,
    Line = 1,
    Quad = 2,
    Conic = 3,
    Cubic = 4,
    Close = 5,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkPathRef {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct SkPath {
    pub fPathRef: sk_sp<SkPathRef>,
    pub fLastMoveToIndex: ::std::os::raw::c_int,
    pub fConvexity: u8,
    pub fFirstDirection: u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: u8,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkPath_ArcSize {
    Small = 0,
    Large = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkPath_AddPathMode {
    Append = 0,
    Extend = 1,
}
pub const SkPath_SegmentMask_kLine_SegmentMask: SkPath_SegmentMask = 1;
pub const SkPath_SegmentMask_kQuad_SegmentMask: SkPath_SegmentMask = 2;
pub const SkPath_SegmentMask_kConic_SegmentMask: SkPath_SegmentMask = 4;
pub const SkPath_SegmentMask_kCubic_SegmentMask: SkPath_SegmentMask = 8;
pub type SkPath_SegmentMask = ::std::os::raw::c_uint;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkPath_Verb {
    Move = 0,
    Line = 1,
    Quad = 2,
    Conic = 3,
    Cubic = 4,
    Close = 5,
    Done = 6,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkPath_Iter {
    pub fPts: *const SkPoint,
    pub fVerbs: *const u8,
    pub fVerbStop: *const u8,
    pub fConicWeights: *const SkScalar,
    pub fMoveTo: SkPoint,
    pub fLastPt: SkPoint,
    pub fForceClose: bool,
    pub fNeedClose: bool,
    pub fCloseLine: bool,
}
#[test]
fn bindgen_test_layout_SkPath_Iter() {
    assert_eq!(
        ::core::mem::size_of::<SkPath_Iter>(),
        56usize,
        concat!("Size of: ", stringify!(SkPath_Iter))
    );
    assert_eq!(
        ::core::mem::align_of::<SkPath_Iter>(),
        8usize,
        concat!("Alignment of ", stringify!(SkPath_Iter))
    );
    fn test_field_fPts() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkPath_Iter>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fPts) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SkPath_Iter),
                "::",
                stringify!(fPts)
            )
        );
    }
    test_field_fPts();
    fn test_field_fVerbs() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkPath_Iter>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fVerbs) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(SkPath_Iter),
                "::",
                stringify!(fVerbs)
            )
        );
    }
    test_field_fVerbs();
    fn test_field_fVerbStop() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkPath_Iter>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fVerbStop) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(SkPath_Iter),
                "::",
                stringify!(fVerbStop)
            )
        );
    }
    test_field_fVerbStop();
    fn test_field_fConicWeights() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkPath_Iter>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fConicWeights) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(SkPath_Iter),
                "::",
                stringify!(fConicWeights)
            )
        );
    }
    test_field_fConicWeights();
    fn test_field_fMoveTo() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkPath_Iter>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fMoveTo) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(SkPath_Iter),
                "::",
                stringify!(fMoveTo)
            )
        );
    }
    test_field_fMoveTo();
    fn test_field_fLastPt() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkPath_Iter>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fLastPt) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(SkPath_Iter),
                "::",
                stringify!(fLastPt)
            )
        );
    }
    test_field_fLastPt();
    fn test_field_fForceClose() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkPath_Iter>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fForceClose) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(SkPath_Iter),
                "::",
                stringify!(fForceClose)
            )
        );
    }
    test_field_fForceClose();
    fn test_field_fNeedClose() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkPath_Iter>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fNeedClose) as usize - ptr as usize
            },
            49usize,
            concat!(
                "Offset of field: ",
                stringify!(SkPath_Iter),
                "::",
                stringify!(fNeedClose)
            )
        );
    }
    test_field_fNeedClose();
    fn test_field_fCloseLine() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkPath_Iter>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fCloseLine) as usize - ptr as usize
            },
            50usize,
            concat!(
                "Offset of field: ",
                stringify!(SkPath_Iter),
                "::",
                stringify!(fCloseLine)
            )
        );
    }
    test_field_fCloseLine();
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkPath4Iter7setPathERKS_b"]
    pub fn SkPath_Iter_setPath(this: *mut SkPath_Iter, path: *const SkPath, forceClose: bool);
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkPath4Iter4nextEP7SkPoint"]
    pub fn SkPath_Iter_next(this: *mut SkPath_Iter, pts: *mut SkPoint) -> SkPath_Verb;
}
extern "C" {
    #[link_name = "\u{1}__ZNK6SkPath4Iter15isClosedContourEv"]
    pub fn SkPath_Iter_isClosedContour(this: *const SkPath_Iter) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkPath4IterC1Ev"]
    pub fn SkPath_Iter_Iter(this: *mut SkPath_Iter);
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkPath4IterC1ERKS_b"]
    pub fn SkPath_Iter_Iter1(this: *mut SkPath_Iter, path: *const SkPath, forceClose: bool);
}
impl SkPath_Iter {
    #[inline]
    pub unsafe fn setPath(&mut self, path: *const SkPath, forceClose: bool) {
        SkPath_Iter_setPath(self, path, forceClose)
    }
    #[inline]
    pub unsafe fn next(&mut self, pts: *mut SkPoint) -> SkPath_Verb {
        SkPath_Iter_next(self, pts)
    }
    #[inline]
    pub unsafe fn isClosedContour(&self) -> bool {
        SkPath_Iter_isClosedContour(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkPath_Iter_Iter(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(path: *const SkPath, forceClose: bool) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkPath_Iter_Iter1(__bindgen_tmp.as_mut_ptr(), path, forceClose);
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkPath_RangeIter {
    pub fVerb: *const u8,
    pub fPoints: *const SkPoint,
    pub fWeights: *const SkScalar,
}
#[test]
fn bindgen_test_layout_SkPath_RangeIter() {
    assert_eq!(
        ::core::mem::size_of::<SkPath_RangeIter>(),
        24usize,
        concat!("Size of: ", stringify!(SkPath_RangeIter))
    );
    assert_eq!(
        ::core::mem::align_of::<SkPath_RangeIter>(),
        8usize,
        concat!("Alignment of ", stringify!(SkPath_RangeIter))
    );
    fn test_field_fVerb() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkPath_RangeIter>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fVerb) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SkPath_RangeIter),
                "::",
                stringify!(fVerb)
            )
        );
    }
    test_field_fVerb();
    fn test_field_fPoints() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkPath_RangeIter>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fPoints) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(SkPath_RangeIter),
                "::",
                stringify!(fPoints)
            )
        );
    }
    test_field_fPoints();
    fn test_field_fWeights() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkPath_RangeIter>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fWeights) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(SkPath_RangeIter),
                "::",
                stringify!(fWeights)
            )
        );
    }
    test_field_fWeights();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkPath_RawIter {
    pub fIter: SkPath_RangeIter,
    pub fEnd: SkPath_RangeIter,
    pub fConicWeight: SkScalar,
}
#[test]
fn bindgen_test_layout_SkPath_RawIter() {
    assert_eq!(
        ::core::mem::size_of::<SkPath_RawIter>(),
        56usize,
        concat!("Size of: ", stringify!(SkPath_RawIter))
    );
    assert_eq!(
        ::core::mem::align_of::<SkPath_RawIter>(),
        8usize,
        concat!("Alignment of ", stringify!(SkPath_RawIter))
    );
    fn test_field_fIter() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkPath_RawIter>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fIter) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SkPath_RawIter),
                "::",
                stringify!(fIter)
            )
        );
    }
    test_field_fIter();
    fn test_field_fEnd() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkPath_RawIter>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fEnd) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(SkPath_RawIter),
                "::",
                stringify!(fEnd)
            )
        );
    }
    test_field_fEnd();
    fn test_field_fConicWeight() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkPath_RawIter>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fConicWeight) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(SkPath_RawIter),
                "::",
                stringify!(fConicWeight)
            )
        );
    }
    test_field_fConicWeight();
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkPath7RawIter7setPathERKS_"]
    pub fn SkPath_RawIter_setPath(this: *mut SkPath_RawIter, arg1: *const SkPath);
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkPath7RawIter4nextEP7SkPoint"]
    pub fn SkPath_RawIter_next(this: *mut SkPath_RawIter, arg1: *mut SkPoint) -> SkPath_Verb;
}
impl SkPath_RawIter {
    #[inline]
    pub unsafe fn setPath(&mut self, arg1: *const SkPath) {
        SkPath_RawIter_setPath(self, arg1)
    }
    #[inline]
    pub unsafe fn next(&mut self, arg1: *mut SkPoint) -> SkPath_Verb {
        SkPath_RawIter_next(self, arg1)
    }
}
#[test]
fn bindgen_test_layout_SkPath() {
    assert_eq!(
        ::core::mem::size_of::<SkPath>(),
        16usize,
        concat!("Size of: ", stringify!(SkPath))
    );
    assert_eq!(
        ::core::mem::align_of::<SkPath>(),
        8usize,
        concat!("Alignment of ", stringify!(SkPath))
    );
    fn test_field_fPathRef() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkPath>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fPathRef) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SkPath),
                "::",
                stringify!(fPathRef)
            )
        );
    }
    test_field_fPathRef();
    fn test_field_fLastMoveToIndex() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkPath>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fLastMoveToIndex) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(SkPath),
                "::",
                stringify!(fLastMoveToIndex)
            )
        );
    }
    test_field_fLastMoveToIndex();
    fn test_field_fConvexity() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkPath>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fConvexity) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(SkPath),
                "::",
                stringify!(fConvexity)
            )
        );
    }
    test_field_fConvexity();
    fn test_field_fFirstDirection() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkPath>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fFirstDirection) as usize - ptr as usize
            },
            13usize,
            concat!(
                "Offset of field: ",
                stringify!(SkPath),
                "::",
                stringify!(fFirstDirection)
            )
        );
    }
    test_field_fFirstDirection();
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkPath4MakeEPK7SkPointiPKhiPKfi14SkPathFillTypeb"]
    pub fn SkPath_Make(
        arg1: *const SkPoint,
        pointCount: ::std::os::raw::c_int,
        arg2: *const u8,
        verbCount: ::std::os::raw::c_int,
        arg3: *const SkScalar,
        conicWeightCount: ::std::os::raw::c_int,
        arg4: SkPathFillType,
        isVolatile: bool,
    ) -> SkPath;
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkPath4RectERK6SkRect15SkPathDirectionj"]
    pub fn SkPath_Rect(
        arg1: *const SkRect,
        arg2: SkPathDirection,
        startIndex: ::std::os::raw::c_uint,
    ) -> SkPath;
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkPath4OvalERK6SkRect15SkPathDirection"]
    pub fn SkPath_Oval(arg1: *const SkRect, arg2: SkPathDirection) -> SkPath;
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkPath4OvalERK6SkRect15SkPathDirectionj"]
    pub fn SkPath_Oval1(
        arg1: *const SkRect,
        arg2: SkPathDirection,
        startIndex: ::std::os::raw::c_uint,
    ) -> SkPath;
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkPath6CircleEfff15SkPathDirection"]
    pub fn SkPath_Circle(
        center_x: SkScalar,
        center_y: SkScalar,
        radius: SkScalar,
        dir: SkPathDirection,
    ) -> SkPath;
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkPath5RRectERK7SkRRect15SkPathDirection"]
    pub fn SkPath_RRect(arg1: *const SkRRect, dir: SkPathDirection) -> SkPath;
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkPath5RRectERK7SkRRect15SkPathDirectionj"]
    pub fn SkPath_RRect1(
        arg1: *const SkRRect,
        arg2: SkPathDirection,
        startIndex: ::std::os::raw::c_uint,
    ) -> SkPath;
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkPath5RRectERK6SkRectff15SkPathDirection"]
    pub fn SkPath_RRect2(
        bounds: *const SkRect,
        rx: SkScalar,
        ry: SkScalar,
        dir: SkPathDirection,
    ) -> SkPath;
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkPath7PolygonEPK7SkPointib14SkPathFillTypeb"]
    pub fn SkPath_Polygon(
        pts: *const SkPoint,
        count: ::std::os::raw::c_int,
        isClosed: bool,
        arg1: SkPathFillType,
        isVolatile: bool,
    ) -> SkPath;
}
extern "C" {
    #[link_name = "\u{1}__ZNK6SkPath16isInterpolatableERKS_"]
    pub fn SkPath_isInterpolatable(this: *const SkPath, compare: *const SkPath) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK6SkPath11interpolateERKS_fPS_"]
    pub fn SkPath_interpolate(
        this: *const SkPath,
        ending: *const SkPath,
        weight: SkScalar,
        out: *mut SkPath,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK6SkPath8isConvexEv"]
    pub fn SkPath_isConvex(this: *const SkPath) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK6SkPath6isOvalEP6SkRect"]
    pub fn SkPath_isOval(this: *const SkPath, bounds: *mut SkRect) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK6SkPath7isRRectEP7SkRRect"]
    pub fn SkPath_isRRect(this: *const SkPath, rrect: *mut SkRRect) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkPath5resetEv"]
    pub fn SkPath_reset(this: *mut SkPath) -> *mut SkPath;
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkPath6rewindEv"]
    pub fn SkPath_rewind(this: *mut SkPath) -> *mut SkPath;
}
extern "C" {
    #[link_name = "\u{1}__ZNK6SkPath7isEmptyEv"]
    pub fn SkPath_isEmpty(this: *const SkPath) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK6SkPath19isLastContourClosedEv"]
    pub fn SkPath_isLastContourClosed(this: *const SkPath) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK6SkPath8isFiniteEv"]
    pub fn SkPath_isFinite(this: *const SkPath) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkPath16IsLineDegenerateERK7SkPointS2_b"]
    pub fn SkPath_IsLineDegenerate(p1: *const SkPoint, p2: *const SkPoint, exact: bool) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkPath16IsQuadDegenerateERK7SkPointS2_S2_b"]
    pub fn SkPath_IsQuadDegenerate(
        p1: *const SkPoint,
        p2: *const SkPoint,
        p3: *const SkPoint,
        exact: bool,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkPath17IsCubicDegenerateERK7SkPointS2_S2_S2_b"]
    pub fn SkPath_IsCubicDegenerate(
        p1: *const SkPoint,
        p2: *const SkPoint,
        p3: *const SkPoint,
        p4: *const SkPoint,
        exact: bool,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK6SkPath6isLineEP7SkPoint"]
    pub fn SkPath_isLine(this: *const SkPath, line: *mut SkPoint) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK6SkPath11countPointsEv"]
    pub fn SkPath_countPoints(this: *const SkPath) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__ZNK6SkPath8getPointEi"]
    pub fn SkPath_getPoint(this: *const SkPath, index: ::std::os::raw::c_int) -> SkPoint;
}
extern "C" {
    #[link_name = "\u{1}__ZNK6SkPath9getPointsEP7SkPointi"]
    pub fn SkPath_getPoints(
        this: *const SkPath,
        points: *mut SkPoint,
        max: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__ZNK6SkPath10countVerbsEv"]
    pub fn SkPath_countVerbs(this: *const SkPath) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__ZNK6SkPath8getVerbsEPhi"]
    pub fn SkPath_getVerbs(
        this: *const SkPath,
        verbs: *mut u8,
        max: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__ZNK6SkPath20approximateBytesUsedEv"]
    pub fn SkPath_approximateBytesUsed(this: *const SkPath) -> usize;
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkPath4swapERS_"]
    pub fn SkPath_swap(this: *mut SkPath, other: *mut SkPath);
}
extern "C" {
    #[link_name = "\u{1}__ZNK6SkPath9getBoundsEv"]
    pub fn SkPath_getBounds(this: *const SkPath) -> *const SkRect;
}
extern "C" {
    #[link_name = "\u{1}__ZNK6SkPath18computeTightBoundsEv"]
    pub fn SkPath_computeTightBounds(this: *const SkPath) -> SkRect;
}
extern "C" {
    #[link_name = "\u{1}__ZNK6SkPath26conservativelyContainsRectERK6SkRect"]
    pub fn SkPath_conservativelyContainsRect(this: *const SkPath, rect: *const SkRect) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkPath10incReserveEi"]
    pub fn SkPath_incReserve(this: *mut SkPath, extraPtCount: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkPath6moveToEff"]
    pub fn SkPath_moveTo(this: *mut SkPath, x: SkScalar, y: SkScalar) -> *mut SkPath;
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkPath7rMoveToEff"]
    pub fn SkPath_rMoveTo(this: *mut SkPath, dx: SkScalar, dy: SkScalar) -> *mut SkPath;
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkPath6lineToEff"]
    pub fn SkPath_lineTo(this: *mut SkPath, x: SkScalar, y: SkScalar) -> *mut SkPath;
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkPath7rLineToEff"]
    pub fn SkPath_rLineTo(this: *mut SkPath, dx: SkScalar, dy: SkScalar) -> *mut SkPath;
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkPath6quadToEffff"]
    pub fn SkPath_quadTo(
        this: *mut SkPath,
        x1: SkScalar,
        y1: SkScalar,
        x2: SkScalar,
        y2: SkScalar,
    ) -> *mut SkPath;
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkPath7rQuadToEffff"]
    pub fn SkPath_rQuadTo(
        this: *mut SkPath,
        dx1: SkScalar,
        dy1: SkScalar,
        dx2: SkScalar,
        dy2: SkScalar,
    ) -> *mut SkPath;
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkPath7conicToEfffff"]
    pub fn SkPath_conicTo(
        this: *mut SkPath,
        x1: SkScalar,
        y1: SkScalar,
        x2: SkScalar,
        y2: SkScalar,
        w: SkScalar,
    ) -> *mut SkPath;
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkPath8rConicToEfffff"]
    pub fn SkPath_rConicTo(
        this: *mut SkPath,
        dx1: SkScalar,
        dy1: SkScalar,
        dx2: SkScalar,
        dy2: SkScalar,
        w: SkScalar,
    ) -> *mut SkPath;
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkPath7cubicToEffffff"]
    pub fn SkPath_cubicTo(
        this: *mut SkPath,
        x1: SkScalar,
        y1: SkScalar,
        x2: SkScalar,
        y2: SkScalar,
        x3: SkScalar,
        y3: SkScalar,
    ) -> *mut SkPath;
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkPath8rCubicToEffffff"]
    pub fn SkPath_rCubicTo(
        this: *mut SkPath,
        dx1: SkScalar,
        dy1: SkScalar,
        dx2: SkScalar,
        dy2: SkScalar,
        dx3: SkScalar,
        dy3: SkScalar,
    ) -> *mut SkPath;
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkPath5arcToERK6SkRectffb"]
    pub fn SkPath_arcTo(
        this: *mut SkPath,
        oval: *const SkRect,
        startAngle: SkScalar,
        sweepAngle: SkScalar,
        forceMoveTo: bool,
    ) -> *mut SkPath;
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkPath5arcToEfffff"]
    pub fn SkPath_arcTo1(
        this: *mut SkPath,
        x1: SkScalar,
        y1: SkScalar,
        x2: SkScalar,
        y2: SkScalar,
        radius: SkScalar,
    ) -> *mut SkPath;
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkPath5arcToEfffNS_7ArcSizeE15SkPathDirectionff"]
    pub fn SkPath_arcTo2(
        this: *mut SkPath,
        rx: SkScalar,
        ry: SkScalar,
        xAxisRotate: SkScalar,
        largeArc: SkPath_ArcSize,
        sweep: SkPathDirection,
        x: SkScalar,
        y: SkScalar,
    ) -> *mut SkPath;
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkPath6rArcToEfffNS_7ArcSizeE15SkPathDirectionff"]
    pub fn SkPath_rArcTo(
        this: *mut SkPath,
        rx: SkScalar,
        ry: SkScalar,
        xAxisRotate: SkScalar,
        largeArc: SkPath_ArcSize,
        sweep: SkPathDirection,
        dx: SkScalar,
        dy: SkScalar,
    ) -> *mut SkPath;
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkPath5closeEv"]
    pub fn SkPath_close(this: *mut SkPath) -> *mut SkPath;
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkPath19ConvertConicToQuadsERK7SkPointS2_S2_fPS0_i"]
    pub fn SkPath_ConvertConicToQuads(
        p0: *const SkPoint,
        p1: *const SkPoint,
        p2: *const SkPoint,
        w: SkScalar,
        pts: *mut SkPoint,
        pow2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__ZNK6SkPath6isRectEP6SkRectPbP15SkPathDirection"]
    pub fn SkPath_isRect(
        this: *const SkPath,
        rect: *mut SkRect,
        isClosed: *mut bool,
        direction: *mut SkPathDirection,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkPath7addRectERK6SkRect15SkPathDirectionj"]
    pub fn SkPath_addRect(
        this: *mut SkPath,
        rect: *const SkRect,
        dir: SkPathDirection,
        start: ::std::os::raw::c_uint,
    ) -> *mut SkPath;
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkPath7addOvalERK6SkRect15SkPathDirection"]
    pub fn SkPath_addOval(
        this: *mut SkPath,
        oval: *const SkRect,
        dir: SkPathDirection,
    ) -> *mut SkPath;
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkPath7addOvalERK6SkRect15SkPathDirectionj"]
    pub fn SkPath_addOval1(
        this: *mut SkPath,
        oval: *const SkRect,
        dir: SkPathDirection,
        start: ::std::os::raw::c_uint,
    ) -> *mut SkPath;
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkPath9addCircleEfff15SkPathDirection"]
    pub fn SkPath_addCircle(
        this: *mut SkPath,
        x: SkScalar,
        y: SkScalar,
        radius: SkScalar,
        dir: SkPathDirection,
    ) -> *mut SkPath;
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkPath6addArcERK6SkRectff"]
    pub fn SkPath_addArc(
        this: *mut SkPath,
        oval: *const SkRect,
        startAngle: SkScalar,
        sweepAngle: SkScalar,
    ) -> *mut SkPath;
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkPath12addRoundRectERK6SkRectff15SkPathDirection"]
    pub fn SkPath_addRoundRect(
        this: *mut SkPath,
        rect: *const SkRect,
        rx: SkScalar,
        ry: SkScalar,
        dir: SkPathDirection,
    ) -> *mut SkPath;
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkPath12addRoundRectERK6SkRectPKf15SkPathDirection"]
    pub fn SkPath_addRoundRect1(
        this: *mut SkPath,
        rect: *const SkRect,
        radii: *const SkScalar,
        dir: SkPathDirection,
    ) -> *mut SkPath;
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkPath8addRRectERK7SkRRect15SkPathDirection"]
    pub fn SkPath_addRRect(
        this: *mut SkPath,
        rrect: *const SkRRect,
        dir: SkPathDirection,
    ) -> *mut SkPath;
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkPath8addRRectERK7SkRRect15SkPathDirectionj"]
    pub fn SkPath_addRRect1(
        this: *mut SkPath,
        rrect: *const SkRRect,
        dir: SkPathDirection,
        start: ::std::os::raw::c_uint,
    ) -> *mut SkPath;
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkPath7addPolyEPK7SkPointib"]
    pub fn SkPath_addPoly(
        this: *mut SkPath,
        pts: *const SkPoint,
        count: ::std::os::raw::c_int,
        close: bool,
    ) -> *mut SkPath;
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkPath7addPathERKS_ffNS_11AddPathModeE"]
    pub fn SkPath_addPath(
        this: *mut SkPath,
        src: *const SkPath,
        dx: SkScalar,
        dy: SkScalar,
        mode: SkPath_AddPathMode,
    ) -> *mut SkPath;
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkPath7addPathERKS_RK8SkMatrixNS_11AddPathModeE"]
    pub fn SkPath_addPath1(
        this: *mut SkPath,
        src: *const SkPath,
        matrix: *const SkMatrix,
        mode: SkPath_AddPathMode,
    ) -> *mut SkPath;
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkPath14reverseAddPathERKS_"]
    pub fn SkPath_reverseAddPath(this: *mut SkPath, src: *const SkPath) -> *mut SkPath;
}
extern "C" {
    #[link_name = "\u{1}__ZNK6SkPath6offsetEffPS_"]
    pub fn SkPath_offset(this: *const SkPath, dx: SkScalar, dy: SkScalar, dst: *mut SkPath);
}
extern "C" {
    #[link_name = "\u{1}__ZNK6SkPath9transformERK8SkMatrixPS_22SkApplyPerspectiveClip"]
    pub fn SkPath_transform(
        this: *const SkPath,
        matrix: *const SkMatrix,
        dst: *mut SkPath,
        pc: SkApplyPerspectiveClip,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNK6SkPath9getLastPtEP7SkPoint"]
    pub fn SkPath_getLastPt(this: *const SkPath, lastPt: *mut SkPoint) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkPath9setLastPtEff"]
    pub fn SkPath_setLastPt(this: *mut SkPath, x: SkScalar, y: SkScalar);
}
extern "C" {
    #[link_name = "\u{1}__ZNK6SkPath15getSegmentMasksEv"]
    pub fn SkPath_getSegmentMasks(this: *const SkPath) -> u32;
}
extern "C" {
    #[link_name = "\u{1}__ZNK6SkPath8containsEff"]
    pub fn SkPath_contains(this: *const SkPath, x: SkScalar, y: SkScalar) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK6SkPath4dumpEP9SkWStreamb"]
    pub fn SkPath_dump(this: *const SkPath, stream: *mut SkWStream, dumpAsHex: bool);
}
extern "C" {
    #[link_name = "\u{1}__ZNK6SkPath10dumpArraysEP9SkWStreamb"]
    pub fn SkPath_dumpArrays(this: *const SkPath, stream: *mut SkWStream, dumpAsHex: bool);
}
extern "C" {
    #[link_name = "\u{1}__ZNK6SkPath13writeToMemoryEPv"]
    pub fn SkPath_writeToMemory(this: *const SkPath, buffer: *mut ::core::ffi::c_void) -> usize;
}
extern "C" {
    #[link_name = "\u{1}__ZNK6SkPath9serializeEv"]
    pub fn SkPath_serialize(this: *const SkPath) -> sk_sp<SkData>;
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkPath14readFromMemoryEPKvm"]
    pub fn SkPath_readFromMemory(
        this: *mut SkPath,
        buffer: *const ::core::ffi::c_void,
        length: usize,
    ) -> usize;
}
extern "C" {
    #[link_name = "\u{1}__ZNK6SkPath15getGenerationIDEv"]
    pub fn SkPath_getGenerationID(this: *const SkPath) -> u32;
}
extern "C" {
    #[link_name = "\u{1}__ZNK6SkPath7isValidEv"]
    pub fn SkPath_isValid(this: *const SkPath) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkPathC1Ev"]
    pub fn SkPath_SkPath(this: *mut SkPath);
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkPathC1ERKS_"]
    pub fn SkPath_SkPath1(this: *mut SkPath, path: *const SkPath);
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkPathD1Ev"]
    pub fn SkPath_SkPath_destructor(this: *mut SkPath);
}
impl SkPath {
    #[inline]
    pub fn fFillType(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_fFillType(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn fIsVolatile(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_fIsVolatile(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(fFillType: u8, fIsVolatile: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let fFillType: u8 = unsafe { ::core::mem::transmute(fFillType) };
            fFillType as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let fIsVolatile: u8 = unsafe { ::core::mem::transmute(fIsVolatile) };
            fIsVolatile as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub unsafe fn Make(
        arg1: *const SkPoint,
        pointCount: ::std::os::raw::c_int,
        arg2: *const u8,
        verbCount: ::std::os::raw::c_int,
        arg3: *const SkScalar,
        conicWeightCount: ::std::os::raw::c_int,
        arg4: SkPathFillType,
        isVolatile: bool,
    ) -> SkPath {
        SkPath_Make(
            arg1,
            pointCount,
            arg2,
            verbCount,
            arg3,
            conicWeightCount,
            arg4,
            isVolatile,
        )
    }
    #[inline]
    pub unsafe fn Rect(
        arg1: *const SkRect,
        arg2: SkPathDirection,
        startIndex: ::std::os::raw::c_uint,
    ) -> SkPath {
        SkPath_Rect(arg1, arg2, startIndex)
    }
    #[inline]
    pub unsafe fn Oval(arg1: *const SkRect, arg2: SkPathDirection) -> SkPath {
        SkPath_Oval(arg1, arg2)
    }
    #[inline]
    pub unsafe fn Oval1(
        arg1: *const SkRect,
        arg2: SkPathDirection,
        startIndex: ::std::os::raw::c_uint,
    ) -> SkPath {
        SkPath_Oval1(arg1, arg2, startIndex)
    }
    #[inline]
    pub unsafe fn Circle(
        center_x: SkScalar,
        center_y: SkScalar,
        radius: SkScalar,
        dir: SkPathDirection,
    ) -> SkPath {
        SkPath_Circle(center_x, center_y, radius, dir)
    }
    #[inline]
    pub unsafe fn RRect(arg1: *const SkRRect, dir: SkPathDirection) -> SkPath {
        SkPath_RRect(arg1, dir)
    }
    #[inline]
    pub unsafe fn RRect1(
        arg1: *const SkRRect,
        arg2: SkPathDirection,
        startIndex: ::std::os::raw::c_uint,
    ) -> SkPath {
        SkPath_RRect1(arg1, arg2, startIndex)
    }
    #[inline]
    pub unsafe fn RRect2(
        bounds: *const SkRect,
        rx: SkScalar,
        ry: SkScalar,
        dir: SkPathDirection,
    ) -> SkPath {
        SkPath_RRect2(bounds, rx, ry, dir)
    }
    #[inline]
    pub unsafe fn Polygon(
        pts: *const SkPoint,
        count: ::std::os::raw::c_int,
        isClosed: bool,
        arg1: SkPathFillType,
        isVolatile: bool,
    ) -> SkPath {
        SkPath_Polygon(pts, count, isClosed, arg1, isVolatile)
    }
    #[inline]
    pub unsafe fn isInterpolatable(&self, compare: *const SkPath) -> bool {
        SkPath_isInterpolatable(self, compare)
    }
    #[inline]
    pub unsafe fn interpolate(
        &self,
        ending: *const SkPath,
        weight: SkScalar,
        out: *mut SkPath,
    ) -> bool {
        SkPath_interpolate(self, ending, weight, out)
    }
    #[inline]
    pub unsafe fn isConvex(&self) -> bool {
        SkPath_isConvex(self)
    }
    #[inline]
    pub unsafe fn isOval(&self, bounds: *mut SkRect) -> bool {
        SkPath_isOval(self, bounds)
    }
    #[inline]
    pub unsafe fn isRRect(&self, rrect: *mut SkRRect) -> bool {
        SkPath_isRRect(self, rrect)
    }
    #[inline]
    pub unsafe fn reset(&mut self) -> *mut SkPath {
        SkPath_reset(self)
    }
    #[inline]
    pub unsafe fn rewind(&mut self) -> *mut SkPath {
        SkPath_rewind(self)
    }
    #[inline]
    pub unsafe fn isEmpty(&self) -> bool {
        SkPath_isEmpty(self)
    }
    #[inline]
    pub unsafe fn isLastContourClosed(&self) -> bool {
        SkPath_isLastContourClosed(self)
    }
    #[inline]
    pub unsafe fn isFinite(&self) -> bool {
        SkPath_isFinite(self)
    }
    #[inline]
    pub unsafe fn IsLineDegenerate(p1: *const SkPoint, p2: *const SkPoint, exact: bool) -> bool {
        SkPath_IsLineDegenerate(p1, p2, exact)
    }
    #[inline]
    pub unsafe fn IsQuadDegenerate(
        p1: *const SkPoint,
        p2: *const SkPoint,
        p3: *const SkPoint,
        exact: bool,
    ) -> bool {
        SkPath_IsQuadDegenerate(p1, p2, p3, exact)
    }
    #[inline]
    pub unsafe fn IsCubicDegenerate(
        p1: *const SkPoint,
        p2: *const SkPoint,
        p3: *const SkPoint,
        p4: *const SkPoint,
        exact: bool,
    ) -> bool {
        SkPath_IsCubicDegenerate(p1, p2, p3, p4, exact)
    }
    #[inline]
    pub unsafe fn isLine(&self, line: *mut SkPoint) -> bool {
        SkPath_isLine(self, line)
    }
    #[inline]
    pub unsafe fn countPoints(&self) -> ::std::os::raw::c_int {
        SkPath_countPoints(self)
    }
    #[inline]
    pub unsafe fn getPoint(&self, index: ::std::os::raw::c_int) -> SkPoint {
        SkPath_getPoint(self, index)
    }
    #[inline]
    pub unsafe fn getPoints(
        &self,
        points: *mut SkPoint,
        max: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        SkPath_getPoints(self, points, max)
    }
    #[inline]
    pub unsafe fn countVerbs(&self) -> ::std::os::raw::c_int {
        SkPath_countVerbs(self)
    }
    #[inline]
    pub unsafe fn getVerbs(
        &self,
        verbs: *mut u8,
        max: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        SkPath_getVerbs(self, verbs, max)
    }
    #[inline]
    pub unsafe fn approximateBytesUsed(&self) -> usize {
        SkPath_approximateBytesUsed(self)
    }
    #[inline]
    pub unsafe fn swap(&mut self, other: *mut SkPath) {
        SkPath_swap(self, other)
    }
    #[inline]
    pub unsafe fn getBounds(&self) -> *const SkRect {
        SkPath_getBounds(self)
    }
    #[inline]
    pub unsafe fn computeTightBounds(&self) -> SkRect {
        SkPath_computeTightBounds(self)
    }
    #[inline]
    pub unsafe fn conservativelyContainsRect(&self, rect: *const SkRect) -> bool {
        SkPath_conservativelyContainsRect(self, rect)
    }
    #[inline]
    pub unsafe fn incReserve(&mut self, extraPtCount: ::std::os::raw::c_int) {
        SkPath_incReserve(self, extraPtCount)
    }
    #[inline]
    pub unsafe fn moveTo(&mut self, x: SkScalar, y: SkScalar) -> *mut SkPath {
        SkPath_moveTo(self, x, y)
    }
    #[inline]
    pub unsafe fn rMoveTo(&mut self, dx: SkScalar, dy: SkScalar) -> *mut SkPath {
        SkPath_rMoveTo(self, dx, dy)
    }
    #[inline]
    pub unsafe fn lineTo(&mut self, x: SkScalar, y: SkScalar) -> *mut SkPath {
        SkPath_lineTo(self, x, y)
    }
    #[inline]
    pub unsafe fn rLineTo(&mut self, dx: SkScalar, dy: SkScalar) -> *mut SkPath {
        SkPath_rLineTo(self, dx, dy)
    }
    #[inline]
    pub unsafe fn quadTo(
        &mut self,
        x1: SkScalar,
        y1: SkScalar,
        x2: SkScalar,
        y2: SkScalar,
    ) -> *mut SkPath {
        SkPath_quadTo(self, x1, y1, x2, y2)
    }
    #[inline]
    pub unsafe fn rQuadTo(
        &mut self,
        dx1: SkScalar,
        dy1: SkScalar,
        dx2: SkScalar,
        dy2: SkScalar,
    ) -> *mut SkPath {
        SkPath_rQuadTo(self, dx1, dy1, dx2, dy2)
    }
    #[inline]
    pub unsafe fn conicTo(
        &mut self,
        x1: SkScalar,
        y1: SkScalar,
        x2: SkScalar,
        y2: SkScalar,
        w: SkScalar,
    ) -> *mut SkPath {
        SkPath_conicTo(self, x1, y1, x2, y2, w)
    }
    #[inline]
    pub unsafe fn rConicTo(
        &mut self,
        dx1: SkScalar,
        dy1: SkScalar,
        dx2: SkScalar,
        dy2: SkScalar,
        w: SkScalar,
    ) -> *mut SkPath {
        SkPath_rConicTo(self, dx1, dy1, dx2, dy2, w)
    }
    #[inline]
    pub unsafe fn cubicTo(
        &mut self,
        x1: SkScalar,
        y1: SkScalar,
        x2: SkScalar,
        y2: SkScalar,
        x3: SkScalar,
        y3: SkScalar,
    ) -> *mut SkPath {
        SkPath_cubicTo(self, x1, y1, x2, y2, x3, y3)
    }
    #[inline]
    pub unsafe fn rCubicTo(
        &mut self,
        dx1: SkScalar,
        dy1: SkScalar,
        dx2: SkScalar,
        dy2: SkScalar,
        dx3: SkScalar,
        dy3: SkScalar,
    ) -> *mut SkPath {
        SkPath_rCubicTo(self, dx1, dy1, dx2, dy2, dx3, dy3)
    }
    #[inline]
    pub unsafe fn arcTo(
        &mut self,
        oval: *const SkRect,
        startAngle: SkScalar,
        sweepAngle: SkScalar,
        forceMoveTo: bool,
    ) -> *mut SkPath {
        SkPath_arcTo(self, oval, startAngle, sweepAngle, forceMoveTo)
    }
    #[inline]
    pub unsafe fn arcTo1(
        &mut self,
        x1: SkScalar,
        y1: SkScalar,
        x2: SkScalar,
        y2: SkScalar,
        radius: SkScalar,
    ) -> *mut SkPath {
        SkPath_arcTo1(self, x1, y1, x2, y2, radius)
    }
    #[inline]
    pub unsafe fn arcTo2(
        &mut self,
        rx: SkScalar,
        ry: SkScalar,
        xAxisRotate: SkScalar,
        largeArc: SkPath_ArcSize,
        sweep: SkPathDirection,
        x: SkScalar,
        y: SkScalar,
    ) -> *mut SkPath {
        SkPath_arcTo2(self, rx, ry, xAxisRotate, largeArc, sweep, x, y)
    }
    #[inline]
    pub unsafe fn rArcTo(
        &mut self,
        rx: SkScalar,
        ry: SkScalar,
        xAxisRotate: SkScalar,
        largeArc: SkPath_ArcSize,
        sweep: SkPathDirection,
        dx: SkScalar,
        dy: SkScalar,
    ) -> *mut SkPath {
        SkPath_rArcTo(self, rx, ry, xAxisRotate, largeArc, sweep, dx, dy)
    }
    #[inline]
    pub unsafe fn close(&mut self) -> *mut SkPath {
        SkPath_close(self)
    }
    #[inline]
    pub unsafe fn ConvertConicToQuads(
        p0: *const SkPoint,
        p1: *const SkPoint,
        p2: *const SkPoint,
        w: SkScalar,
        pts: *mut SkPoint,
        pow2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        SkPath_ConvertConicToQuads(p0, p1, p2, w, pts, pow2)
    }
    #[inline]
    pub unsafe fn isRect(
        &self,
        rect: *mut SkRect,
        isClosed: *mut bool,
        direction: *mut SkPathDirection,
    ) -> bool {
        SkPath_isRect(self, rect, isClosed, direction)
    }
    #[inline]
    pub unsafe fn addRect(
        &mut self,
        rect: *const SkRect,
        dir: SkPathDirection,
        start: ::std::os::raw::c_uint,
    ) -> *mut SkPath {
        SkPath_addRect(self, rect, dir, start)
    }
    #[inline]
    pub unsafe fn addOval(&mut self, oval: *const SkRect, dir: SkPathDirection) -> *mut SkPath {
        SkPath_addOval(self, oval, dir)
    }
    #[inline]
    pub unsafe fn addOval1(
        &mut self,
        oval: *const SkRect,
        dir: SkPathDirection,
        start: ::std::os::raw::c_uint,
    ) -> *mut SkPath {
        SkPath_addOval1(self, oval, dir, start)
    }
    #[inline]
    pub unsafe fn addCircle(
        &mut self,
        x: SkScalar,
        y: SkScalar,
        radius: SkScalar,
        dir: SkPathDirection,
    ) -> *mut SkPath {
        SkPath_addCircle(self, x, y, radius, dir)
    }
    #[inline]
    pub unsafe fn addArc(
        &mut self,
        oval: *const SkRect,
        startAngle: SkScalar,
        sweepAngle: SkScalar,
    ) -> *mut SkPath {
        SkPath_addArc(self, oval, startAngle, sweepAngle)
    }
    #[inline]
    pub unsafe fn addRoundRect(
        &mut self,
        rect: *const SkRect,
        rx: SkScalar,
        ry: SkScalar,
        dir: SkPathDirection,
    ) -> *mut SkPath {
        SkPath_addRoundRect(self, rect, rx, ry, dir)
    }
    #[inline]
    pub unsafe fn addRoundRect1(
        &mut self,
        rect: *const SkRect,
        radii: *const SkScalar,
        dir: SkPathDirection,
    ) -> *mut SkPath {
        SkPath_addRoundRect1(self, rect, radii, dir)
    }
    #[inline]
    pub unsafe fn addRRect(&mut self, rrect: *const SkRRect, dir: SkPathDirection) -> *mut SkPath {
        SkPath_addRRect(self, rrect, dir)
    }
    #[inline]
    pub unsafe fn addRRect1(
        &mut self,
        rrect: *const SkRRect,
        dir: SkPathDirection,
        start: ::std::os::raw::c_uint,
    ) -> *mut SkPath {
        SkPath_addRRect1(self, rrect, dir, start)
    }
    #[inline]
    pub unsafe fn addPoly(
        &mut self,
        pts: *const SkPoint,
        count: ::std::os::raw::c_int,
        close: bool,
    ) -> *mut SkPath {
        SkPath_addPoly(self, pts, count, close)
    }
    #[inline]
    pub unsafe fn addPath(
        &mut self,
        src: *const SkPath,
        dx: SkScalar,
        dy: SkScalar,
        mode: SkPath_AddPathMode,
    ) -> *mut SkPath {
        SkPath_addPath(self, src, dx, dy, mode)
    }
    #[inline]
    pub unsafe fn addPath1(
        &mut self,
        src: *const SkPath,
        matrix: *const SkMatrix,
        mode: SkPath_AddPathMode,
    ) -> *mut SkPath {
        SkPath_addPath1(self, src, matrix, mode)
    }
    #[inline]
    pub unsafe fn reverseAddPath(&mut self, src: *const SkPath) -> *mut SkPath {
        SkPath_reverseAddPath(self, src)
    }
    #[inline]
    pub unsafe fn offset(&self, dx: SkScalar, dy: SkScalar, dst: *mut SkPath) {
        SkPath_offset(self, dx, dy, dst)
    }
    #[inline]
    pub unsafe fn transform(
        &self,
        matrix: *const SkMatrix,
        dst: *mut SkPath,
        pc: SkApplyPerspectiveClip,
    ) {
        SkPath_transform(self, matrix, dst, pc)
    }
    #[inline]
    pub unsafe fn getLastPt(&self, lastPt: *mut SkPoint) -> bool {
        SkPath_getLastPt(self, lastPt)
    }
    #[inline]
    pub unsafe fn setLastPt(&mut self, x: SkScalar, y: SkScalar) {
        SkPath_setLastPt(self, x, y)
    }
    #[inline]
    pub unsafe fn getSegmentMasks(&self) -> u32 {
        SkPath_getSegmentMasks(self)
    }
    #[inline]
    pub unsafe fn contains(&self, x: SkScalar, y: SkScalar) -> bool {
        SkPath_contains(self, x, y)
    }
    #[inline]
    pub unsafe fn dump(&self, stream: *mut SkWStream, dumpAsHex: bool) {
        SkPath_dump(self, stream, dumpAsHex)
    }
    #[inline]
    pub unsafe fn dumpArrays(&self, stream: *mut SkWStream, dumpAsHex: bool) {
        SkPath_dumpArrays(self, stream, dumpAsHex)
    }
    #[inline]
    pub unsafe fn writeToMemory(&self, buffer: *mut ::core::ffi::c_void) -> usize {
        SkPath_writeToMemory(self, buffer)
    }
    #[inline]
    pub unsafe fn serialize(&self) -> sk_sp<SkData> {
        SkPath_serialize(self)
    }
    #[inline]
    pub unsafe fn readFromMemory(
        &mut self,
        buffer: *const ::core::ffi::c_void,
        length: usize,
    ) -> usize {
        SkPath_readFromMemory(self, buffer, length)
    }
    #[inline]
    pub unsafe fn getGenerationID(&self) -> u32 {
        SkPath_getGenerationID(self)
    }
    #[inline]
    pub unsafe fn isValid(&self) -> bool {
        SkPath_isValid(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkPath_SkPath(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(path: *const SkPath) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkPath_SkPath1(__bindgen_tmp.as_mut_ptr(), path);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        SkPath_SkPath_destructor(self)
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct SkTDArray<T> {
    pub fArray: *mut T,
    pub fReserve: ::std::os::raw::c_int,
    pub fCount: ::std::os::raw::c_int,
    pub _phantom_0: ::core::marker::PhantomData<::core::cell::UnsafeCell<T>>,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct SkContourMeasure {
    pub _bindgen_opaque_blob: [u64; 7usize],
}
pub const SkContourMeasure_MatrixFlags_kGetPosition_MatrixFlag: SkContourMeasure_MatrixFlags = 1;
pub const SkContourMeasure_MatrixFlags_kGetTangent_MatrixFlag: SkContourMeasure_MatrixFlags = 2;
pub const SkContourMeasure_MatrixFlags_kGetPosAndTan_MatrixFlag: SkContourMeasure_MatrixFlags = 3;
pub type SkContourMeasure_MatrixFlags = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkContourMeasure_Segment {
    pub fDistance: SkScalar,
    pub fPtIndex: ::std::os::raw::c_uint,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_SkContourMeasure_Segment() {
    assert_eq!(
        ::core::mem::size_of::<SkContourMeasure_Segment>(),
        12usize,
        concat!("Size of: ", stringify!(SkContourMeasure_Segment))
    );
    assert_eq!(
        ::core::mem::align_of::<SkContourMeasure_Segment>(),
        4usize,
        concat!("Alignment of ", stringify!(SkContourMeasure_Segment))
    );
    fn test_field_fDistance() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkContourMeasure_Segment>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fDistance) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SkContourMeasure_Segment),
                "::",
                stringify!(fDistance)
            )
        );
    }
    test_field_fDistance();
    fn test_field_fPtIndex() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkContourMeasure_Segment>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fPtIndex) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(SkContourMeasure_Segment),
                "::",
                stringify!(fPtIndex)
            )
        );
    }
    test_field_fPtIndex();
}
extern "C" {
    #[link_name = "\u{1}__ZNK16SkContourMeasure7Segment10getScalarTEv"]
    pub fn SkContourMeasure_Segment_getScalarT(this: *const SkContourMeasure_Segment) -> SkScalar;
}
impl SkContourMeasure_Segment {
    #[inline]
    pub fn fTValue(&self) -> ::std::os::raw::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_fTValue(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn fType(&self) -> ::std::os::raw::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_fType(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        fTValue: ::std::os::raw::c_uint,
        fType: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 30u8, {
            let fTValue: u32 = unsafe { ::core::mem::transmute(fTValue) };
            fTValue as u64
        });
        __bindgen_bitfield_unit.set(30usize, 2u8, {
            let fType: u32 = unsafe { ::core::mem::transmute(fType) };
            fType as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub unsafe fn getScalarT(&self) -> SkScalar {
        SkContourMeasure_Segment_getScalarT(self)
    }
}
#[test]
fn bindgen_test_layout_SkContourMeasure() {
    assert_eq!(
        ::core::mem::size_of::<SkContourMeasure>(),
        56usize,
        concat!("Size of: ", stringify!(SkContourMeasure))
    );
    assert_eq!(
        ::core::mem::align_of::<SkContourMeasure>(),
        8usize,
        concat!("Alignment of ", stringify!(SkContourMeasure))
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNK16SkContourMeasure9getPosTanEfP7SkPointS1_"]
    pub fn SkContourMeasure_getPosTan(
        this: *const SkContourMeasure,
        distance: SkScalar,
        position: *mut SkPoint,
        tangent: *mut SkVector,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK16SkContourMeasure9getMatrixEfP8SkMatrixNS_11MatrixFlagsE"]
    pub fn SkContourMeasure_getMatrix(
        this: *const SkContourMeasure,
        distance: SkScalar,
        matrix: *mut SkMatrix,
        flags: SkContourMeasure_MatrixFlags,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK16SkContourMeasure10getSegmentEffP6SkPathb"]
    pub fn SkContourMeasure_getSegment(
        this: *const SkContourMeasure,
        startD: SkScalar,
        stopD: SkScalar,
        dst: *mut SkPath,
        startWithMoveTo: bool,
    ) -> bool;
}
impl SkContourMeasure {
    #[inline]
    pub unsafe fn getPosTan(
        &self,
        distance: SkScalar,
        position: *mut SkPoint,
        tangent: *mut SkVector,
    ) -> bool {
        SkContourMeasure_getPosTan(self, distance, position, tangent)
    }
    #[inline]
    pub unsafe fn getMatrix(
        &self,
        distance: SkScalar,
        matrix: *mut SkMatrix,
        flags: SkContourMeasure_MatrixFlags,
    ) -> bool {
        SkContourMeasure_getMatrix(self, distance, matrix, flags)
    }
    #[inline]
    pub unsafe fn getSegment(
        &self,
        startD: SkScalar,
        stopD: SkScalar,
        dst: *mut SkPath,
        startWithMoveTo: bool,
    ) -> bool {
        SkContourMeasure_getSegment(self, startD, stopD, dst, startWithMoveTo)
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct SkContourMeasureIter {
    pub fImpl: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkContourMeasureIter_Impl {
    _unused: [u8; 0],
}
#[test]
fn bindgen_test_layout_SkContourMeasureIter() {
    assert_eq!(
        ::core::mem::size_of::<SkContourMeasureIter>(),
        8usize,
        concat!("Size of: ", stringify!(SkContourMeasureIter))
    );
    assert_eq!(
        ::core::mem::align_of::<SkContourMeasureIter>(),
        8usize,
        concat!("Alignment of ", stringify!(SkContourMeasureIter))
    );
    fn test_field_fImpl() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkContourMeasureIter>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fImpl) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SkContourMeasureIter),
                "::",
                stringify!(fImpl)
            )
        );
    }
    test_field_fImpl();
}
extern "C" {
    #[link_name = "\u{1}__ZN20SkContourMeasureIter5resetERK6SkPathbf"]
    pub fn SkContourMeasureIter_reset(
        this: *mut SkContourMeasureIter,
        path: *const SkPath,
        forceClosed: bool,
        resScale: SkScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN20SkContourMeasureIter4nextEv"]
    pub fn SkContourMeasureIter_next(this: *mut SkContourMeasureIter) -> sk_sp<SkContourMeasure>;
}
extern "C" {
    #[link_name = "\u{1}__ZN20SkContourMeasureIterC1Ev"]
    pub fn SkContourMeasureIter_SkContourMeasureIter(this: *mut SkContourMeasureIter);
}
extern "C" {
    #[link_name = "\u{1}__ZN20SkContourMeasureIterC1ERK6SkPathbf"]
    pub fn SkContourMeasureIter_SkContourMeasureIter1(
        this: *mut SkContourMeasureIter,
        path: *const SkPath,
        forceClosed: bool,
        resScale: SkScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN20SkContourMeasureIterD1Ev"]
    pub fn SkContourMeasureIter_SkContourMeasureIter_destructor(this: *mut SkContourMeasureIter);
}
impl SkContourMeasureIter {
    #[inline]
    pub unsafe fn reset(&mut self, path: *const SkPath, forceClosed: bool, resScale: SkScalar) {
        SkContourMeasureIter_reset(self, path, forceClosed, resScale)
    }
    #[inline]
    pub unsafe fn next(&mut self) -> sk_sp<SkContourMeasure> {
        SkContourMeasureIter_next(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkContourMeasureIter_SkContourMeasureIter(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(path: *const SkPath, forceClosed: bool, resScale: SkScalar) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkContourMeasureIter_SkContourMeasureIter1(
            __bindgen_tmp.as_mut_ptr(),
            path,
            forceClosed,
            resScale,
        );
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        SkContourMeasureIter_SkContourMeasureIter_destructor(self)
    }
}
impl SkCoverageMode {
    pub const Last: SkCoverageMode = SkCoverageMode::Xor;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkCoverageMode {
    Union = 0,
    Intersect = 1,
    Difference = 2,
    ReverseDifference = 3,
    Xor = 4,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkCubicMap {
    pub fCoeff: [SkPoint; 3usize],
    pub fType: SkCubicMap_Type,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkCubicMap_Type {
    Line = 0,
    CubeRoot = 1,
    Solver = 2,
}
#[test]
fn bindgen_test_layout_SkCubicMap() {
    assert_eq!(
        ::core::mem::size_of::<SkCubicMap>(),
        28usize,
        concat!("Size of: ", stringify!(SkCubicMap))
    );
    assert_eq!(
        ::core::mem::align_of::<SkCubicMap>(),
        4usize,
        concat!("Alignment of ", stringify!(SkCubicMap))
    );
    fn test_field_fCoeff() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkCubicMap>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fCoeff) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SkCubicMap),
                "::",
                stringify!(fCoeff)
            )
        );
    }
    test_field_fCoeff();
    fn test_field_fType() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkCubicMap>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fType) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(SkCubicMap),
                "::",
                stringify!(fType)
            )
        );
    }
    test_field_fType();
}
extern "C" {
    #[link_name = "\u{1}__ZNK10SkCubicMap13computeYFromXEf"]
    pub fn SkCubicMap_computeYFromX(this: *const SkCubicMap, x: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}__ZNK10SkCubicMap12computeFromTEf"]
    pub fn SkCubicMap_computeFromT(this: *const SkCubicMap, t: f32) -> SkPoint;
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkCubicMapC1E7SkPointS0_"]
    pub fn SkCubicMap_SkCubicMap(this: *mut SkCubicMap, p1: SkPoint, p2: SkPoint);
}
impl SkCubicMap {
    #[inline]
    pub unsafe fn computeYFromX(&self, x: f32) -> f32 {
        SkCubicMap_computeYFromX(self, x)
    }
    #[inline]
    pub unsafe fn computeFromT(&self, t: f32) -> SkPoint {
        SkCubicMap_computeFromT(self, t)
    }
    #[inline]
    pub unsafe fn new(p1: SkPoint, p2: SkPoint) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkCubicMap_SkCubicMap(__bindgen_tmp.as_mut_ptr(), p1, p2);
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct SkDataTable {
    pub _bindgen_opaque_blob: [u64; 6usize],
}
pub type SkDataTable_FreeProc =
    ::core::option::Option<unsafe extern "C" fn(context: *mut ::core::ffi::c_void)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkDataTable_Dir {
    pub fPtr: *const ::core::ffi::c_void,
    pub fSize: usize,
}
#[test]
fn bindgen_test_layout_SkDataTable_Dir() {
    assert_eq!(
        ::core::mem::size_of::<SkDataTable_Dir>(),
        16usize,
        concat!("Size of: ", stringify!(SkDataTable_Dir))
    );
    assert_eq!(
        ::core::mem::align_of::<SkDataTable_Dir>(),
        8usize,
        concat!("Alignment of ", stringify!(SkDataTable_Dir))
    );
    fn test_field_fPtr() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkDataTable_Dir>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fPtr) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SkDataTable_Dir),
                "::",
                stringify!(fPtr)
            )
        );
    }
    test_field_fPtr();
    fn test_field_fSize() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkDataTable_Dir>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fSize) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(SkDataTable_Dir),
                "::",
                stringify!(fSize)
            )
        );
    }
    test_field_fSize();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SkDataTable__bindgen_ty_1 {
    pub fDir: *const SkDataTable_Dir,
    pub fElems: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_SkDataTable__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SkDataTable__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(SkDataTable__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<SkDataTable__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(SkDataTable__bindgen_ty_1))
    );
    fn test_field_fDir() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkDataTable__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fDir) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SkDataTable__bindgen_ty_1),
                "::",
                stringify!(fDir)
            )
        );
    }
    test_field_fDir();
    fn test_field_fElems() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkDataTable__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fElems) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SkDataTable__bindgen_ty_1),
                "::",
                stringify!(fElems)
            )
        );
    }
    test_field_fElems();
}
pub type SkDataTable_INHERITED = SkRefCnt;
#[test]
fn bindgen_test_layout_SkDataTable() {
    assert_eq!(
        ::core::mem::size_of::<SkDataTable>(),
        48usize,
        concat!("Size of: ", stringify!(SkDataTable))
    );
    assert_eq!(
        ::core::mem::align_of::<SkDataTable>(),
        8usize,
        concat!("Alignment of ", stringify!(SkDataTable))
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNK11SkDataTable6atSizeEi"]
    pub fn SkDataTable_atSize(this: *const SkDataTable, index: ::std::os::raw::c_int) -> usize;
}
extern "C" {
    #[link_name = "\u{1}__ZNK11SkDataTable2atEiPm"]
    pub fn SkDataTable_at(
        this: *const SkDataTable,
        index: ::std::os::raw::c_int,
        size: *mut usize,
    ) -> *const ::core::ffi::c_void;
}
extern "C" {
    #[link_name = "\u{1}__ZN11SkDataTable9MakeEmptyEv"]
    pub fn SkDataTable_MakeEmpty() -> sk_sp<SkDataTable>;
}
extern "C" {
    #[link_name = "\u{1}__ZN11SkDataTable14MakeCopyArraysEPKPKvPKmi"]
    pub fn SkDataTable_MakeCopyArrays(
        ptrs: *const *const ::core::ffi::c_void,
        sizes: *const usize,
        count: ::std::os::raw::c_int,
    ) -> sk_sp<SkDataTable>;
}
extern "C" {
    #[link_name = "\u{1}__ZN11SkDataTable13MakeCopyArrayEPKvmi"]
    pub fn SkDataTable_MakeCopyArray(
        array: *const ::core::ffi::c_void,
        elemSize: usize,
        count: ::std::os::raw::c_int,
    ) -> sk_sp<SkDataTable>;
}
extern "C" {
    #[link_name = "\u{1}__ZN11SkDataTable13MakeArrayProcEPKvmiPFvPvES2_"]
    pub fn SkDataTable_MakeArrayProc(
        array: *const ::core::ffi::c_void,
        elemSize: usize,
        count: ::std::os::raw::c_int,
        proc_: SkDataTable_FreeProc,
        context: *mut ::core::ffi::c_void,
    ) -> sk_sp<SkDataTable>;
}
impl SkDataTable {
    #[inline]
    pub unsafe fn atSize(&self, index: ::std::os::raw::c_int) -> usize {
        SkDataTable_atSize(self, index)
    }
    #[inline]
    pub unsafe fn at(
        &self,
        index: ::std::os::raw::c_int,
        size: *mut usize,
    ) -> *const ::core::ffi::c_void {
        SkDataTable_at(self, index, size)
    }
    #[inline]
    pub unsafe fn MakeEmpty() -> sk_sp<SkDataTable> {
        SkDataTable_MakeEmpty()
    }
    #[inline]
    pub unsafe fn MakeCopyArrays(
        ptrs: *const *const ::core::ffi::c_void,
        sizes: *const usize,
        count: ::std::os::raw::c_int,
    ) -> sk_sp<SkDataTable> {
        SkDataTable_MakeCopyArrays(ptrs, sizes, count)
    }
    #[inline]
    pub unsafe fn MakeCopyArray(
        array: *const ::core::ffi::c_void,
        elemSize: usize,
        count: ::std::os::raw::c_int,
    ) -> sk_sp<SkDataTable> {
        SkDataTable_MakeCopyArray(array, elemSize, count)
    }
    #[inline]
    pub unsafe fn MakeArrayProc(
        array: *const ::core::ffi::c_void,
        elemSize: usize,
        count: ::std::os::raw::c_int,
        proc_: SkDataTable_FreeProc,
        context: *mut ::core::ffi::c_void,
    ) -> sk_sp<SkDataTable> {
        SkDataTable_MakeArrayProc(array, elemSize, count, proc_, context)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkSurfaceCharacterization {
    pub fSurfaceProps: SkSurfaceProps,
}
#[test]
fn bindgen_test_layout_SkSurfaceCharacterization() {
    assert_eq!(
        ::core::mem::size_of::<SkSurfaceCharacterization>(),
        8usize,
        concat!("Size of: ", stringify!(SkSurfaceCharacterization))
    );
    assert_eq!(
        ::core::mem::align_of::<SkSurfaceCharacterization>(),
        4usize,
        concat!("Alignment of ", stringify!(SkSurfaceCharacterization))
    );
    fn test_field_fSurfaceProps() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkSurfaceCharacterization>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fSurfaceProps) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SkSurfaceCharacterization),
                "::",
                stringify!(fSurfaceProps)
            )
        );
    }
    test_field_fSurfaceProps();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkDeferredDisplayListPriv {
    _unused: [u8; 0],
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct SkDeferredDisplayList {
    pub _bindgen_opaque_blob: [u32; 3usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkDeferredDisplayList_LazyProxyData {
    pub _base: SkRefCnt,
}
#[test]
fn bindgen_test_layout_SkDeferredDisplayList_LazyProxyData() {
    assert_eq!(
        ::core::mem::size_of::<SkDeferredDisplayList_LazyProxyData>(),
        16usize,
        concat!("Size of: ", stringify!(SkDeferredDisplayList_LazyProxyData))
    );
    assert_eq!(
        ::core::mem::align_of::<SkDeferredDisplayList_LazyProxyData>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(SkDeferredDisplayList_LazyProxyData)
        )
    );
}
#[test]
fn bindgen_test_layout_SkDeferredDisplayList() {
    assert_eq!(
        ::core::mem::size_of::<SkDeferredDisplayList>(),
        12usize,
        concat!("Size of: ", stringify!(SkDeferredDisplayList))
    );
    assert_eq!(
        ::core::mem::align_of::<SkDeferredDisplayList>(),
        4usize,
        concat!("Alignment of ", stringify!(SkDeferredDisplayList))
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN21SkDeferredDisplayListD1Ev"]
    pub fn SkDeferredDisplayList_SkDeferredDisplayList_destructor(this: *mut SkDeferredDisplayList);
}
impl SkDeferredDisplayList {
    #[inline]
    pub unsafe fn destruct(&mut self) {
        SkDeferredDisplayList_SkDeferredDisplayList_destructor(self)
    }
}
impl SkTileMode {
    pub const LastTileMode: SkTileMode = SkTileMode::Decal;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkTileMode {
    Clamp = 0,
    Repeat = 1,
    Mirror = 2,
    Decal = 3,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct SkShader {
    pub _bindgen_opaque_blob: [u64; 2usize],
}
impl SkShader_GradientType {
    pub const Last: SkShader_GradientType = SkShader_GradientType::Conical;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkShader_GradientType {
    None = 0,
    Color = 1,
    Linear = 2,
    Radial = 3,
    Sweep = 4,
    Conical = 5,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkShader_GradientInfo {
    pub fColorCount: ::std::os::raw::c_int,
    pub fColors: *mut SkColor,
    pub fColorOffsets: *mut SkScalar,
    pub fPoint: [SkPoint; 2usize],
    pub fRadius: [SkScalar; 2usize],
    pub fTileMode: SkTileMode,
    pub fGradientFlags: u32,
}
#[test]
fn bindgen_test_layout_SkShader_GradientInfo() {
    assert_eq!(
        ::core::mem::size_of::<SkShader_GradientInfo>(),
        56usize,
        concat!("Size of: ", stringify!(SkShader_GradientInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<SkShader_GradientInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(SkShader_GradientInfo))
    );
    fn test_field_fColorCount() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkShader_GradientInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fColorCount) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SkShader_GradientInfo),
                "::",
                stringify!(fColorCount)
            )
        );
    }
    test_field_fColorCount();
    fn test_field_fColors() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkShader_GradientInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fColors) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(SkShader_GradientInfo),
                "::",
                stringify!(fColors)
            )
        );
    }
    test_field_fColors();
    fn test_field_fColorOffsets() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkShader_GradientInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fColorOffsets) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(SkShader_GradientInfo),
                "::",
                stringify!(fColorOffsets)
            )
        );
    }
    test_field_fColorOffsets();
    fn test_field_fPoint() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkShader_GradientInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fPoint) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(SkShader_GradientInfo),
                "::",
                stringify!(fPoint)
            )
        );
    }
    test_field_fPoint();
    fn test_field_fRadius() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkShader_GradientInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fRadius) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(SkShader_GradientInfo),
                "::",
                stringify!(fRadius)
            )
        );
    }
    test_field_fRadius();
    fn test_field_fTileMode() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkShader_GradientInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fTileMode) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(SkShader_GradientInfo),
                "::",
                stringify!(fTileMode)
            )
        );
    }
    test_field_fTileMode();
    fn test_field_fGradientFlags() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkShader_GradientInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fGradientFlags) as usize - ptr as usize
            },
            52usize,
            concat!(
                "Offset of field: ",
                stringify!(SkShader_GradientInfo),
                "::",
                stringify!(fGradientFlags)
            )
        );
    }
    test_field_fGradientFlags();
}
pub type SkShader_INHERITED = SkFlattenable;
#[test]
fn bindgen_test_layout_SkShader() {
    assert_eq!(
        ::core::mem::size_of::<SkShader>(),
        16usize,
        concat!("Size of: ", stringify!(SkShader))
    );
    assert_eq!(
        ::core::mem::align_of::<SkShader>(),
        8usize,
        concat!("Alignment of ", stringify!(SkShader))
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkShader8isAImageEP8SkMatrixP10SkTileMode"]
    pub fn SkShader_isAImage(
        this: *const SkShader,
        localMatrix: *mut SkMatrix,
        xy: *mut SkTileMode,
    ) -> *mut SkImage;
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkShader19makeWithLocalMatrixERK8SkMatrix"]
    pub fn SkShader_makeWithLocalMatrix(
        this: *const SkShader,
        arg1: *const SkMatrix,
    ) -> sk_sp<SkShader>;
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkShader19makeWithColorFilterE5sk_spI13SkColorFilterE"]
    pub fn SkShader_makeWithColorFilter(
        this: *const SkShader,
        arg1: sk_sp<SkColorFilter>,
    ) -> sk_sp<SkShader>;
}
impl SkShader {
    #[inline]
    pub unsafe fn isAImage(&self, localMatrix: *mut SkMatrix, xy: *mut SkTileMode) -> *mut SkImage {
        SkShader_isAImage(self, localMatrix, xy)
    }
    #[inline]
    pub unsafe fn makeWithLocalMatrix(&self, arg1: *const SkMatrix) -> sk_sp<SkShader> {
        SkShader_makeWithLocalMatrix(self, arg1)
    }
    #[inline]
    pub unsafe fn makeWithColorFilter(&self, arg1: sk_sp<SkColorFilter>) -> sk_sp<SkShader> {
        SkShader_makeWithColorFilter(self, arg1)
    }
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkShader11asAGradientEPNS_12GradientInfoE"]
    pub fn SkShader_asAGradient(
        this: *mut ::core::ffi::c_void,
        info: *mut SkShader_GradientInfo,
    ) -> SkShader_GradientType;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GrBackendTexture {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GrDirectContext {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkMipmap {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct SkImage {
    pub _base: SkRefCnt,
    pub fInfo: SkImageInfo,
    pub fUniqueID: u32,
}
pub type SkImage_ReleaseContext = *mut ::core::ffi::c_void;
pub type SkImage_RasterReleaseProc = ::core::option::Option<
    unsafe extern "C" fn(pixels: *const ::core::ffi::c_void, arg1: SkImage_ReleaseContext),
>;
impl SkImage_CompressionType {
    pub const Last: SkImage_CompressionType = SkImage_CompressionType::BC1_RGBA8_UNORM;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkImage_CompressionType {
    None = 0,
    ETC2_RGB8_UNORM = 1,
    BC1_RGB8_UNORM = 2,
    BC1_RGBA8_UNORM = 3,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkImage_BitDepth {
    U8 = 0,
    F16 = 1,
}
pub type SkImage_CubicResampler = SkCubicResampler;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkImage_CachingHint {
    Allow = 0,
    Disallow = 1,
}
#[repr(C)]
pub struct SkImage_AsyncReadResult__bindgen_vtable(::core::ffi::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct SkImage_AsyncReadResult {
    pub vtable_: *const SkImage_AsyncReadResult__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_SkImage_AsyncReadResult() {
    assert_eq!(
        ::core::mem::size_of::<SkImage_AsyncReadResult>(),
        8usize,
        concat!("Size of: ", stringify!(SkImage_AsyncReadResult))
    );
    assert_eq!(
        ::core::mem::align_of::<SkImage_AsyncReadResult>(),
        8usize,
        concat!("Alignment of ", stringify!(SkImage_AsyncReadResult))
    );
}
pub type SkImage_ReadPixelsContext = *mut ::core::ffi::c_void;
pub type SkImage_ReadPixelsCallback =
    ::core::option::Option<unsafe extern "C" fn(arg1: SkImage_ReadPixelsContext, arg2: u8)>;
#[repr(u8)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkImage_RescaleGamma {
    kSrc = 0,
    kLinear = 1,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkImage_RescaleMode {
    kNearest = 0,
    kRepeatedLinear = 1,
    kRepeatedCubic = 2,
}
pub type SkImage_BackendTextureReleaseProc = u8;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkImage_LegacyBitmapMode {
    kRO_LegacyBitmapMode = 0,
}
pub type SkImage_INHERITED = SkRefCnt;
pub const SkImage_kCompressionTypeCount: ::std::os::raw::c_int = 4;
extern "C" {
    #[link_name = "\u{1}__ZN7SkImage21kETC1_CompressionTypeE"]
    pub static SkImage_kETC1_CompressionType: SkImage_CompressionType;
}
#[test]
fn bindgen_test_layout_SkImage() {
    assert_eq!(
        ::core::mem::size_of::<SkImage>(),
        48usize,
        concat!("Size of: ", stringify!(SkImage))
    );
    assert_eq!(
        ::core::mem::align_of::<SkImage>(),
        8usize,
        concat!("Alignment of ", stringify!(SkImage))
    );
    fn test_field_fInfo() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkImage>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fInfo) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(SkImage),
                "::",
                stringify!(fInfo)
            )
        );
    }
    test_field_fInfo();
    fn test_field_fUniqueID() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkImage>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fUniqueID) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(SkImage),
                "::",
                stringify!(fUniqueID)
            )
        );
    }
    test_field_fUniqueID();
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkImage14MakeRasterCopyERK8SkPixmap"]
    pub fn SkImage_MakeRasterCopy(pixmap: *const SkPixmap) -> sk_sp<SkImage>;
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkImage14MakeRasterDataERK11SkImageInfo5sk_spI6SkDataEm"]
    pub fn SkImage_MakeRasterData(
        info: *const SkImageInfo,
        pixels: sk_sp<SkData>,
        rowBytes: usize,
    ) -> sk_sp<SkImage>;
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkImage14MakeFromRasterERK8SkPixmapPFvPKvPvES5_"]
    pub fn SkImage_MakeFromRaster(
        pixmap: *const SkPixmap,
        rasterReleaseProc: SkImage_RasterReleaseProc,
        releaseContext: SkImage_ReleaseContext,
    ) -> sk_sp<SkImage>;
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkImage14MakeFromBitmapERK8SkBitmap"]
    pub fn SkImage_MakeFromBitmap(bitmap: *const SkBitmap) -> sk_sp<SkImage>;
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkImage17MakeFromGeneratorENSt3__110unique_ptrI16SkImageGeneratorNS0_14default_deleteIS2_EEEE"]
    pub fn SkImage_MakeFromGenerator(imageGenerator: u64) -> sk_sp<SkImage>;
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkImage15MakeFromEncodedE5sk_spI6SkDataENSt3__18optionalI11SkAlphaTypeEE"]
    pub fn SkImage_MakeFromEncoded(
        encoded: sk_sp<SkData>,
        alphaType: [u32; 2usize],
    ) -> sk_sp<SkImage>;
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkImage24MakeRasterFromCompressedE5sk_spI6SkDataEiiNS_15CompressionTypeE"]
    pub fn SkImage_MakeRasterFromCompressed(
        data: sk_sp<SkData>,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        type_: SkImage_CompressionType,
    ) -> sk_sp<SkImage>;
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkImage15MakeFromPictureE5sk_spI9SkPictureERK7SkISizePK8SkMatrixPK7SkPaintNS_8BitDepthES0_I12SkColorSpaceE14SkSurfaceProps"]
    pub fn SkImage_MakeFromPicture(
        picture: sk_sp<SkPicture>,
        dimensions: *const SkISize,
        matrix: *const SkMatrix,
        paint: *const SkPaint,
        bitDepth: SkImage_BitDepth,
        colorSpace: sk_sp<SkColorSpace>,
        props: SkSurfaceProps,
    ) -> sk_sp<SkImage>;
}
extern "C" {
    #[link_name = "\u{1}__ZNK7SkImage9alphaTypeEv"]
    pub fn SkImage_alphaType(this: *const SkImage) -> SkAlphaType;
}
extern "C" {
    #[link_name = "\u{1}__ZNK7SkImage9colorTypeEv"]
    pub fn SkImage_colorType(this: *const SkImage) -> SkColorType;
}
extern "C" {
    #[link_name = "\u{1}__ZNK7SkImage10colorSpaceEv"]
    pub fn SkImage_colorSpace(this: *const SkImage) -> *mut SkColorSpace;
}
extern "C" {
    #[link_name = "\u{1}__ZNK7SkImage13refColorSpaceEv"]
    pub fn SkImage_refColorSpace(this: *const SkImage) -> sk_sp<SkColorSpace>;
}
extern "C" {
    #[link_name = "\u{1}__ZNK7SkImage11isAlphaOnlyEv"]
    pub fn SkImage_isAlphaOnly(this: *const SkImage) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK7SkImage10makeShaderE10SkTileModeS0_RK17SkSamplingOptionsPK8SkMatrix"]
    pub fn SkImage_makeShader(
        this: *const SkImage,
        tmx: SkTileMode,
        tmy: SkTileMode,
        arg1: *const SkSamplingOptions,
        localMatrix: *const SkMatrix,
    ) -> sk_sp<SkShader>;
}
extern "C" {
    #[link_name = "\u{1}__ZNK7SkImage13makeRawShaderE10SkTileModeS0_RK17SkSamplingOptionsPK8SkMatrix"]
    pub fn SkImage_makeRawShader(
        this: *const SkImage,
        tmx: SkTileMode,
        tmy: SkTileMode,
        arg1: *const SkSamplingOptions,
        localMatrix: *const SkMatrix,
    ) -> sk_sp<SkShader>;
}
extern "C" {
    #[link_name = "\u{1}__ZNK7SkImage10peekPixelsEP8SkPixmap"]
    pub fn SkImage_peekPixels(this: *const SkImage, pixmap: *mut SkPixmap) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK7SkImage15isTextureBackedEv"]
    pub fn SkImage_isTextureBacked(this: *const SkImage) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK7SkImage7isValidEP18GrRecordingContext"]
    pub fn SkImage_isValid(this: *const SkImage, context: *mut GrRecordingContext) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK7SkImage10readPixelsEP15GrDirectContextRK11SkImageInfoPvmiiNS_11CachingHintE"]
    pub fn SkImage_readPixels(
        this: *const SkImage,
        context: *mut GrDirectContext,
        dstInfo: *const SkImageInfo,
        dstPixels: *mut ::core::ffi::c_void,
        dstRowBytes: usize,
        srcX: ::std::os::raw::c_int,
        srcY: ::std::os::raw::c_int,
        cachingHint: SkImage_CachingHint,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK7SkImage10readPixelsEP15GrDirectContextRK8SkPixmapiiNS_11CachingHintE"]
    pub fn SkImage_readPixels1(
        this: *const SkImage,
        context: *mut GrDirectContext,
        dst: *const SkPixmap,
        srcX: ::std::os::raw::c_int,
        srcY: ::std::os::raw::c_int,
        cachingHint: SkImage_CachingHint,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK7SkImage10readPixelsERK11SkImageInfoPvmiiNS_11CachingHintE"]
    pub fn SkImage_readPixels2(
        this: *const SkImage,
        dstInfo: *const SkImageInfo,
        dstPixels: *mut ::core::ffi::c_void,
        dstRowBytes: usize,
        srcX: ::std::os::raw::c_int,
        srcY: ::std::os::raw::c_int,
        cachingHint: SkImage_CachingHint,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK7SkImage10readPixelsERK8SkPixmapiiNS_11CachingHintE"]
    pub fn SkImage_readPixels3(
        this: *const SkImage,
        dst: *const SkPixmap,
        srcX: ::std::os::raw::c_int,
        srcY: ::std::os::raw::c_int,
        cachingHint: SkImage_CachingHint,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK7SkImage25asyncRescaleAndReadPixelsERK11SkImageInfoRK7SkIRectNS_12RescaleGammaENS_11RescaleModeEPFvPvNSt3__110unique_ptrIKNS_15AsyncReadResultENS9_14default_deleteISC_EEEEES8_"]
    pub fn SkImage_asyncRescaleAndReadPixels(
        this: *const SkImage,
        info: *const SkImageInfo,
        srcRect: *const SkIRect,
        rescaleGamma: SkImage_RescaleGamma,
        rescaleMode: SkImage_RescaleMode,
        callback: SkImage_ReadPixelsCallback,
        context: SkImage_ReadPixelsContext,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNK7SkImage31asyncRescaleAndReadPixelsYUV420E15SkYUVColorSpace5sk_spI12SkColorSpaceERK7SkIRectRK7SkISizeNS_12RescaleGammaENS_11RescaleModeEPFvPvNSt3__110unique_ptrIKNS_15AsyncReadResultENSD_14default_deleteISG_EEEEESC_"]
    pub fn SkImage_asyncRescaleAndReadPixelsYUV420(
        this: *const SkImage,
        yuvColorSpace: SkYUVColorSpace,
        dstColorSpace: sk_sp<SkColorSpace>,
        srcRect: *const SkIRect,
        dstSize: *const SkISize,
        rescaleGamma: SkImage_RescaleGamma,
        rescaleMode: SkImage_RescaleMode,
        callback: SkImage_ReadPixelsCallback,
        context: SkImage_ReadPixelsContext,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNK7SkImage11scalePixelsERK8SkPixmapRK17SkSamplingOptionsNS_11CachingHintE"]
    pub fn SkImage_scalePixels(
        this: *const SkImage,
        dst: *const SkPixmap,
        arg1: *const SkSamplingOptions,
        cachingHint: SkImage_CachingHint,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK7SkImage12encodeToDataE20SkEncodedImageFormati"]
    pub fn SkImage_encodeToData(
        this: *const SkImage,
        encodedImageFormat: SkEncodedImageFormat,
        quality: ::std::os::raw::c_int,
    ) -> sk_sp<SkData>;
}
extern "C" {
    #[link_name = "\u{1}__ZNK7SkImage12encodeToDataEv"]
    pub fn SkImage_encodeToData1(this: *const SkImage) -> sk_sp<SkData>;
}
extern "C" {
    #[link_name = "\u{1}__ZNK7SkImage14refEncodedDataEv"]
    pub fn SkImage_refEncodedData(this: *const SkImage) -> sk_sp<SkData>;
}
extern "C" {
    #[link_name = "\u{1}__ZNK7SkImage10makeSubsetERK7SkIRectP15GrDirectContext"]
    pub fn SkImage_makeSubset(
        this: *const SkImage,
        subset: *const SkIRect,
        direct: *mut GrDirectContext,
    ) -> sk_sp<SkImage>;
}
extern "C" {
    #[link_name = "\u{1}__ZNK7SkImage10hasMipmapsEv"]
    pub fn SkImage_hasMipmaps(this: *const SkImage) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK7SkImage18withDefaultMipmapsEv"]
    pub fn SkImage_withDefaultMipmaps(this: *const SkImage) -> sk_sp<SkImage>;
}
extern "C" {
    #[link_name = "\u{1}__ZNK7SkImage19makeNonTextureImageEv"]
    pub fn SkImage_makeNonTextureImage(this: *const SkImage) -> sk_sp<SkImage>;
}
extern "C" {
    #[link_name = "\u{1}__ZNK7SkImage15makeRasterImageENS_11CachingHintE"]
    pub fn SkImage_makeRasterImage(
        this: *const SkImage,
        cachingHint: SkImage_CachingHint,
    ) -> sk_sp<SkImage>;
}
extern "C" {
    #[link_name = "\u{1}__ZNK7SkImage14makeWithFilterEP18GrRecordingContextPK13SkImageFilterRK7SkIRectS7_PS5_P8SkIPoint"]
    pub fn SkImage_makeWithFilter(
        this: *const SkImage,
        context: *mut GrRecordingContext,
        filter: *const SkImageFilter,
        subset: *const SkIRect,
        clipBounds: *const SkIRect,
        outSubset: *mut SkIRect,
        offset: *mut SkIPoint,
    ) -> sk_sp<SkImage>;
}
extern "C" {
    #[link_name = "\u{1}__ZNK7SkImage14asLegacyBitmapEP8SkBitmapNS_16LegacyBitmapModeE"]
    pub fn SkImage_asLegacyBitmap(
        this: *const SkImage,
        bitmap: *mut SkBitmap,
        legacyBitmapMode: SkImage_LegacyBitmapMode,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK7SkImage15isLazyGeneratedEv"]
    pub fn SkImage_isLazyGenerated(this: *const SkImage) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK7SkImage14makeColorSpaceE5sk_spI12SkColorSpaceEP15GrDirectContext"]
    pub fn SkImage_makeColorSpace(
        this: *const SkImage,
        target: sk_sp<SkColorSpace>,
        direct: *mut GrDirectContext,
    ) -> sk_sp<SkImage>;
}
extern "C" {
    #[link_name = "\u{1}__ZNK7SkImage26makeColorTypeAndColorSpaceE11SkColorType5sk_spI12SkColorSpaceEP15GrDirectContext"]
    pub fn SkImage_makeColorTypeAndColorSpace(
        this: *const SkImage,
        targetColorType: SkColorType,
        targetColorSpace: sk_sp<SkColorSpace>,
        direct: *mut GrDirectContext,
    ) -> sk_sp<SkImage>;
}
extern "C" {
    #[link_name = "\u{1}__ZNK7SkImage21reinterpretColorSpaceE5sk_spI12SkColorSpaceE"]
    pub fn SkImage_reinterpretColorSpace(
        this: *const SkImage,
        newColorSpace: sk_sp<SkColorSpace>,
    ) -> sk_sp<SkImage>;
}
impl SkImage {
    #[inline]
    pub unsafe fn MakeRasterCopy(pixmap: *const SkPixmap) -> sk_sp<SkImage> {
        SkImage_MakeRasterCopy(pixmap)
    }
    #[inline]
    pub unsafe fn MakeRasterData(
        info: *const SkImageInfo,
        pixels: sk_sp<SkData>,
        rowBytes: usize,
    ) -> sk_sp<SkImage> {
        SkImage_MakeRasterData(info, pixels, rowBytes)
    }
    #[inline]
    pub unsafe fn MakeFromRaster(
        pixmap: *const SkPixmap,
        rasterReleaseProc: SkImage_RasterReleaseProc,
        releaseContext: SkImage_ReleaseContext,
    ) -> sk_sp<SkImage> {
        SkImage_MakeFromRaster(pixmap, rasterReleaseProc, releaseContext)
    }
    #[inline]
    pub unsafe fn MakeFromBitmap(bitmap: *const SkBitmap) -> sk_sp<SkImage> {
        SkImage_MakeFromBitmap(bitmap)
    }
    #[inline]
    pub unsafe fn MakeFromGenerator(imageGenerator: u64) -> sk_sp<SkImage> {
        SkImage_MakeFromGenerator(imageGenerator)
    }
    #[inline]
    pub unsafe fn MakeFromEncoded(
        encoded: sk_sp<SkData>,
        alphaType: [u32; 2usize],
    ) -> sk_sp<SkImage> {
        SkImage_MakeFromEncoded(encoded, alphaType)
    }
    #[inline]
    pub unsafe fn MakeRasterFromCompressed(
        data: sk_sp<SkData>,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        type_: SkImage_CompressionType,
    ) -> sk_sp<SkImage> {
        SkImage_MakeRasterFromCompressed(data, width, height, type_)
    }
    #[inline]
    pub unsafe fn MakeFromPicture(
        picture: sk_sp<SkPicture>,
        dimensions: *const SkISize,
        matrix: *const SkMatrix,
        paint: *const SkPaint,
        bitDepth: SkImage_BitDepth,
        colorSpace: sk_sp<SkColorSpace>,
        props: SkSurfaceProps,
    ) -> sk_sp<SkImage> {
        SkImage_MakeFromPicture(
            picture, dimensions, matrix, paint, bitDepth, colorSpace, props,
        )
    }
    #[inline]
    pub unsafe fn alphaType(&self) -> SkAlphaType {
        SkImage_alphaType(self)
    }
    #[inline]
    pub unsafe fn colorType(&self) -> SkColorType {
        SkImage_colorType(self)
    }
    #[inline]
    pub unsafe fn colorSpace(&self) -> *mut SkColorSpace {
        SkImage_colorSpace(self)
    }
    #[inline]
    pub unsafe fn refColorSpace(&self) -> sk_sp<SkColorSpace> {
        SkImage_refColorSpace(self)
    }
    #[inline]
    pub unsafe fn isAlphaOnly(&self) -> bool {
        SkImage_isAlphaOnly(self)
    }
    #[inline]
    pub unsafe fn makeShader(
        &self,
        tmx: SkTileMode,
        tmy: SkTileMode,
        arg1: *const SkSamplingOptions,
        localMatrix: *const SkMatrix,
    ) -> sk_sp<SkShader> {
        SkImage_makeShader(self, tmx, tmy, arg1, localMatrix)
    }
    #[inline]
    pub unsafe fn makeRawShader(
        &self,
        tmx: SkTileMode,
        tmy: SkTileMode,
        arg1: *const SkSamplingOptions,
        localMatrix: *const SkMatrix,
    ) -> sk_sp<SkShader> {
        SkImage_makeRawShader(self, tmx, tmy, arg1, localMatrix)
    }
    #[inline]
    pub unsafe fn peekPixels(&self, pixmap: *mut SkPixmap) -> bool {
        SkImage_peekPixels(self, pixmap)
    }
    #[inline]
    pub unsafe fn isTextureBacked(&self) -> bool {
        SkImage_isTextureBacked(self)
    }
    #[inline]
    pub unsafe fn isValid(&self, context: *mut GrRecordingContext) -> bool {
        SkImage_isValid(self, context)
    }
    #[inline]
    pub unsafe fn readPixels(
        &self,
        context: *mut GrDirectContext,
        dstInfo: *const SkImageInfo,
        dstPixels: *mut ::core::ffi::c_void,
        dstRowBytes: usize,
        srcX: ::std::os::raw::c_int,
        srcY: ::std::os::raw::c_int,
        cachingHint: SkImage_CachingHint,
    ) -> bool {
        SkImage_readPixels(
            self,
            context,
            dstInfo,
            dstPixels,
            dstRowBytes,
            srcX,
            srcY,
            cachingHint,
        )
    }
    #[inline]
    pub unsafe fn readPixels1(
        &self,
        context: *mut GrDirectContext,
        dst: *const SkPixmap,
        srcX: ::std::os::raw::c_int,
        srcY: ::std::os::raw::c_int,
        cachingHint: SkImage_CachingHint,
    ) -> bool {
        SkImage_readPixels1(self, context, dst, srcX, srcY, cachingHint)
    }
    #[inline]
    pub unsafe fn readPixels2(
        &self,
        dstInfo: *const SkImageInfo,
        dstPixels: *mut ::core::ffi::c_void,
        dstRowBytes: usize,
        srcX: ::std::os::raw::c_int,
        srcY: ::std::os::raw::c_int,
        cachingHint: SkImage_CachingHint,
    ) -> bool {
        SkImage_readPixels2(
            self,
            dstInfo,
            dstPixels,
            dstRowBytes,
            srcX,
            srcY,
            cachingHint,
        )
    }
    #[inline]
    pub unsafe fn readPixels3(
        &self,
        dst: *const SkPixmap,
        srcX: ::std::os::raw::c_int,
        srcY: ::std::os::raw::c_int,
        cachingHint: SkImage_CachingHint,
    ) -> bool {
        SkImage_readPixels3(self, dst, srcX, srcY, cachingHint)
    }
    #[inline]
    pub unsafe fn asyncRescaleAndReadPixels(
        &self,
        info: *const SkImageInfo,
        srcRect: *const SkIRect,
        rescaleGamma: SkImage_RescaleGamma,
        rescaleMode: SkImage_RescaleMode,
        callback: SkImage_ReadPixelsCallback,
        context: SkImage_ReadPixelsContext,
    ) {
        SkImage_asyncRescaleAndReadPixels(
            self,
            info,
            srcRect,
            rescaleGamma,
            rescaleMode,
            callback,
            context,
        )
    }
    #[inline]
    pub unsafe fn asyncRescaleAndReadPixelsYUV420(
        &self,
        yuvColorSpace: SkYUVColorSpace,
        dstColorSpace: sk_sp<SkColorSpace>,
        srcRect: *const SkIRect,
        dstSize: *const SkISize,
        rescaleGamma: SkImage_RescaleGamma,
        rescaleMode: SkImage_RescaleMode,
        callback: SkImage_ReadPixelsCallback,
        context: SkImage_ReadPixelsContext,
    ) {
        SkImage_asyncRescaleAndReadPixelsYUV420(
            self,
            yuvColorSpace,
            dstColorSpace,
            srcRect,
            dstSize,
            rescaleGamma,
            rescaleMode,
            callback,
            context,
        )
    }
    #[inline]
    pub unsafe fn scalePixels(
        &self,
        dst: *const SkPixmap,
        arg1: *const SkSamplingOptions,
        cachingHint: SkImage_CachingHint,
    ) -> bool {
        SkImage_scalePixels(self, dst, arg1, cachingHint)
    }
    #[inline]
    pub unsafe fn encodeToData(
        &self,
        encodedImageFormat: SkEncodedImageFormat,
        quality: ::std::os::raw::c_int,
    ) -> sk_sp<SkData> {
        SkImage_encodeToData(self, encodedImageFormat, quality)
    }
    #[inline]
    pub unsafe fn encodeToData1(&self) -> sk_sp<SkData> {
        SkImage_encodeToData1(self)
    }
    #[inline]
    pub unsafe fn refEncodedData(&self) -> sk_sp<SkData> {
        SkImage_refEncodedData(self)
    }
    #[inline]
    pub unsafe fn makeSubset(
        &self,
        subset: *const SkIRect,
        direct: *mut GrDirectContext,
    ) -> sk_sp<SkImage> {
        SkImage_makeSubset(self, subset, direct)
    }
    #[inline]
    pub unsafe fn hasMipmaps(&self) -> bool {
        SkImage_hasMipmaps(self)
    }
    #[inline]
    pub unsafe fn withDefaultMipmaps(&self) -> sk_sp<SkImage> {
        SkImage_withDefaultMipmaps(self)
    }
    #[inline]
    pub unsafe fn makeNonTextureImage(&self) -> sk_sp<SkImage> {
        SkImage_makeNonTextureImage(self)
    }
    #[inline]
    pub unsafe fn makeRasterImage(&self, cachingHint: SkImage_CachingHint) -> sk_sp<SkImage> {
        SkImage_makeRasterImage(self, cachingHint)
    }
    #[inline]
    pub unsafe fn makeWithFilter(
        &self,
        context: *mut GrRecordingContext,
        filter: *const SkImageFilter,
        subset: *const SkIRect,
        clipBounds: *const SkIRect,
        outSubset: *mut SkIRect,
        offset: *mut SkIPoint,
    ) -> sk_sp<SkImage> {
        SkImage_makeWithFilter(self, context, filter, subset, clipBounds, outSubset, offset)
    }
    #[inline]
    pub unsafe fn asLegacyBitmap(
        &self,
        bitmap: *mut SkBitmap,
        legacyBitmapMode: SkImage_LegacyBitmapMode,
    ) -> bool {
        SkImage_asLegacyBitmap(self, bitmap, legacyBitmapMode)
    }
    #[inline]
    pub unsafe fn isLazyGenerated(&self) -> bool {
        SkImage_isLazyGenerated(self)
    }
    #[inline]
    pub unsafe fn makeColorSpace(
        &self,
        target: sk_sp<SkColorSpace>,
        direct: *mut GrDirectContext,
    ) -> sk_sp<SkImage> {
        SkImage_makeColorSpace(self, target, direct)
    }
    #[inline]
    pub unsafe fn makeColorTypeAndColorSpace(
        &self,
        targetColorType: SkColorType,
        targetColorSpace: sk_sp<SkColorSpace>,
        direct: *mut GrDirectContext,
    ) -> sk_sp<SkImage> {
        SkImage_makeColorTypeAndColorSpace(self, targetColorType, targetColorSpace, direct)
    }
    #[inline]
    pub unsafe fn reinterpretColorSpace(
        &self,
        newColorSpace: sk_sp<SkColorSpace>,
    ) -> sk_sp<SkImage> {
        SkImage_reinterpretColorSpace(self, newColorSpace)
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct SkDeferredDisplayListRecorder {
    pub fCharacterization: SkSurfaceCharacterization,
}
#[test]
fn bindgen_test_layout_SkDeferredDisplayListRecorder() {
    assert_eq!(
        ::core::mem::size_of::<SkDeferredDisplayListRecorder>(),
        8usize,
        concat!("Size of: ", stringify!(SkDeferredDisplayListRecorder))
    );
    assert_eq!(
        ::core::mem::align_of::<SkDeferredDisplayListRecorder>(),
        4usize,
        concat!("Alignment of ", stringify!(SkDeferredDisplayListRecorder))
    );
    fn test_field_fCharacterization() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkDeferredDisplayListRecorder>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fCharacterization) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SkDeferredDisplayListRecorder),
                "::",
                stringify!(fCharacterization)
            )
        );
    }
    test_field_fCharacterization();
}
extern "C" {
    #[link_name = "\u{1}__ZN29SkDeferredDisplayListRecorder9getCanvasEv"]
    pub fn SkDeferredDisplayListRecorder_getCanvas(
        this: *mut SkDeferredDisplayListRecorder,
    ) -> *mut SkCanvas;
}
extern "C" {
    #[link_name = "\u{1}__ZN29SkDeferredDisplayListRecorder6detachEv"]
    pub fn SkDeferredDisplayListRecorder_detach(
        this: *mut SkDeferredDisplayListRecorder,
    ) -> sk_sp<SkDeferredDisplayList>;
}
extern "C" {
    #[link_name = "\u{1}__ZN29SkDeferredDisplayListRecorderC1ERK25SkSurfaceCharacterization"]
    pub fn SkDeferredDisplayListRecorder_SkDeferredDisplayListRecorder(
        this: *mut SkDeferredDisplayListRecorder,
        arg1: *const SkSurfaceCharacterization,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN29SkDeferredDisplayListRecorderD1Ev"]
    pub fn SkDeferredDisplayListRecorder_SkDeferredDisplayListRecorder_destructor(
        this: *mut SkDeferredDisplayListRecorder,
    );
}
impl SkDeferredDisplayListRecorder {
    #[inline]
    pub unsafe fn getCanvas(&mut self) -> *mut SkCanvas {
        SkDeferredDisplayListRecorder_getCanvas(self)
    }
    #[inline]
    pub unsafe fn detach(&mut self) -> sk_sp<SkDeferredDisplayList> {
        SkDeferredDisplayListRecorder_detach(self)
    }
    #[inline]
    pub unsafe fn new(arg1: *const SkSurfaceCharacterization) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkDeferredDisplayListRecorder_SkDeferredDisplayListRecorder(
            __bindgen_tmp.as_mut_ptr(),
            arg1,
        );
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        SkDeferredDisplayListRecorder_SkDeferredDisplayListRecorder_destructor(self)
    }
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct SkDrawable {
    pub _bindgen_opaque_blob: [u64; 2usize],
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct SkDrawable_GpuDrawHandler {
    pub _bindgen_opaque_blob: u64,
}
#[test]
fn bindgen_test_layout_SkDrawable_GpuDrawHandler() {
    assert_eq!(
        ::core::mem::size_of::<SkDrawable_GpuDrawHandler>(),
        8usize,
        concat!("Size of: ", stringify!(SkDrawable_GpuDrawHandler))
    );
    assert_eq!(
        ::core::mem::align_of::<SkDrawable_GpuDrawHandler>(),
        8usize,
        concat!("Alignment of ", stringify!(SkDrawable_GpuDrawHandler))
    );
}
#[test]
fn bindgen_test_layout_SkDrawable() {
    assert_eq!(
        ::core::mem::size_of::<SkDrawable>(),
        16usize,
        concat!("Size of: ", stringify!(SkDrawable))
    );
    assert_eq!(
        ::core::mem::align_of::<SkDrawable>(),
        8usize,
        concat!("Alignment of ", stringify!(SkDrawable))
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkDrawable4drawEP8SkCanvasPK8SkMatrix"]
    pub fn SkDrawable_draw(this: *mut SkDrawable, arg1: *mut SkCanvas, arg2: *const SkMatrix);
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkDrawable4drawEP8SkCanvasff"]
    pub fn SkDrawable_draw1(this: *mut SkDrawable, arg1: *mut SkCanvas, x: SkScalar, y: SkScalar);
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkDrawable18newPictureSnapshotEv"]
    pub fn SkDrawable_newPictureSnapshot(this: *mut SkDrawable) -> *mut SkPicture;
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkDrawable15getGenerationIDEv"]
    pub fn SkDrawable_getGenerationID(this: *mut SkDrawable) -> u32;
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkDrawable9getBoundsEv"]
    pub fn SkDrawable_getBounds(this: *mut SkDrawable) -> SkRect;
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkDrawable20approximateBytesUsedEv"]
    pub fn SkDrawable_approximateBytesUsed(this: *mut SkDrawable) -> usize;
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkDrawable20notifyDrawingChangedEv"]
    pub fn SkDrawable_notifyDrawingChanged(this: *mut SkDrawable);
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkDrawableC2Ev"]
    pub fn SkDrawable_SkDrawable(this: *mut SkDrawable);
}
impl SkDrawable {
    #[inline]
    pub unsafe fn draw(&mut self, arg1: *mut SkCanvas, arg2: *const SkMatrix) {
        SkDrawable_draw(self, arg1, arg2)
    }
    #[inline]
    pub unsafe fn draw1(&mut self, arg1: *mut SkCanvas, x: SkScalar, y: SkScalar) {
        SkDrawable_draw1(self, arg1, x, y)
    }
    #[inline]
    pub unsafe fn newPictureSnapshot(&mut self) -> *mut SkPicture {
        SkDrawable_newPictureSnapshot(self)
    }
    #[inline]
    pub unsafe fn getGenerationID(&mut self) -> u32 {
        SkDrawable_getGenerationID(self)
    }
    #[inline]
    pub unsafe fn getBounds(&mut self) -> SkRect {
        SkDrawable_getBounds(self)
    }
    #[inline]
    pub unsafe fn approximateBytesUsed(&mut self) -> usize {
        SkDrawable_approximateBytesUsed(self)
    }
    #[inline]
    pub unsafe fn notifyDrawingChanged(&mut self) {
        SkDrawable_notifyDrawingChanged(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkDrawable_SkDrawable(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkDrawable22onApproximateBytesUsedEv"]
    pub fn SkDrawable_onApproximateBytesUsed(this: *mut ::core::ffi::c_void) -> usize;
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkDrawable20onNewPictureSnapshotEv"]
    pub fn SkDrawable_onNewPictureSnapshot(this: *mut ::core::ffi::c_void) -> *mut SkPicture;
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct SkDocument {
    pub _bindgen_opaque_blob: [u64; 4usize],
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkDocument_State {
    kBetweenPages_State = 0,
    kInPage_State = 1,
    kClosed_State = 2,
}
pub type SkDocument_INHERITED = SkRefCnt;
#[test]
fn bindgen_test_layout_SkDocument() {
    assert_eq!(
        ::core::mem::size_of::<SkDocument>(),
        32usize,
        concat!("Size of: ", stringify!(SkDocument))
    );
    assert_eq!(
        ::core::mem::align_of::<SkDocument>(),
        8usize,
        concat!("Alignment of ", stringify!(SkDocument))
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkDocument9beginPageEffPK6SkRect"]
    pub fn SkDocument_beginPage(
        this: *mut SkDocument,
        width: SkScalar,
        height: SkScalar,
        content: *const SkRect,
    ) -> *mut SkCanvas;
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkDocument7endPageEv"]
    pub fn SkDocument_endPage(this: *mut SkDocument);
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkDocument5closeEv"]
    pub fn SkDocument_close(this: *mut SkDocument);
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkDocument5abortEv"]
    pub fn SkDocument_abort(this: *mut SkDocument);
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkDocumentC2EP9SkWStream"]
    pub fn SkDocument_SkDocument(this: *mut SkDocument, arg1: *mut SkWStream);
}
impl SkDocument {
    #[inline]
    pub unsafe fn beginPage(
        &mut self,
        width: SkScalar,
        height: SkScalar,
        content: *const SkRect,
    ) -> *mut SkCanvas {
        SkDocument_beginPage(self, width, height, content)
    }
    #[inline]
    pub unsafe fn endPage(&mut self) {
        SkDocument_endPage(self)
    }
    #[inline]
    pub unsafe fn close(&mut self) {
        SkDocument_close(self)
    }
    #[inline]
    pub unsafe fn abort(&mut self) {
        SkDocument_abort(self)
    }
    #[inline]
    pub unsafe fn new(arg1: *mut SkWStream) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkDocument_SkDocument(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkDocumentD1Ev"]
    pub fn SkDocument_SkDocument_destructor(this: *mut SkDocument);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkFontArguments {
    pub fCollectionIndex: ::std::os::raw::c_int,
    pub fVariationDesignPosition: SkFontArguments_VariationPosition,
    pub fPalette: SkFontArguments_Palette,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkFontArguments_VariationPosition {
    pub coordinates: *const SkFontArguments_VariationPosition_Coordinate,
    pub coordinateCount: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkFontArguments_VariationPosition_Coordinate {
    pub axis: SkFourByteTag,
    pub value: f32,
}
#[test]
fn bindgen_test_layout_SkFontArguments_VariationPosition_Coordinate() {
    assert_eq!(
        ::core::mem::size_of::<SkFontArguments_VariationPosition_Coordinate>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(SkFontArguments_VariationPosition_Coordinate)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<SkFontArguments_VariationPosition_Coordinate>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(SkFontArguments_VariationPosition_Coordinate)
        )
    );
    fn test_field_axis() {
        assert_eq!(
            unsafe {
                let uninit = :: core :: mem :: MaybeUninit :: < SkFontArguments_VariationPosition_Coordinate > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).axis) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SkFontArguments_VariationPosition_Coordinate),
                "::",
                stringify!(axis)
            )
        );
    }
    test_field_axis();
    fn test_field_value() {
        assert_eq!(
            unsafe {
                let uninit = :: core :: mem :: MaybeUninit :: < SkFontArguments_VariationPosition_Coordinate > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).value) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(SkFontArguments_VariationPosition_Coordinate),
                "::",
                stringify!(value)
            )
        );
    }
    test_field_value();
}
#[test]
fn bindgen_test_layout_SkFontArguments_VariationPosition() {
    assert_eq!(
        ::core::mem::size_of::<SkFontArguments_VariationPosition>(),
        16usize,
        concat!("Size of: ", stringify!(SkFontArguments_VariationPosition))
    );
    assert_eq!(
        ::core::mem::align_of::<SkFontArguments_VariationPosition>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(SkFontArguments_VariationPosition)
        )
    );
    fn test_field_coordinates() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::core::mem::MaybeUninit::<SkFontArguments_VariationPosition>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).coordinates) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SkFontArguments_VariationPosition),
                "::",
                stringify!(coordinates)
            )
        );
    }
    test_field_coordinates();
    fn test_field_coordinateCount() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::core::mem::MaybeUninit::<SkFontArguments_VariationPosition>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).coordinateCount) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(SkFontArguments_VariationPosition),
                "::",
                stringify!(coordinateCount)
            )
        );
    }
    test_field_coordinateCount();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkFontArguments_Palette {
    pub index: ::std::os::raw::c_int,
    pub overrides: *const SkFontArguments_Palette_Override,
    pub overrideCount: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkFontArguments_Palette_Override {
    pub index: ::std::os::raw::c_int,
    pub color: SkColor,
}
#[test]
fn bindgen_test_layout_SkFontArguments_Palette_Override() {
    assert_eq!(
        ::core::mem::size_of::<SkFontArguments_Palette_Override>(),
        8usize,
        concat!("Size of: ", stringify!(SkFontArguments_Palette_Override))
    );
    assert_eq!(
        ::core::mem::align_of::<SkFontArguments_Palette_Override>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(SkFontArguments_Palette_Override)
        )
    );
    fn test_field_index() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkFontArguments_Palette_Override>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).index) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SkFontArguments_Palette_Override),
                "::",
                stringify!(index)
            )
        );
    }
    test_field_index();
    fn test_field_color() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkFontArguments_Palette_Override>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).color) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(SkFontArguments_Palette_Override),
                "::",
                stringify!(color)
            )
        );
    }
    test_field_color();
}
#[test]
fn bindgen_test_layout_SkFontArguments_Palette() {
    assert_eq!(
        ::core::mem::size_of::<SkFontArguments_Palette>(),
        24usize,
        concat!("Size of: ", stringify!(SkFontArguments_Palette))
    );
    assert_eq!(
        ::core::mem::align_of::<SkFontArguments_Palette>(),
        8usize,
        concat!("Alignment of ", stringify!(SkFontArguments_Palette))
    );
    fn test_field_index() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkFontArguments_Palette>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).index) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SkFontArguments_Palette),
                "::",
                stringify!(index)
            )
        );
    }
    test_field_index();
    fn test_field_overrides() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkFontArguments_Palette>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).overrides) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(SkFontArguments_Palette),
                "::",
                stringify!(overrides)
            )
        );
    }
    test_field_overrides();
    fn test_field_overrideCount() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkFontArguments_Palette>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).overrideCount) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(SkFontArguments_Palette),
                "::",
                stringify!(overrideCount)
            )
        );
    }
    test_field_overrideCount();
}
#[test]
fn bindgen_test_layout_SkFontArguments() {
    assert_eq!(
        ::core::mem::size_of::<SkFontArguments>(),
        48usize,
        concat!("Size of: ", stringify!(SkFontArguments))
    );
    assert_eq!(
        ::core::mem::align_of::<SkFontArguments>(),
        8usize,
        concat!("Alignment of ", stringify!(SkFontArguments))
    );
    fn test_field_fCollectionIndex() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkFontArguments>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fCollectionIndex) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SkFontArguments),
                "::",
                stringify!(fCollectionIndex)
            )
        );
    }
    test_field_fCollectionIndex();
    fn test_field_fVariationDesignPosition() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkFontArguments>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fVariationDesignPosition) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(SkFontArguments),
                "::",
                stringify!(fVariationDesignPosition)
            )
        );
    }
    test_field_fVariationDesignPosition();
    fn test_field_fPalette() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkFontArguments>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fPalette) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(SkFontArguments),
                "::",
                stringify!(fPalette)
            )
        );
    }
    test_field_fPalette();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkFontParameters_Variation_Axis {
    pub tag: SkFourByteTag,
    pub min: f32,
    pub def: f32,
    pub max: f32,
    pub flags: u16,
}
pub const SkFontParameters_Variation_Axis_HIDDEN: u16 = 1;
#[test]
fn bindgen_test_layout_SkFontParameters_Variation_Axis() {
    assert_eq!(
        ::core::mem::size_of::<SkFontParameters_Variation_Axis>(),
        20usize,
        concat!("Size of: ", stringify!(SkFontParameters_Variation_Axis))
    );
    assert_eq!(
        ::core::mem::align_of::<SkFontParameters_Variation_Axis>(),
        4usize,
        concat!("Alignment of ", stringify!(SkFontParameters_Variation_Axis))
    );
    fn test_field_tag() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkFontParameters_Variation_Axis>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).tag) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SkFontParameters_Variation_Axis),
                "::",
                stringify!(tag)
            )
        );
    }
    test_field_tag();
    fn test_field_min() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkFontParameters_Variation_Axis>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).min) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(SkFontParameters_Variation_Axis),
                "::",
                stringify!(min)
            )
        );
    }
    test_field_min();
    fn test_field_def() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkFontParameters_Variation_Axis>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).def) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(SkFontParameters_Variation_Axis),
                "::",
                stringify!(def)
            )
        );
    }
    test_field_def();
    fn test_field_max() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkFontParameters_Variation_Axis>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).max) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(SkFontParameters_Variation_Axis),
                "::",
                stringify!(max)
            )
        );
    }
    test_field_max();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkFontParameters_Variation_Axis>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(SkFontParameters_Variation_Axis),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkFontStyle {
    pub fValue: i32,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkFontStyle_Weight {
    kInvisible_Weight = 0,
    kThin_Weight = 100,
    kExtraLight_Weight = 200,
    kLight_Weight = 300,
    kNormal_Weight = 400,
    kMedium_Weight = 500,
    kSemiBold_Weight = 600,
    kBold_Weight = 700,
    kExtraBold_Weight = 800,
    kBlack_Weight = 900,
    kExtraBlack_Weight = 1000,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkFontStyle_Width {
    kUltraCondensed_Width = 1,
    kExtraCondensed_Width = 2,
    kCondensed_Width = 3,
    kSemiCondensed_Width = 4,
    kNormal_Width = 5,
    kSemiExpanded_Width = 6,
    kExpanded_Width = 7,
    kExtraExpanded_Width = 8,
    kUltraExpanded_Width = 9,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkFontStyle_Slant {
    Upright = 0,
    Italic = 1,
    Oblique = 2,
}
#[test]
fn bindgen_test_layout_SkFontStyle() {
    assert_eq!(
        ::core::mem::size_of::<SkFontStyle>(),
        4usize,
        concat!("Size of: ", stringify!(SkFontStyle))
    );
    assert_eq!(
        ::core::mem::align_of::<SkFontStyle>(),
        4usize,
        concat!("Alignment of ", stringify!(SkFontStyle))
    );
    fn test_field_fValue() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkFontStyle>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fValue) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SkFontStyle),
                "::",
                stringify!(fValue)
            )
        );
    }
    test_field_fValue();
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct SkWeakRefCnt {
    pub _bindgen_opaque_blob: [u64; 2usize],
}
pub type SkWeakRefCnt_INHERITED = SkRefCnt;
#[test]
fn bindgen_test_layout_SkWeakRefCnt() {
    assert_eq!(
        ::core::mem::size_of::<SkWeakRefCnt>(),
        16usize,
        concat!("Size of: ", stringify!(SkWeakRefCnt))
    );
    assert_eq!(
        ::core::mem::align_of::<SkWeakRefCnt>(),
        8usize,
        concat!("Alignment of ", stringify!(SkWeakRefCnt))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkDescriptor {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkFontDescriptor {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkScalerContext {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkAdvancedTypefaceMetrics {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkScalerContextEffects {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkScalerContextRec {
    _unused: [u8; 0],
}
pub type SkTypefaceID = u32;
pub type SkFontTableTag = u32;
#[repr(C)]
#[derive(Debug)]
pub struct SkTypeface {
    pub _base: SkWeakRefCnt,
    pub fUniqueID: SkTypefaceID,
    pub fStyle: SkFontStyle,
    pub fBounds: SkRect,
    pub fBoundsOnce: SkOnce,
    pub fIsFixedPitch: bool,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkTypeface_SerializeBehavior {
    DoIncludeData = 0,
    DontIncludeData = 1,
    IncludeDataIfLocal = 2,
}
#[repr(C)]
#[derive(Debug)]
pub struct SkTypeface_LocalizedString {
    pub fString: SkString,
    pub fLanguage: SkString,
}
#[test]
fn bindgen_test_layout_SkTypeface_LocalizedString() {
    assert_eq!(
        ::core::mem::size_of::<SkTypeface_LocalizedString>(),
        16usize,
        concat!("Size of: ", stringify!(SkTypeface_LocalizedString))
    );
    assert_eq!(
        ::core::mem::align_of::<SkTypeface_LocalizedString>(),
        8usize,
        concat!("Alignment of ", stringify!(SkTypeface_LocalizedString))
    );
    fn test_field_fString() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkTypeface_LocalizedString>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fString) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SkTypeface_LocalizedString),
                "::",
                stringify!(fString)
            )
        );
    }
    test_field_fString();
    fn test_field_fLanguage() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkTypeface_LocalizedString>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fLanguage) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(SkTypeface_LocalizedString),
                "::",
                stringify!(fLanguage)
            )
        );
    }
    test_field_fLanguage();
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct SkTypeface_LocalizedStrings {
    pub _bindgen_opaque_blob: u64,
}
#[test]
fn bindgen_test_layout_SkTypeface_LocalizedStrings() {
    assert_eq!(
        ::core::mem::size_of::<SkTypeface_LocalizedStrings>(),
        8usize,
        concat!("Size of: ", stringify!(SkTypeface_LocalizedStrings))
    );
    assert_eq!(
        ::core::mem::align_of::<SkTypeface_LocalizedStrings>(),
        8usize,
        concat!("Alignment of ", stringify!(SkTypeface_LocalizedStrings))
    );
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkTypeface_Style {
    Normal = 0,
    Bold = 1,
    Italic = 2,
    BoldItalic = 3,
}
pub type SkTypeface_INHERITED = SkWeakRefCnt;
#[test]
fn bindgen_test_layout_SkTypeface() {
    assert_eq!(
        ::core::mem::size_of::<SkTypeface>(),
        48usize,
        concat!("Size of: ", stringify!(SkTypeface))
    );
    assert_eq!(
        ::core::mem::align_of::<SkTypeface>(),
        8usize,
        concat!("Alignment of ", stringify!(SkTypeface))
    );
    fn test_field_fUniqueID() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkTypeface>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fUniqueID) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(SkTypeface),
                "::",
                stringify!(fUniqueID)
            )
        );
    }
    test_field_fUniqueID();
    fn test_field_fStyle() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkTypeface>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fStyle) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(SkTypeface),
                "::",
                stringify!(fStyle)
            )
        );
    }
    test_field_fStyle();
    fn test_field_fBounds() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkTypeface>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fBounds) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(SkTypeface),
                "::",
                stringify!(fBounds)
            )
        );
    }
    test_field_fBounds();
    fn test_field_fBoundsOnce() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkTypeface>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fBoundsOnce) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(SkTypeface),
                "::",
                stringify!(fBoundsOnce)
            )
        );
    }
    test_field_fBoundsOnce();
    fn test_field_fIsFixedPitch() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkTypeface>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fIsFixedPitch) as usize - ptr as usize
            },
            41usize,
            concat!(
                "Offset of field: ",
                stringify!(SkTypeface),
                "::",
                stringify!(fIsFixedPitch)
            )
        );
    }
    test_field_fIsFixedPitch();
}
extern "C" {
    #[link_name = "\u{1}__ZNK10SkTypeface26getVariationDesignPositionEPN15SkFontArguments17VariationPosition10CoordinateEi"]
    pub fn SkTypeface_getVariationDesignPosition(
        this: *const SkTypeface,
        coordinates: *mut SkFontArguments_VariationPosition_Coordinate,
        coordinateCount: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__ZNK10SkTypeface28getVariationDesignParametersEPN16SkFontParameters9Variation4AxisEi"]
    pub fn SkTypeface_getVariationDesignParameters(
        this: *const SkTypeface,
        parameters: *mut SkFontParameters_Variation_Axis,
        parameterCount: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkTypeface8UniqueIDEPKS_"]
    pub fn SkTypeface_UniqueID(face: *const SkTypeface) -> SkTypefaceID;
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkTypeface5EqualEPKS_S1_"]
    pub fn SkTypeface_Equal(facea: *const SkTypeface, faceb: *const SkTypeface) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkTypeface11MakeDefaultEv"]
    pub fn SkTypeface_MakeDefault() -> sk_sp<SkTypeface>;
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkTypeface12MakeFromNameEPKc11SkFontStyle"]
    pub fn SkTypeface_MakeFromName(
        familyName: *const ::std::os::raw::c_char,
        fontStyle: SkFontStyle,
    ) -> sk_sp<SkTypeface>;
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkTypeface12MakeFromFileEPKci"]
    pub fn SkTypeface_MakeFromFile(
        path: *const ::std::os::raw::c_char,
        index: ::std::os::raw::c_int,
    ) -> sk_sp<SkTypeface>;
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkTypeface14MakeFromStreamENSt3__110unique_ptrI13SkStreamAssetNS0_14default_deleteIS2_EEEEi"]
    pub fn SkTypeface_MakeFromStream(
        stream: u64,
        index: ::std::os::raw::c_int,
    ) -> sk_sp<SkTypeface>;
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkTypeface12MakeFromDataE5sk_spI6SkDataEi"]
    pub fn SkTypeface_MakeFromData(
        arg1: sk_sp<SkData>,
        index: ::std::os::raw::c_int,
    ) -> sk_sp<SkTypeface>;
}
extern "C" {
    #[link_name = "\u{1}__ZNK10SkTypeface9makeCloneERK15SkFontArguments"]
    pub fn SkTypeface_makeClone(
        this: *const SkTypeface,
        arg1: *const SkFontArguments,
    ) -> sk_sp<SkTypeface>;
}
extern "C" {
    #[link_name = "\u{1}__ZNK10SkTypeface9serializeEP9SkWStreamNS_17SerializeBehaviorE"]
    pub fn SkTypeface_serialize(
        this: *const SkTypeface,
        arg1: *mut SkWStream,
        arg2: SkTypeface_SerializeBehavior,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNK10SkTypeface9serializeENS_17SerializeBehaviorE"]
    pub fn SkTypeface_serialize1(
        this: *const SkTypeface,
        arg1: SkTypeface_SerializeBehavior,
    ) -> sk_sp<SkData>;
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkTypeface15MakeDeserializeEP8SkStream"]
    pub fn SkTypeface_MakeDeserialize(arg1: *mut SkStream) -> sk_sp<SkTypeface>;
}
extern "C" {
    #[link_name = "\u{1}__ZNK10SkTypeface16unicharsToGlyphsEPKiiPt"]
    pub fn SkTypeface_unicharsToGlyphs(
        this: *const SkTypeface,
        uni: *const SkUnichar,
        count: ::std::os::raw::c_int,
        glyphs: *mut SkGlyphID,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNK10SkTypeface12textToGlyphsEPKvm14SkTextEncodingPti"]
    pub fn SkTypeface_textToGlyphs(
        this: *const SkTypeface,
        text: *const ::core::ffi::c_void,
        byteLength: usize,
        encoding: SkTextEncoding,
        glyphs: *mut SkGlyphID,
        maxGlyphCount: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__ZNK10SkTypeface14unicharToGlyphEi"]
    pub fn SkTypeface_unicharToGlyph(this: *const SkTypeface, unichar: SkUnichar) -> SkGlyphID;
}
extern "C" {
    #[link_name = "\u{1}__ZNK10SkTypeface11countGlyphsEv"]
    pub fn SkTypeface_countGlyphs(this: *const SkTypeface) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__ZNK10SkTypeface11countTablesEv"]
    pub fn SkTypeface_countTables(this: *const SkTypeface) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__ZNK10SkTypeface12getTableTagsEPj"]
    pub fn SkTypeface_getTableTags(
        this: *const SkTypeface,
        tags: *mut SkFontTableTag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__ZNK10SkTypeface12getTableSizeEj"]
    pub fn SkTypeface_getTableSize(this: *const SkTypeface, arg1: SkFontTableTag) -> usize;
}
extern "C" {
    #[link_name = "\u{1}__ZNK10SkTypeface12getTableDataEjmmPv"]
    pub fn SkTypeface_getTableData(
        this: *const SkTypeface,
        tag: SkFontTableTag,
        offset: usize,
        length: usize,
        data: *mut ::core::ffi::c_void,
    ) -> usize;
}
extern "C" {
    #[link_name = "\u{1}__ZNK10SkTypeface13copyTableDataEj"]
    pub fn SkTypeface_copyTableData(this: *const SkTypeface, tag: SkFontTableTag) -> sk_sp<SkData>;
}
extern "C" {
    #[link_name = "\u{1}__ZNK10SkTypeface13getUnitsPerEmEv"]
    pub fn SkTypeface_getUnitsPerEm(this: *const SkTypeface) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__ZNK10SkTypeface25getKerningPairAdjustmentsEPKtiPi"]
    pub fn SkTypeface_getKerningPairAdjustments(
        this: *const SkTypeface,
        glyphs: *const SkGlyphID,
        count: ::std::os::raw::c_int,
        adjustments: *mut i32,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK10SkTypeface24createFamilyNameIteratorEv"]
    pub fn SkTypeface_createFamilyNameIterator(
        this: *const SkTypeface,
    ) -> *mut SkTypeface_LocalizedStrings;
}
extern "C" {
    #[link_name = "\u{1}__ZNK10SkTypeface13getFamilyNameEP8SkString"]
    pub fn SkTypeface_getFamilyName(this: *const SkTypeface, name: *mut SkString);
}
extern "C" {
    #[link_name = "\u{1}__ZNK10SkTypeface17getPostScriptNameEP8SkString"]
    pub fn SkTypeface_getPostScriptName(this: *const SkTypeface, name: *mut SkString) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK10SkTypeface10openStreamEPi"]
    pub fn SkTypeface_openStream(
        this: *const SkTypeface,
        ttcIndex: *mut ::std::os::raw::c_int,
    ) -> u64;
}
extern "C" {
    #[link_name = "\u{1}__ZNK10SkTypeface18openExistingStreamEPi"]
    pub fn SkTypeface_openExistingStream(
        this: *const SkTypeface,
        ttcIndex: *mut ::std::os::raw::c_int,
    ) -> u64;
}
extern "C" {
    #[link_name = "\u{1}__ZNK10SkTypeface19createScalerContextERK22SkScalerContextEffectsPK12SkDescriptor"]
    pub fn SkTypeface_createScalerContext(
        this: *const SkTypeface,
        arg1: *const SkScalerContextEffects,
        arg2: *const SkDescriptor,
    ) -> u8;
}
extern "C" {
    #[link_name = "\u{1}__ZNK10SkTypeface9getBoundsEv"]
    pub fn SkTypeface_getBounds(this: *const SkTypeface) -> SkRect;
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkTypefaceC2ERK11SkFontStyleb"]
    pub fn SkTypeface_SkTypeface(
        this: *mut SkTypeface,
        style: *const SkFontStyle,
        isFixedPitch: bool,
    );
}
impl SkTypeface {
    #[inline]
    pub unsafe fn getVariationDesignPosition(
        &self,
        coordinates: *mut SkFontArguments_VariationPosition_Coordinate,
        coordinateCount: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        SkTypeface_getVariationDesignPosition(self, coordinates, coordinateCount)
    }
    #[inline]
    pub unsafe fn getVariationDesignParameters(
        &self,
        parameters: *mut SkFontParameters_Variation_Axis,
        parameterCount: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        SkTypeface_getVariationDesignParameters(self, parameters, parameterCount)
    }
    #[inline]
    pub unsafe fn UniqueID(face: *const SkTypeface) -> SkTypefaceID {
        SkTypeface_UniqueID(face)
    }
    #[inline]
    pub unsafe fn Equal(facea: *const SkTypeface, faceb: *const SkTypeface) -> bool {
        SkTypeface_Equal(facea, faceb)
    }
    #[inline]
    pub unsafe fn MakeDefault() -> sk_sp<SkTypeface> {
        SkTypeface_MakeDefault()
    }
    #[inline]
    pub unsafe fn MakeFromName(
        familyName: *const ::std::os::raw::c_char,
        fontStyle: SkFontStyle,
    ) -> sk_sp<SkTypeface> {
        SkTypeface_MakeFromName(familyName, fontStyle)
    }
    #[inline]
    pub unsafe fn MakeFromFile(
        path: *const ::std::os::raw::c_char,
        index: ::std::os::raw::c_int,
    ) -> sk_sp<SkTypeface> {
        SkTypeface_MakeFromFile(path, index)
    }
    #[inline]
    pub unsafe fn MakeFromStream(stream: u64, index: ::std::os::raw::c_int) -> sk_sp<SkTypeface> {
        SkTypeface_MakeFromStream(stream, index)
    }
    #[inline]
    pub unsafe fn MakeFromData(
        arg1: sk_sp<SkData>,
        index: ::std::os::raw::c_int,
    ) -> sk_sp<SkTypeface> {
        SkTypeface_MakeFromData(arg1, index)
    }
    #[inline]
    pub unsafe fn makeClone(&self, arg1: *const SkFontArguments) -> sk_sp<SkTypeface> {
        SkTypeface_makeClone(self, arg1)
    }
    #[inline]
    pub unsafe fn serialize(&self, arg1: *mut SkWStream, arg2: SkTypeface_SerializeBehavior) {
        SkTypeface_serialize(self, arg1, arg2)
    }
    #[inline]
    pub unsafe fn serialize1(&self, arg1: SkTypeface_SerializeBehavior) -> sk_sp<SkData> {
        SkTypeface_serialize1(self, arg1)
    }
    #[inline]
    pub unsafe fn MakeDeserialize(arg1: *mut SkStream) -> sk_sp<SkTypeface> {
        SkTypeface_MakeDeserialize(arg1)
    }
    #[inline]
    pub unsafe fn unicharsToGlyphs(
        &self,
        uni: *const SkUnichar,
        count: ::std::os::raw::c_int,
        glyphs: *mut SkGlyphID,
    ) {
        SkTypeface_unicharsToGlyphs(self, uni, count, glyphs)
    }
    #[inline]
    pub unsafe fn textToGlyphs(
        &self,
        text: *const ::core::ffi::c_void,
        byteLength: usize,
        encoding: SkTextEncoding,
        glyphs: *mut SkGlyphID,
        maxGlyphCount: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        SkTypeface_textToGlyphs(self, text, byteLength, encoding, glyphs, maxGlyphCount)
    }
    #[inline]
    pub unsafe fn unicharToGlyph(&self, unichar: SkUnichar) -> SkGlyphID {
        SkTypeface_unicharToGlyph(self, unichar)
    }
    #[inline]
    pub unsafe fn countGlyphs(&self) -> ::std::os::raw::c_int {
        SkTypeface_countGlyphs(self)
    }
    #[inline]
    pub unsafe fn countTables(&self) -> ::std::os::raw::c_int {
        SkTypeface_countTables(self)
    }
    #[inline]
    pub unsafe fn getTableTags(&self, tags: *mut SkFontTableTag) -> ::std::os::raw::c_int {
        SkTypeface_getTableTags(self, tags)
    }
    #[inline]
    pub unsafe fn getTableSize(&self, arg1: SkFontTableTag) -> usize {
        SkTypeface_getTableSize(self, arg1)
    }
    #[inline]
    pub unsafe fn getTableData(
        &self,
        tag: SkFontTableTag,
        offset: usize,
        length: usize,
        data: *mut ::core::ffi::c_void,
    ) -> usize {
        SkTypeface_getTableData(self, tag, offset, length, data)
    }
    #[inline]
    pub unsafe fn copyTableData(&self, tag: SkFontTableTag) -> sk_sp<SkData> {
        SkTypeface_copyTableData(self, tag)
    }
    #[inline]
    pub unsafe fn getUnitsPerEm(&self) -> ::std::os::raw::c_int {
        SkTypeface_getUnitsPerEm(self)
    }
    #[inline]
    pub unsafe fn getKerningPairAdjustments(
        &self,
        glyphs: *const SkGlyphID,
        count: ::std::os::raw::c_int,
        adjustments: *mut i32,
    ) -> bool {
        SkTypeface_getKerningPairAdjustments(self, glyphs, count, adjustments)
    }
    #[inline]
    pub unsafe fn createFamilyNameIterator(&self) -> *mut SkTypeface_LocalizedStrings {
        SkTypeface_createFamilyNameIterator(self)
    }
    #[inline]
    pub unsafe fn getFamilyName(&self, name: *mut SkString) {
        SkTypeface_getFamilyName(self, name)
    }
    #[inline]
    pub unsafe fn getPostScriptName(&self, name: *mut SkString) -> bool {
        SkTypeface_getPostScriptName(self, name)
    }
    #[inline]
    pub unsafe fn openStream(&self, ttcIndex: *mut ::std::os::raw::c_int) -> u64 {
        SkTypeface_openStream(self, ttcIndex)
    }
    #[inline]
    pub unsafe fn openExistingStream(&self, ttcIndex: *mut ::std::os::raw::c_int) -> u64 {
        SkTypeface_openExistingStream(self, ttcIndex)
    }
    #[inline]
    pub unsafe fn createScalerContext(
        &self,
        arg1: *const SkScalerContextEffects,
        arg2: *const SkDescriptor,
    ) -> u8 {
        SkTypeface_createScalerContext(self, arg1, arg2)
    }
    #[inline]
    pub unsafe fn getBounds(&self) -> SkRect {
        SkTypeface_getBounds(self)
    }
    #[inline]
    pub unsafe fn new(style: *const SkFontStyle, isFixedPitch: bool) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkTypeface_SkTypeface(__bindgen_tmp.as_mut_ptr(), style, isFixedPitch);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkTypefaceD1Ev"]
    pub fn SkTypeface_SkTypeface_destructor(this: *mut SkTypeface);
}
extern "C" {
    #[link_name = "\u{1}__ZNK10SkTypeface20onOpenExistingStreamEPi"]
    pub fn SkTypeface_onOpenExistingStream(
        this: *mut ::core::ffi::c_void,
        ttcIndex: *mut ::std::os::raw::c_int,
    ) -> u64;
}
extern "C" {
    #[link_name = "\u{1}__ZNK10SkTypeface27onGetKerningPairAdjustmentsEPKtiPi"]
    pub fn SkTypeface_onGetKerningPairAdjustments(
        this: *mut ::core::ffi::c_void,
        glyphs: *const SkGlyphID,
        count: ::std::os::raw::c_int,
        adjustments: *mut i32,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK10SkTypeface15onCopyTableDataEj"]
    pub fn SkTypeface_onCopyTableData(
        this: *mut ::core::ffi::c_void,
        arg1: SkFontTableTag,
    ) -> sk_sp<SkData>;
}
extern "C" {
    #[link_name = "\u{1}__ZNK10SkTypeface15onComputeBoundsEP6SkRect"]
    pub fn SkTypeface_onComputeBounds(this: *mut ::core::ffi::c_void, arg1: *mut SkRect) -> bool;
}
#[repr(C)]
#[derive(Debug)]
pub struct SkFont {
    pub fTypeface: sk_sp<SkTypeface>,
    pub fSize: SkScalar,
    pub fScaleX: SkScalar,
    pub fSkewX: SkScalar,
    pub fFlags: u8,
    pub fEdging: u8,
    pub fHinting: u8,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkFont_Edging {
    Alias = 0,
    AntiAlias = 1,
    SubpixelAntiAlias = 2,
}
pub const SkFont_PrivFlags_kForceAutoHinting_PrivFlag: SkFont_PrivFlags = 1;
pub const SkFont_PrivFlags_kEmbeddedBitmaps_PrivFlag: SkFont_PrivFlags = 2;
pub const SkFont_PrivFlags_kSubpixel_PrivFlag: SkFont_PrivFlags = 4;
pub const SkFont_PrivFlags_kLinearMetrics_PrivFlag: SkFont_PrivFlags = 8;
pub const SkFont_PrivFlags_kEmbolden_PrivFlag: SkFont_PrivFlags = 16;
pub const SkFont_PrivFlags_kBaselineSnap_PrivFlag: SkFont_PrivFlags = 32;
pub type SkFont_PrivFlags = ::std::os::raw::c_uint;
pub const SkFont_kAllFlags: ::std::os::raw::c_uint = 63;
#[test]
fn bindgen_test_layout_SkFont() {
    assert_eq!(
        ::core::mem::size_of::<SkFont>(),
        24usize,
        concat!("Size of: ", stringify!(SkFont))
    );
    assert_eq!(
        ::core::mem::align_of::<SkFont>(),
        8usize,
        concat!("Alignment of ", stringify!(SkFont))
    );
    fn test_field_fTypeface() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkFont>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fTypeface) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SkFont),
                "::",
                stringify!(fTypeface)
            )
        );
    }
    test_field_fTypeface();
    fn test_field_fSize() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkFont>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fSize) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(SkFont),
                "::",
                stringify!(fSize)
            )
        );
    }
    test_field_fSize();
    fn test_field_fScaleX() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkFont>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fScaleX) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(SkFont),
                "::",
                stringify!(fScaleX)
            )
        );
    }
    test_field_fScaleX();
    fn test_field_fSkewX() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkFont>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fSkewX) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(SkFont),
                "::",
                stringify!(fSkewX)
            )
        );
    }
    test_field_fSkewX();
    fn test_field_fFlags() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkFont>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fFlags) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(SkFont),
                "::",
                stringify!(fFlags)
            )
        );
    }
    test_field_fFlags();
    fn test_field_fEdging() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkFont>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fEdging) as usize - ptr as usize
            },
            21usize,
            concat!(
                "Offset of field: ",
                stringify!(SkFont),
                "::",
                stringify!(fEdging)
            )
        );
    }
    test_field_fEdging();
    fn test_field_fHinting() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkFont>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fHinting) as usize - ptr as usize
            },
            22usize,
            concat!(
                "Offset of field: ",
                stringify!(SkFont),
                "::",
                stringify!(fHinting)
            )
        );
    }
    test_field_fHinting();
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkFont19setForceAutoHintingEb"]
    pub fn SkFont_setForceAutoHinting(this: *mut SkFont, forceAutoHinting: bool);
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkFont18setEmbeddedBitmapsEb"]
    pub fn SkFont_setEmbeddedBitmaps(this: *mut SkFont, embeddedBitmaps: bool);
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkFont11setSubpixelEb"]
    pub fn SkFont_setSubpixel(this: *mut SkFont, subpixel: bool);
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkFont16setLinearMetricsEb"]
    pub fn SkFont_setLinearMetrics(this: *mut SkFont, linearMetrics: bool);
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkFont11setEmboldenEb"]
    pub fn SkFont_setEmbolden(this: *mut SkFont, embolden: bool);
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkFont15setBaselineSnapEb"]
    pub fn SkFont_setBaselineSnap(this: *mut SkFont, baselineSnap: bool);
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkFont9setEdgingENS_6EdgingE"]
    pub fn SkFont_setEdging(this: *mut SkFont, edging: SkFont_Edging);
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkFont10setHintingE13SkFontHinting"]
    pub fn SkFont_setHinting(this: *mut SkFont, hintingLevel: SkFontHinting);
}
extern "C" {
    #[link_name = "\u{1}__ZNK6SkFont12makeWithSizeEf"]
    pub fn SkFont_makeWithSize(this: *const SkFont, size: SkScalar) -> SkFont;
}
extern "C" {
    #[link_name = "\u{1}__ZNK6SkFont20getTypefaceOrDefaultEv"]
    pub fn SkFont_getTypefaceOrDefault(this: *const SkFont) -> *mut SkTypeface;
}
extern "C" {
    #[link_name = "\u{1}__ZNK6SkFont20refTypefaceOrDefaultEv"]
    pub fn SkFont_refTypefaceOrDefault(this: *const SkFont) -> sk_sp<SkTypeface>;
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkFont7setSizeEf"]
    pub fn SkFont_setSize(this: *mut SkFont, textSize: SkScalar);
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkFont9setScaleXEf"]
    pub fn SkFont_setScaleX(this: *mut SkFont, scaleX: SkScalar);
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkFont8setSkewXEf"]
    pub fn SkFont_setSkewX(this: *mut SkFont, skewX: SkScalar);
}
extern "C" {
    #[link_name = "\u{1}__ZNK6SkFont12textToGlyphsEPKvm14SkTextEncodingPti"]
    pub fn SkFont_textToGlyphs(
        this: *const SkFont,
        text: *const ::core::ffi::c_void,
        byteLength: usize,
        encoding: SkTextEncoding,
        glyphs: *mut SkGlyphID,
        maxGlyphCount: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__ZNK6SkFont14unicharToGlyphEi"]
    pub fn SkFont_unicharToGlyph(this: *const SkFont, uni: SkUnichar) -> SkGlyphID;
}
extern "C" {
    #[link_name = "\u{1}__ZNK6SkFont16unicharsToGlyphsEPKiiPt"]
    pub fn SkFont_unicharsToGlyphs(
        this: *const SkFont,
        uni: *const SkUnichar,
        count: ::std::os::raw::c_int,
        glyphs: *mut SkGlyphID,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNK6SkFont11measureTextEPKvm14SkTextEncodingP6SkRectPK7SkPaint"]
    pub fn SkFont_measureText(
        this: *const SkFont,
        text: *const ::core::ffi::c_void,
        byteLength: usize,
        encoding: SkTextEncoding,
        bounds: *mut SkRect,
        paint: *const SkPaint,
    ) -> SkScalar;
}
extern "C" {
    #[link_name = "\u{1}__ZNK6SkFont15getWidthsBoundsEPKtiPfP6SkRectPK7SkPaint"]
    pub fn SkFont_getWidthsBounds(
        this: *const SkFont,
        glyphs: *const SkGlyphID,
        count: ::std::os::raw::c_int,
        widths: *mut SkScalar,
        bounds: *mut SkRect,
        paint: *const SkPaint,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNK6SkFont6getPosEPKtiP7SkPointS2_"]
    pub fn SkFont_getPos(
        this: *const SkFont,
        glyphs: *const SkGlyphID,
        count: ::std::os::raw::c_int,
        pos: *mut SkPoint,
        origin: SkPoint,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNK6SkFont7getXPosEPKtiPff"]
    pub fn SkFont_getXPos(
        this: *const SkFont,
        glyphs: *const SkGlyphID,
        count: ::std::os::raw::c_int,
        xpos: *mut SkScalar,
        origin: SkScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNK6SkFont13getInterceptsEPKtiPK7SkPointffPK7SkPaint"]
    pub fn SkFont_getIntercepts(
        this: *const SkFont,
        glyphs: *const SkGlyphID,
        count: ::std::os::raw::c_int,
        pos: *const SkPoint,
        top: SkScalar,
        bottom: SkScalar,
        arg1: *const SkPaint,
    ) -> [u64; 3usize];
}
extern "C" {
    #[link_name = "\u{1}__ZNK6SkFont7getPathEtP6SkPath"]
    pub fn SkFont_getPath(this: *const SkFont, glyphID: SkGlyphID, path: *mut SkPath) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK6SkFont8getPathsEPKtiPFvPK6SkPathRK8SkMatrixPvES8_"]
    pub fn SkFont_getPaths(
        this: *const SkFont,
        glyphIDs: *const SkGlyphID,
        count: ::std::os::raw::c_int,
        glyphPathProc: ::core::option::Option<
            unsafe extern "C" fn(
                pathOrNull: *const SkPath,
                mx: *const SkMatrix,
                ctx: *mut ::core::ffi::c_void,
            ),
        >,
        ctx: *mut ::core::ffi::c_void,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNK6SkFont10getMetricsEP13SkFontMetrics"]
    pub fn SkFont_getMetrics(this: *const SkFont, metrics: *mut SkFontMetrics) -> SkScalar;
}
extern "C" {
    #[link_name = "\u{1}__ZNK6SkFont4dumpEv"]
    pub fn SkFont_dump(this: *const SkFont);
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkFontC1Ev"]
    pub fn SkFont_SkFont(this: *mut SkFont);
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkFontC1E5sk_spI10SkTypefaceEf"]
    pub fn SkFont_SkFont1(this: *mut SkFont, typeface: sk_sp<SkTypeface>, size: SkScalar);
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkFontC1E5sk_spI10SkTypefaceE"]
    pub fn SkFont_SkFont2(this: *mut SkFont, typeface: sk_sp<SkTypeface>);
}
extern "C" {
    #[link_name = "\u{1}__ZN6SkFontC1E5sk_spI10SkTypefaceEfff"]
    pub fn SkFont_SkFont3(
        this: *mut SkFont,
        typeface: sk_sp<SkTypeface>,
        size: SkScalar,
        scaleX: SkScalar,
        skewX: SkScalar,
    );
}
impl SkFont {
    #[inline]
    pub unsafe fn setForceAutoHinting(&mut self, forceAutoHinting: bool) {
        SkFont_setForceAutoHinting(self, forceAutoHinting)
    }
    #[inline]
    pub unsafe fn setEmbeddedBitmaps(&mut self, embeddedBitmaps: bool) {
        SkFont_setEmbeddedBitmaps(self, embeddedBitmaps)
    }
    #[inline]
    pub unsafe fn setSubpixel(&mut self, subpixel: bool) {
        SkFont_setSubpixel(self, subpixel)
    }
    #[inline]
    pub unsafe fn setLinearMetrics(&mut self, linearMetrics: bool) {
        SkFont_setLinearMetrics(self, linearMetrics)
    }
    #[inline]
    pub unsafe fn setEmbolden(&mut self, embolden: bool) {
        SkFont_setEmbolden(self, embolden)
    }
    #[inline]
    pub unsafe fn setBaselineSnap(&mut self, baselineSnap: bool) {
        SkFont_setBaselineSnap(self, baselineSnap)
    }
    #[inline]
    pub unsafe fn setEdging(&mut self, edging: SkFont_Edging) {
        SkFont_setEdging(self, edging)
    }
    #[inline]
    pub unsafe fn setHinting(&mut self, hintingLevel: SkFontHinting) {
        SkFont_setHinting(self, hintingLevel)
    }
    #[inline]
    pub unsafe fn makeWithSize(&self, size: SkScalar) -> SkFont {
        SkFont_makeWithSize(self, size)
    }
    #[inline]
    pub unsafe fn getTypefaceOrDefault(&self) -> *mut SkTypeface {
        SkFont_getTypefaceOrDefault(self)
    }
    #[inline]
    pub unsafe fn refTypefaceOrDefault(&self) -> sk_sp<SkTypeface> {
        SkFont_refTypefaceOrDefault(self)
    }
    #[inline]
    pub unsafe fn setSize(&mut self, textSize: SkScalar) {
        SkFont_setSize(self, textSize)
    }
    #[inline]
    pub unsafe fn setScaleX(&mut self, scaleX: SkScalar) {
        SkFont_setScaleX(self, scaleX)
    }
    #[inline]
    pub unsafe fn setSkewX(&mut self, skewX: SkScalar) {
        SkFont_setSkewX(self, skewX)
    }
    #[inline]
    pub unsafe fn textToGlyphs(
        &self,
        text: *const ::core::ffi::c_void,
        byteLength: usize,
        encoding: SkTextEncoding,
        glyphs: *mut SkGlyphID,
        maxGlyphCount: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        SkFont_textToGlyphs(self, text, byteLength, encoding, glyphs, maxGlyphCount)
    }
    #[inline]
    pub unsafe fn unicharToGlyph(&self, uni: SkUnichar) -> SkGlyphID {
        SkFont_unicharToGlyph(self, uni)
    }
    #[inline]
    pub unsafe fn unicharsToGlyphs(
        &self,
        uni: *const SkUnichar,
        count: ::std::os::raw::c_int,
        glyphs: *mut SkGlyphID,
    ) {
        SkFont_unicharsToGlyphs(self, uni, count, glyphs)
    }
    #[inline]
    pub unsafe fn measureText(
        &self,
        text: *const ::core::ffi::c_void,
        byteLength: usize,
        encoding: SkTextEncoding,
        bounds: *mut SkRect,
        paint: *const SkPaint,
    ) -> SkScalar {
        SkFont_measureText(self, text, byteLength, encoding, bounds, paint)
    }
    #[inline]
    pub unsafe fn getWidthsBounds(
        &self,
        glyphs: *const SkGlyphID,
        count: ::std::os::raw::c_int,
        widths: *mut SkScalar,
        bounds: *mut SkRect,
        paint: *const SkPaint,
    ) {
        SkFont_getWidthsBounds(self, glyphs, count, widths, bounds, paint)
    }
    #[inline]
    pub unsafe fn getPos(
        &self,
        glyphs: *const SkGlyphID,
        count: ::std::os::raw::c_int,
        pos: *mut SkPoint,
        origin: SkPoint,
    ) {
        SkFont_getPos(self, glyphs, count, pos, origin)
    }
    #[inline]
    pub unsafe fn getXPos(
        &self,
        glyphs: *const SkGlyphID,
        count: ::std::os::raw::c_int,
        xpos: *mut SkScalar,
        origin: SkScalar,
    ) {
        SkFont_getXPos(self, glyphs, count, xpos, origin)
    }
    #[inline]
    pub unsafe fn getIntercepts(
        &self,
        glyphs: *const SkGlyphID,
        count: ::std::os::raw::c_int,
        pos: *const SkPoint,
        top: SkScalar,
        bottom: SkScalar,
        arg1: *const SkPaint,
    ) -> [u64; 3usize] {
        SkFont_getIntercepts(self, glyphs, count, pos, top, bottom, arg1)
    }
    #[inline]
    pub unsafe fn getPath(&self, glyphID: SkGlyphID, path: *mut SkPath) -> bool {
        SkFont_getPath(self, glyphID, path)
    }
    #[inline]
    pub unsafe fn getPaths(
        &self,
        glyphIDs: *const SkGlyphID,
        count: ::std::os::raw::c_int,
        glyphPathProc: ::core::option::Option<
            unsafe extern "C" fn(
                pathOrNull: *const SkPath,
                mx: *const SkMatrix,
                ctx: *mut ::core::ffi::c_void,
            ),
        >,
        ctx: *mut ::core::ffi::c_void,
    ) {
        SkFont_getPaths(self, glyphIDs, count, glyphPathProc, ctx)
    }
    #[inline]
    pub unsafe fn getMetrics(&self, metrics: *mut SkFontMetrics) -> SkScalar {
        SkFont_getMetrics(self, metrics)
    }
    #[inline]
    pub unsafe fn dump(&self) {
        SkFont_dump(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkFont_SkFont(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(typeface: sk_sp<SkTypeface>, size: SkScalar) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkFont_SkFont1(__bindgen_tmp.as_mut_ptr(), typeface, size);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(typeface: sk_sp<SkTypeface>) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkFont_SkFont2(__bindgen_tmp.as_mut_ptr(), typeface);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new3(
        typeface: sk_sp<SkTypeface>,
        size: SkScalar,
        scaleX: SkScalar,
        skewX: SkScalar,
    ) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkFont_SkFont3(__bindgen_tmp.as_mut_ptr(), typeface, size, scaleX, skewX);
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkFontMetrics {
    pub fFlags: u32,
    pub fTop: SkScalar,
    pub fAscent: SkScalar,
    pub fDescent: SkScalar,
    pub fBottom: SkScalar,
    pub fLeading: SkScalar,
    pub fAvgCharWidth: SkScalar,
    pub fMaxCharWidth: SkScalar,
    pub fXMin: SkScalar,
    pub fXMax: SkScalar,
    pub fXHeight: SkScalar,
    pub fCapHeight: SkScalar,
    pub fUnderlineThickness: SkScalar,
    pub fUnderlinePosition: SkScalar,
    pub fStrikeoutThickness: SkScalar,
    pub fStrikeoutPosition: SkScalar,
}
pub const SkFontMetrics_FontMetricsFlags_kUnderlineThicknessIsValid_Flag:
    SkFontMetrics_FontMetricsFlags = 1;
pub const SkFontMetrics_FontMetricsFlags_kUnderlinePositionIsValid_Flag:
    SkFontMetrics_FontMetricsFlags = 2;
pub const SkFontMetrics_FontMetricsFlags_kStrikeoutThicknessIsValid_Flag:
    SkFontMetrics_FontMetricsFlags = 4;
pub const SkFontMetrics_FontMetricsFlags_kStrikeoutPositionIsValid_Flag:
    SkFontMetrics_FontMetricsFlags = 8;
pub const SkFontMetrics_FontMetricsFlags_kBoundsInvalid_Flag: SkFontMetrics_FontMetricsFlags = 16;
pub type SkFontMetrics_FontMetricsFlags = ::std::os::raw::c_uint;
#[test]
fn bindgen_test_layout_SkFontMetrics() {
    assert_eq!(
        ::core::mem::size_of::<SkFontMetrics>(),
        64usize,
        concat!("Size of: ", stringify!(SkFontMetrics))
    );
    assert_eq!(
        ::core::mem::align_of::<SkFontMetrics>(),
        4usize,
        concat!("Alignment of ", stringify!(SkFontMetrics))
    );
    fn test_field_fFlags() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkFontMetrics>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fFlags) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SkFontMetrics),
                "::",
                stringify!(fFlags)
            )
        );
    }
    test_field_fFlags();
    fn test_field_fTop() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkFontMetrics>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fTop) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(SkFontMetrics),
                "::",
                stringify!(fTop)
            )
        );
    }
    test_field_fTop();
    fn test_field_fAscent() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkFontMetrics>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fAscent) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(SkFontMetrics),
                "::",
                stringify!(fAscent)
            )
        );
    }
    test_field_fAscent();
    fn test_field_fDescent() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkFontMetrics>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fDescent) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(SkFontMetrics),
                "::",
                stringify!(fDescent)
            )
        );
    }
    test_field_fDescent();
    fn test_field_fBottom() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkFontMetrics>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fBottom) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(SkFontMetrics),
                "::",
                stringify!(fBottom)
            )
        );
    }
    test_field_fBottom();
    fn test_field_fLeading() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkFontMetrics>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fLeading) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(SkFontMetrics),
                "::",
                stringify!(fLeading)
            )
        );
    }
    test_field_fLeading();
    fn test_field_fAvgCharWidth() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkFontMetrics>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fAvgCharWidth) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(SkFontMetrics),
                "::",
                stringify!(fAvgCharWidth)
            )
        );
    }
    test_field_fAvgCharWidth();
    fn test_field_fMaxCharWidth() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkFontMetrics>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fMaxCharWidth) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(SkFontMetrics),
                "::",
                stringify!(fMaxCharWidth)
            )
        );
    }
    test_field_fMaxCharWidth();
    fn test_field_fXMin() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkFontMetrics>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fXMin) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(SkFontMetrics),
                "::",
                stringify!(fXMin)
            )
        );
    }
    test_field_fXMin();
    fn test_field_fXMax() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkFontMetrics>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fXMax) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(SkFontMetrics),
                "::",
                stringify!(fXMax)
            )
        );
    }
    test_field_fXMax();
    fn test_field_fXHeight() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkFontMetrics>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fXHeight) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(SkFontMetrics),
                "::",
                stringify!(fXHeight)
            )
        );
    }
    test_field_fXHeight();
    fn test_field_fCapHeight() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkFontMetrics>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fCapHeight) as usize - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(SkFontMetrics),
                "::",
                stringify!(fCapHeight)
            )
        );
    }
    test_field_fCapHeight();
    fn test_field_fUnderlineThickness() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkFontMetrics>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fUnderlineThickness) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(SkFontMetrics),
                "::",
                stringify!(fUnderlineThickness)
            )
        );
    }
    test_field_fUnderlineThickness();
    fn test_field_fUnderlinePosition() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkFontMetrics>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fUnderlinePosition) as usize - ptr as usize
            },
            52usize,
            concat!(
                "Offset of field: ",
                stringify!(SkFontMetrics),
                "::",
                stringify!(fUnderlinePosition)
            )
        );
    }
    test_field_fUnderlinePosition();
    fn test_field_fStrikeoutThickness() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkFontMetrics>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fStrikeoutThickness) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(SkFontMetrics),
                "::",
                stringify!(fStrikeoutThickness)
            )
        );
    }
    test_field_fStrikeoutThickness();
    fn test_field_fStrikeoutPosition() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkFontMetrics>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fStrikeoutPosition) as usize - ptr as usize
            },
            60usize,
            concat!(
                "Offset of field: ",
                stringify!(SkFontMetrics),
                "::",
                stringify!(fStrikeoutPosition)
            )
        );
    }
    test_field_fStrikeoutPosition();
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct SkFontStyleSet {
    pub _bindgen_opaque_blob: [u64; 2usize],
}
pub type SkFontStyleSet_INHERITED = SkRefCnt;
#[test]
fn bindgen_test_layout_SkFontStyleSet() {
    assert_eq!(
        ::core::mem::size_of::<SkFontStyleSet>(),
        16usize,
        concat!("Size of: ", stringify!(SkFontStyleSet))
    );
    assert_eq!(
        ::core::mem::align_of::<SkFontStyleSet>(),
        8usize,
        concat!("Alignment of ", stringify!(SkFontStyleSet))
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN14SkFontStyleSet11CreateEmptyEv"]
    pub fn SkFontStyleSet_CreateEmpty() -> *mut SkFontStyleSet;
}
extern "C" {
    #[link_name = "\u{1}__ZN14SkFontStyleSet14matchStyleCSS3ERK11SkFontStyle"]
    pub fn SkFontStyleSet_matchStyleCSS3(
        this: *mut SkFontStyleSet,
        pattern: *const SkFontStyle,
    ) -> *mut SkTypeface;
}
impl SkFontStyleSet {
    #[inline]
    pub unsafe fn CreateEmpty() -> *mut SkFontStyleSet {
        SkFontStyleSet_CreateEmpty()
    }
    #[inline]
    pub unsafe fn matchStyleCSS3(&mut self, pattern: *const SkFontStyle) -> *mut SkTypeface {
        SkFontStyleSet_matchStyleCSS3(self, pattern)
    }
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct SkFontMgr {
    pub _bindgen_opaque_blob: [u64; 2usize],
}
pub type SkFontMgr_INHERITED = SkRefCnt;
#[test]
fn bindgen_test_layout_SkFontMgr() {
    assert_eq!(
        ::core::mem::size_of::<SkFontMgr>(),
        16usize,
        concat!("Size of: ", stringify!(SkFontMgr))
    );
    assert_eq!(
        ::core::mem::align_of::<SkFontMgr>(),
        8usize,
        concat!("Alignment of ", stringify!(SkFontMgr))
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNK9SkFontMgr13countFamiliesEv"]
    pub fn SkFontMgr_countFamilies(this: *const SkFontMgr) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__ZNK9SkFontMgr13getFamilyNameEiP8SkString"]
    pub fn SkFontMgr_getFamilyName(
        this: *const SkFontMgr,
        index: ::std::os::raw::c_int,
        familyName: *mut SkString,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNK9SkFontMgr14createStyleSetEi"]
    pub fn SkFontMgr_createStyleSet(
        this: *const SkFontMgr,
        index: ::std::os::raw::c_int,
    ) -> *mut SkFontStyleSet;
}
extern "C" {
    #[link_name = "\u{1}__ZNK9SkFontMgr11matchFamilyEPKc"]
    pub fn SkFontMgr_matchFamily(
        this: *const SkFontMgr,
        familyName: *const ::std::os::raw::c_char,
    ) -> *mut SkFontStyleSet;
}
extern "C" {
    #[link_name = "\u{1}__ZNK9SkFontMgr16matchFamilyStyleEPKcRK11SkFontStyle"]
    pub fn SkFontMgr_matchFamilyStyle(
        this: *const SkFontMgr,
        familyName: *const ::std::os::raw::c_char,
        arg1: *const SkFontStyle,
    ) -> *mut SkTypeface;
}
extern "C" {
    #[link_name = "\u{1}__ZNK9SkFontMgr25matchFamilyStyleCharacterEPKcRK11SkFontStylePS1_ii"]
    pub fn SkFontMgr_matchFamilyStyleCharacter(
        this: *const SkFontMgr,
        familyName: *const ::std::os::raw::c_char,
        arg1: *const SkFontStyle,
        bcp47: *mut *const ::std::os::raw::c_char,
        bcp47Count: ::std::os::raw::c_int,
        character: SkUnichar,
    ) -> *mut SkTypeface;
}
extern "C" {
    #[link_name = "\u{1}__ZNK9SkFontMgr12makeFromDataE5sk_spI6SkDataEi"]
    pub fn SkFontMgr_makeFromData(
        this: *const SkFontMgr,
        arg1: sk_sp<SkData>,
        ttcIndex: ::std::os::raw::c_int,
    ) -> sk_sp<SkTypeface>;
}
extern "C" {
    #[link_name = "\u{1}__ZNK9SkFontMgr14makeFromStreamENSt3__110unique_ptrI13SkStreamAssetNS0_14default_deleteIS2_EEEEi"]
    pub fn SkFontMgr_makeFromStream(
        this: *const SkFontMgr,
        arg1: u64,
        ttcIndex: ::std::os::raw::c_int,
    ) -> sk_sp<SkTypeface>;
}
extern "C" {
    #[link_name = "\u{1}__ZNK9SkFontMgr14makeFromStreamENSt3__110unique_ptrI13SkStreamAssetNS0_14default_deleteIS2_EEEERK15SkFontArguments"]
    pub fn SkFontMgr_makeFromStream1(
        this: *const SkFontMgr,
        arg1: u64,
        arg2: *const SkFontArguments,
    ) -> sk_sp<SkTypeface>;
}
extern "C" {
    #[link_name = "\u{1}__ZNK9SkFontMgr12makeFromFileEPKci"]
    pub fn SkFontMgr_makeFromFile(
        this: *const SkFontMgr,
        path: *const ::std::os::raw::c_char,
        ttcIndex: ::std::os::raw::c_int,
    ) -> sk_sp<SkTypeface>;
}
extern "C" {
    #[link_name = "\u{1}__ZNK9SkFontMgr18legacyMakeTypefaceEPKc11SkFontStyle"]
    pub fn SkFontMgr_legacyMakeTypeface(
        this: *const SkFontMgr,
        familyName: *const ::std::os::raw::c_char,
        style: SkFontStyle,
    ) -> sk_sp<SkTypeface>;
}
extern "C" {
    #[link_name = "\u{1}__ZN9SkFontMgr10RefDefaultEv"]
    pub fn SkFontMgr_RefDefault() -> sk_sp<SkFontMgr>;
}
impl SkFontMgr {
    #[inline]
    pub unsafe fn countFamilies(&self) -> ::std::os::raw::c_int {
        SkFontMgr_countFamilies(self)
    }
    #[inline]
    pub unsafe fn getFamilyName(&self, index: ::std::os::raw::c_int, familyName: *mut SkString) {
        SkFontMgr_getFamilyName(self, index, familyName)
    }
    #[inline]
    pub unsafe fn createStyleSet(&self, index: ::std::os::raw::c_int) -> *mut SkFontStyleSet {
        SkFontMgr_createStyleSet(self, index)
    }
    #[inline]
    pub unsafe fn matchFamily(
        &self,
        familyName: *const ::std::os::raw::c_char,
    ) -> *mut SkFontStyleSet {
        SkFontMgr_matchFamily(self, familyName)
    }
    #[inline]
    pub unsafe fn matchFamilyStyle(
        &self,
        familyName: *const ::std::os::raw::c_char,
        arg1: *const SkFontStyle,
    ) -> *mut SkTypeface {
        SkFontMgr_matchFamilyStyle(self, familyName, arg1)
    }
    #[inline]
    pub unsafe fn matchFamilyStyleCharacter(
        &self,
        familyName: *const ::std::os::raw::c_char,
        arg1: *const SkFontStyle,
        bcp47: *mut *const ::std::os::raw::c_char,
        bcp47Count: ::std::os::raw::c_int,
        character: SkUnichar,
    ) -> *mut SkTypeface {
        SkFontMgr_matchFamilyStyleCharacter(self, familyName, arg1, bcp47, bcp47Count, character)
    }
    #[inline]
    pub unsafe fn makeFromData(
        &self,
        arg1: sk_sp<SkData>,
        ttcIndex: ::std::os::raw::c_int,
    ) -> sk_sp<SkTypeface> {
        SkFontMgr_makeFromData(self, arg1, ttcIndex)
    }
    #[inline]
    pub unsafe fn makeFromStream(
        &self,
        arg1: u64,
        ttcIndex: ::std::os::raw::c_int,
    ) -> sk_sp<SkTypeface> {
        SkFontMgr_makeFromStream(self, arg1, ttcIndex)
    }
    #[inline]
    pub unsafe fn makeFromStream1(
        &self,
        arg1: u64,
        arg2: *const SkFontArguments,
    ) -> sk_sp<SkTypeface> {
        SkFontMgr_makeFromStream1(self, arg1, arg2)
    }
    #[inline]
    pub unsafe fn makeFromFile(
        &self,
        path: *const ::std::os::raw::c_char,
        ttcIndex: ::std::os::raw::c_int,
    ) -> sk_sp<SkTypeface> {
        SkFontMgr_makeFromFile(self, path, ttcIndex)
    }
    #[inline]
    pub unsafe fn legacyMakeTypeface(
        &self,
        familyName: *const ::std::os::raw::c_char,
        style: SkFontStyle,
    ) -> sk_sp<SkTypeface> {
        SkFontMgr_legacyMakeTypeface(self, familyName, style)
    }
    #[inline]
    pub unsafe fn RefDefault() -> sk_sp<SkFontMgr> {
        SkFontMgr_RefDefault()
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkOpenTypeSVGDecoder {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkTraceMemoryDump {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkGraphics {
    pub _address: u8,
}
pub type SkGraphics_ImageGeneratorFromEncodedDataFactory =
    ::core::option::Option<unsafe extern "C" fn(arg1: sk_sp<SkData>) -> u64>;
pub type SkGraphics_OpenTypeSVGDecoderFactory =
    ::core::option::Option<unsafe extern "C" fn(svg: *const u8, length: usize) -> u8>;
pub type SkGraphics_VariableColrV1EnabledFunc =
    ::core::option::Option<unsafe extern "C" fn() -> bool>;
#[test]
fn bindgen_test_layout_SkGraphics() {
    assert_eq!(
        ::core::mem::size_of::<SkGraphics>(),
        1usize,
        concat!("Size of: ", stringify!(SkGraphics))
    );
    assert_eq!(
        ::core::mem::align_of::<SkGraphics>(),
        1usize,
        concat!("Alignment of ", stringify!(SkGraphics))
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkGraphics4InitEv"]
    pub fn SkGraphics_Init();
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkGraphics17GetFontCacheLimitEv"]
    pub fn SkGraphics_GetFontCacheLimit() -> usize;
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkGraphics17SetFontCacheLimitEm"]
    pub fn SkGraphics_SetFontCacheLimit(bytes: usize) -> usize;
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkGraphics16GetFontCacheUsedEv"]
    pub fn SkGraphics_GetFontCacheUsed() -> usize;
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkGraphics21GetFontCacheCountUsedEv"]
    pub fn SkGraphics_GetFontCacheCountUsed() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkGraphics22GetFontCacheCountLimitEv"]
    pub fn SkGraphics_GetFontCacheCountLimit() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkGraphics22SetFontCacheCountLimitEi"]
    pub fn SkGraphics_SetFontCacheCountLimit(count: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkGraphics14PurgeFontCacheEv"]
    pub fn SkGraphics_PurgeFontCache();
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkGraphics30GetResourceCacheTotalBytesUsedEv"]
    pub fn SkGraphics_GetResourceCacheTotalBytesUsed() -> usize;
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkGraphics30GetResourceCacheTotalByteLimitEv"]
    pub fn SkGraphics_GetResourceCacheTotalByteLimit() -> usize;
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkGraphics30SetResourceCacheTotalByteLimitEm"]
    pub fn SkGraphics_SetResourceCacheTotalByteLimit(newLimit: usize) -> usize;
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkGraphics18PurgeResourceCacheEv"]
    pub fn SkGraphics_PurgeResourceCache();
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkGraphics41GetResourceCacheSingleAllocationByteLimitEv"]
    pub fn SkGraphics_GetResourceCacheSingleAllocationByteLimit() -> usize;
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkGraphics41SetResourceCacheSingleAllocationByteLimitEm"]
    pub fn SkGraphics_SetResourceCacheSingleAllocationByteLimit(newLimit: usize) -> usize;
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkGraphics20DumpMemoryStatisticsEP17SkTraceMemoryDump"]
    pub fn SkGraphics_DumpMemoryStatistics(dump: *mut SkTraceMemoryDump);
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkGraphics14PurgeAllCachesEv"]
    pub fn SkGraphics_PurgeAllCaches();
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkGraphics8SetFlagsEPKc"]
    pub fn SkGraphics_SetFlags(flags: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkGraphics39SetImageGeneratorFromEncodedDataFactoryEPFNSt3__110unique_ptrI16SkImageGeneratorNS0_14default_deleteIS2_EEEE5sk_spI6SkDataEE"]
    pub fn SkGraphics_SetImageGeneratorFromEncodedDataFactory(
        arg1: SkGraphics_ImageGeneratorFromEncodedDataFactory,
    ) -> SkGraphics_ImageGeneratorFromEncodedDataFactory;
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkGraphics28SetOpenTypeSVGDecoderFactoryEPFNSt3__110unique_ptrI20SkOpenTypeSVGDecoderNS0_14default_deleteIS2_EEEEPKhmE"]
    pub fn SkGraphics_SetOpenTypeSVGDecoderFactory(
        arg1: SkGraphics_OpenTypeSVGDecoderFactory,
    ) -> SkGraphics_OpenTypeSVGDecoderFactory;
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkGraphics28GetOpenTypeSVGDecoderFactoryEv"]
    pub fn SkGraphics_GetOpenTypeSVGDecoderFactory() -> SkGraphics_OpenTypeSVGDecoderFactory;
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkGraphics28SetVariableColrV1EnabledFuncEPFbvE"]
    pub fn SkGraphics_SetVariableColrV1EnabledFunc(
        arg1: SkGraphics_VariableColrV1EnabledFunc,
    ) -> SkGraphics_VariableColrV1EnabledFunc;
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkGraphics24GetVariableColrV1EnabledEv"]
    pub fn SkGraphics_GetVariableColrV1Enabled() -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkGraphics8AllowJITEv"]
    pub fn SkGraphics_AllowJIT();
}
impl SkGraphics {
    #[inline]
    pub unsafe fn Init() {
        SkGraphics_Init()
    }
    #[inline]
    pub unsafe fn GetFontCacheLimit() -> usize {
        SkGraphics_GetFontCacheLimit()
    }
    #[inline]
    pub unsafe fn SetFontCacheLimit(bytes: usize) -> usize {
        SkGraphics_SetFontCacheLimit(bytes)
    }
    #[inline]
    pub unsafe fn GetFontCacheUsed() -> usize {
        SkGraphics_GetFontCacheUsed()
    }
    #[inline]
    pub unsafe fn GetFontCacheCountUsed() -> ::std::os::raw::c_int {
        SkGraphics_GetFontCacheCountUsed()
    }
    #[inline]
    pub unsafe fn GetFontCacheCountLimit() -> ::std::os::raw::c_int {
        SkGraphics_GetFontCacheCountLimit()
    }
    #[inline]
    pub unsafe fn SetFontCacheCountLimit(count: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        SkGraphics_SetFontCacheCountLimit(count)
    }
    #[inline]
    pub unsafe fn PurgeFontCache() {
        SkGraphics_PurgeFontCache()
    }
    #[inline]
    pub unsafe fn GetResourceCacheTotalBytesUsed() -> usize {
        SkGraphics_GetResourceCacheTotalBytesUsed()
    }
    #[inline]
    pub unsafe fn GetResourceCacheTotalByteLimit() -> usize {
        SkGraphics_GetResourceCacheTotalByteLimit()
    }
    #[inline]
    pub unsafe fn SetResourceCacheTotalByteLimit(newLimit: usize) -> usize {
        SkGraphics_SetResourceCacheTotalByteLimit(newLimit)
    }
    #[inline]
    pub unsafe fn PurgeResourceCache() {
        SkGraphics_PurgeResourceCache()
    }
    #[inline]
    pub unsafe fn GetResourceCacheSingleAllocationByteLimit() -> usize {
        SkGraphics_GetResourceCacheSingleAllocationByteLimit()
    }
    #[inline]
    pub unsafe fn SetResourceCacheSingleAllocationByteLimit(newLimit: usize) -> usize {
        SkGraphics_SetResourceCacheSingleAllocationByteLimit(newLimit)
    }
    #[inline]
    pub unsafe fn DumpMemoryStatistics(dump: *mut SkTraceMemoryDump) {
        SkGraphics_DumpMemoryStatistics(dump)
    }
    #[inline]
    pub unsafe fn PurgeAllCaches() {
        SkGraphics_PurgeAllCaches()
    }
    #[inline]
    pub unsafe fn SetFlags(flags: *const ::std::os::raw::c_char) {
        SkGraphics_SetFlags(flags)
    }
    #[inline]
    pub unsafe fn SetImageGeneratorFromEncodedDataFactory(
        arg1: SkGraphics_ImageGeneratorFromEncodedDataFactory,
    ) -> SkGraphics_ImageGeneratorFromEncodedDataFactory {
        SkGraphics_SetImageGeneratorFromEncodedDataFactory(arg1)
    }
    #[inline]
    pub unsafe fn SetOpenTypeSVGDecoderFactory(
        arg1: SkGraphics_OpenTypeSVGDecoderFactory,
    ) -> SkGraphics_OpenTypeSVGDecoderFactory {
        SkGraphics_SetOpenTypeSVGDecoderFactory(arg1)
    }
    #[inline]
    pub unsafe fn GetOpenTypeSVGDecoderFactory() -> SkGraphics_OpenTypeSVGDecoderFactory {
        SkGraphics_GetOpenTypeSVGDecoderFactory()
    }
    #[inline]
    pub unsafe fn SetVariableColrV1EnabledFunc(
        arg1: SkGraphics_VariableColrV1EnabledFunc,
    ) -> SkGraphics_VariableColrV1EnabledFunc {
        SkGraphics_SetVariableColrV1EnabledFunc(arg1)
    }
    #[inline]
    pub unsafe fn GetVariableColrV1Enabled() -> bool {
        SkGraphics_GetVariableColrV1Enabled()
    }
    #[inline]
    pub unsafe fn AllowJIT() {
        SkGraphics_AllowJIT()
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkImageFilter {
    pub _base: SkFlattenable,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkImageFilter_MapDirection {
    Forward = 0,
    Reverse = 1,
}
pub type SkImageFilter_INHERITED = SkFlattenable;
#[test]
fn bindgen_test_layout_SkImageFilter() {
    assert_eq!(
        ::core::mem::size_of::<SkImageFilter>(),
        16usize,
        concat!("Size of: ", stringify!(SkImageFilter))
    );
    assert_eq!(
        ::core::mem::align_of::<SkImageFilter>(),
        8usize,
        concat!("Alignment of ", stringify!(SkImageFilter))
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNK13SkImageFilter12filterBoundsERK7SkIRectRK8SkMatrixNS_12MapDirectionEPS1_"]
    pub fn SkImageFilter_filterBounds(
        this: *const SkImageFilter,
        src: *const SkIRect,
        ctm: *const SkMatrix,
        arg1: SkImageFilter_MapDirection,
        inputRect: *const SkIRect,
    ) -> SkIRect;
}
extern "C" {
    #[link_name = "\u{1}__ZNK13SkImageFilter17isColorFilterNodeEPP13SkColorFilter"]
    pub fn SkImageFilter_isColorFilterNode(
        this: *const SkImageFilter,
        filterPtr: *mut *mut SkColorFilter,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK13SkImageFilter14asAColorFilterEPP13SkColorFilter"]
    pub fn SkImageFilter_asAColorFilter(
        this: *const SkImageFilter,
        filterPtr: *mut *mut SkColorFilter,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK13SkImageFilter11countInputsEv"]
    pub fn SkImageFilter_countInputs(this: *const SkImageFilter) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__ZNK13SkImageFilter8getInputEi"]
    pub fn SkImageFilter_getInput(
        this: *const SkImageFilter,
        i: ::std::os::raw::c_int,
    ) -> *const SkImageFilter;
}
extern "C" {
    #[link_name = "\u{1}__ZNK13SkImageFilter20canComputeFastBoundsEv"]
    pub fn SkImageFilter_canComputeFastBounds(this: *const SkImageFilter) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK13SkImageFilter19makeWithLocalMatrixERK8SkMatrix"]
    pub fn SkImageFilter_makeWithLocalMatrix(
        this: *const SkImageFilter,
        matrix: *const SkMatrix,
    ) -> sk_sp<SkImageFilter>;
}
impl SkImageFilter {
    #[inline]
    pub unsafe fn filterBounds(
        &self,
        src: *const SkIRect,
        ctm: *const SkMatrix,
        arg1: SkImageFilter_MapDirection,
        inputRect: *const SkIRect,
    ) -> SkIRect {
        SkImageFilter_filterBounds(self, src, ctm, arg1, inputRect)
    }
    #[inline]
    pub unsafe fn isColorFilterNode(&self, filterPtr: *mut *mut SkColorFilter) -> bool {
        SkImageFilter_isColorFilterNode(self, filterPtr)
    }
    #[inline]
    pub unsafe fn asAColorFilter(&self, filterPtr: *mut *mut SkColorFilter) -> bool {
        SkImageFilter_asAColorFilter(self, filterPtr)
    }
    #[inline]
    pub unsafe fn countInputs(&self) -> ::std::os::raw::c_int {
        SkImageFilter_countInputs(self)
    }
    #[inline]
    pub unsafe fn getInput(&self, i: ::std::os::raw::c_int) -> *const SkImageFilter {
        SkImageFilter_getInput(self, i)
    }
    #[inline]
    pub unsafe fn canComputeFastBounds(&self) -> bool {
        SkImageFilter_canComputeFastBounds(self)
    }
    #[inline]
    pub unsafe fn makeWithLocalMatrix(&self, matrix: *const SkMatrix) -> sk_sp<SkImageFilter> {
        SkImageFilter_makeWithLocalMatrix(self, matrix)
    }
}
extern "C" {
    #[link_name = "\u{1}__ZNK13SkImageFilter17computeFastBoundsERK6SkRect"]
    pub fn SkImageFilter_computeFastBounds(
        this: *mut ::core::ffi::c_void,
        bounds: *const SkRect,
    ) -> SkRect;
}
#[repr(C)]
#[derive(Debug)]
pub struct SkBitmap {
    pub fPixelRef: sk_sp<SkPixelRef>,
    pub fPixmap: SkPixmap,
    pub fMips: sk_sp<SkMipmap>,
}
pub const SkBitmap_AllocFlags_kZeroPixels_AllocFlag: SkBitmap_AllocFlags = 1;
pub type SkBitmap_AllocFlags = ::std::os::raw::c_uint;
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct SkBitmap_Allocator {
    pub _bindgen_opaque_blob: [u64; 2usize],
}
pub type SkBitmap_Allocator_INHERITED = SkRefCnt;
#[test]
fn bindgen_test_layout_SkBitmap_Allocator() {
    assert_eq!(
        ::core::mem::size_of::<SkBitmap_Allocator>(),
        16usize,
        concat!("Size of: ", stringify!(SkBitmap_Allocator))
    );
    assert_eq!(
        ::core::mem::align_of::<SkBitmap_Allocator>(),
        8usize,
        concat!("Alignment of ", stringify!(SkBitmap_Allocator))
    );
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct SkBitmap_HeapAllocator {
    pub _bindgen_opaque_blob: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_SkBitmap_HeapAllocator() {
    assert_eq!(
        ::core::mem::size_of::<SkBitmap_HeapAllocator>(),
        16usize,
        concat!("Size of: ", stringify!(SkBitmap_HeapAllocator))
    );
    assert_eq!(
        ::core::mem::align_of::<SkBitmap_HeapAllocator>(),
        8usize,
        concat!("Alignment of ", stringify!(SkBitmap_HeapAllocator))
    );
}
#[test]
fn bindgen_test_layout_SkBitmap() {
    assert_eq!(
        ::core::mem::size_of::<SkBitmap>(),
        56usize,
        concat!("Size of: ", stringify!(SkBitmap))
    );
    assert_eq!(
        ::core::mem::align_of::<SkBitmap>(),
        8usize,
        concat!("Alignment of ", stringify!(SkBitmap))
    );
    fn test_field_fPixelRef() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkBitmap>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fPixelRef) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SkBitmap),
                "::",
                stringify!(fPixelRef)
            )
        );
    }
    test_field_fPixelRef();
    fn test_field_fPixmap() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkBitmap>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fPixmap) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(SkBitmap),
                "::",
                stringify!(fPixmap)
            )
        );
    }
    test_field_fPixmap();
    fn test_field_fMips() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkBitmap>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fMips) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(SkBitmap),
                "::",
                stringify!(fMips)
            )
        );
    }
    test_field_fMips();
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkBitmap4swapERS_"]
    pub fn SkBitmap_swap(this: *mut SkBitmap, other: *mut SkBitmap);
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkBitmap10colorSpaceEv"]
    pub fn SkBitmap_colorSpace(this: *const SkBitmap) -> *mut SkColorSpace;
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkBitmap13refColorSpaceEv"]
    pub fn SkBitmap_refColorSpace(this: *const SkBitmap) -> sk_sp<SkColorSpace>;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkBitmap12setAlphaTypeE11SkAlphaType"]
    pub fn SkBitmap_setAlphaType(this: *mut SkBitmap, alphaType: SkAlphaType) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkBitmap11isImmutableEv"]
    pub fn SkBitmap_isImmutable(this: *const SkBitmap) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkBitmap12setImmutableEv"]
    pub fn SkBitmap_setImmutable(this: *mut SkBitmap);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkBitmap5resetEv"]
    pub fn SkBitmap_reset(this: *mut SkBitmap);
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkBitmap9getBoundsEP6SkRect"]
    pub fn SkBitmap_getBounds(this: *const SkBitmap, bounds: *mut SkRect);
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkBitmap9getBoundsEP7SkIRect"]
    pub fn SkBitmap_getBounds1(this: *const SkBitmap, bounds: *mut SkIRect);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkBitmap7setInfoERK11SkImageInfom"]
    pub fn SkBitmap_setInfo(
        this: *mut SkBitmap,
        imageInfo: *const SkImageInfo,
        rowBytes: usize,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkBitmap19tryAllocPixelsFlagsERK11SkImageInfoj"]
    pub fn SkBitmap_tryAllocPixelsFlags(
        this: *mut SkBitmap,
        info: *const SkImageInfo,
        flags: u32,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkBitmap16allocPixelsFlagsERK11SkImageInfoj"]
    pub fn SkBitmap_allocPixelsFlags(this: *mut SkBitmap, info: *const SkImageInfo, flags: u32);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkBitmap14tryAllocPixelsERK11SkImageInfom"]
    pub fn SkBitmap_tryAllocPixels(
        this: *mut SkBitmap,
        info: *const SkImageInfo,
        rowBytes: usize,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkBitmap11allocPixelsERK11SkImageInfom"]
    pub fn SkBitmap_allocPixels(this: *mut SkBitmap, info: *const SkImageInfo, rowBytes: usize);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkBitmap11allocPixelsERK11SkImageInfo"]
    pub fn SkBitmap_allocPixels1(this: *mut SkBitmap, info: *const SkImageInfo);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkBitmap17tryAllocN32PixelsEiib"]
    pub fn SkBitmap_tryAllocN32Pixels(
        this: *mut SkBitmap,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        isOpaque: bool,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkBitmap14allocN32PixelsEiib"]
    pub fn SkBitmap_allocN32Pixels(
        this: *mut SkBitmap,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        isOpaque: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkBitmap13installPixelsERK11SkImageInfoPvmPFvS3_S3_ES3_"]
    pub fn SkBitmap_installPixels(
        this: *mut SkBitmap,
        info: *const SkImageInfo,
        pixels: *mut ::core::ffi::c_void,
        rowBytes: usize,
        releaseProc: ::core::option::Option<
            unsafe extern "C" fn(addr: *mut ::core::ffi::c_void, context: *mut ::core::ffi::c_void),
        >,
        context: *mut ::core::ffi::c_void,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkBitmap13installPixelsERK8SkPixmap"]
    pub fn SkBitmap_installPixels1(this: *mut SkBitmap, pixmap: *const SkPixmap) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkBitmap17installMaskPixelsERK6SkMask"]
    pub fn SkBitmap_installMaskPixels(this: *mut SkBitmap, mask: *const SkMask) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkBitmap9setPixelsEPv"]
    pub fn SkBitmap_setPixels(this: *mut SkBitmap, pixels: *mut ::core::ffi::c_void);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkBitmap11allocPixelsEv"]
    pub fn SkBitmap_allocPixels2(this: *mut SkBitmap);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkBitmap14tryAllocPixelsEPNS_9AllocatorE"]
    pub fn SkBitmap_tryAllocPixels1(
        this: *mut SkBitmap,
        allocator: *mut SkBitmap_Allocator,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkBitmap11allocPixelsEPNS_9AllocatorE"]
    pub fn SkBitmap_allocPixels3(this: *mut SkBitmap, allocator: *mut SkBitmap_Allocator);
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkBitmap14pixelRefOriginEv"]
    pub fn SkBitmap_pixelRefOrigin(this: *const SkBitmap) -> SkIPoint;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkBitmap11setPixelRefE5sk_spI10SkPixelRefEii"]
    pub fn SkBitmap_setPixelRef(
        this: *mut SkBitmap,
        pixelRef: sk_sp<SkPixelRef>,
        dx: ::std::os::raw::c_int,
        dy: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkBitmap15getGenerationIDEv"]
    pub fn SkBitmap_getGenerationID(this: *const SkBitmap) -> u32;
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkBitmap19notifyPixelsChangedEv"]
    pub fn SkBitmap_notifyPixelsChanged(this: *const SkBitmap);
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkBitmap10eraseColorE8SkRGBA4fIL11SkAlphaType3EEP12SkColorSpace"]
    pub fn SkBitmap_eraseColor(this: *const SkBitmap, c: SkColor4f, colorSpace: *mut SkColorSpace);
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkBitmap10eraseColorEj"]
    pub fn SkBitmap_eraseColor1(this: *const SkBitmap, c: SkColor);
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkBitmap5eraseE8SkRGBA4fIL11SkAlphaType3EEP12SkColorSpaceRK7SkIRect"]
    pub fn SkBitmap_erase(
        this: *const SkBitmap,
        c: SkColor4f,
        colorSpace: *mut SkColorSpace,
        area: *const SkIRect,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkBitmap5eraseE8SkRGBA4fIL11SkAlphaType3EERK7SkIRect"]
    pub fn SkBitmap_erase1(this: *const SkBitmap, c: SkColor4f, area: *const SkIRect);
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkBitmap5eraseEjRK7SkIRect"]
    pub fn SkBitmap_erase2(this: *const SkBitmap, c: SkColor, area: *const SkIRect);
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkBitmap7getAddrEii"]
    pub fn SkBitmap_getAddr(
        this: *const SkBitmap,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkBitmap13extractSubsetEPS_RK7SkIRect"]
    pub fn SkBitmap_extractSubset(
        this: *const SkBitmap,
        dst: *mut SkBitmap,
        subset: *const SkIRect,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkBitmap10readPixelsERK11SkImageInfoPvmii"]
    pub fn SkBitmap_readPixels(
        this: *const SkBitmap,
        dstInfo: *const SkImageInfo,
        dstPixels: *mut ::core::ffi::c_void,
        dstRowBytes: usize,
        srcX: ::std::os::raw::c_int,
        srcY: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkBitmap10readPixelsERK8SkPixmapii"]
    pub fn SkBitmap_readPixels1(
        this: *const SkBitmap,
        dst: *const SkPixmap,
        srcX: ::std::os::raw::c_int,
        srcY: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkBitmap11writePixelsERK8SkPixmapii"]
    pub fn SkBitmap_writePixels(
        this: *mut SkBitmap,
        src: *const SkPixmap,
        dstX: ::std::os::raw::c_int,
        dstY: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkBitmap12extractAlphaEPS_PK7SkPaintPNS_9AllocatorEP8SkIPoint"]
    pub fn SkBitmap_extractAlpha(
        this: *const SkBitmap,
        dst: *mut SkBitmap,
        paint: *const SkPaint,
        allocator: *mut SkBitmap_Allocator,
        offset: *mut SkIPoint,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkBitmap10peekPixelsEP8SkPixmap"]
    pub fn SkBitmap_peekPixels(this: *const SkBitmap, pixmap: *mut SkPixmap) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkBitmap10makeShaderE10SkTileModeS0_RK17SkSamplingOptionsPK8SkMatrix"]
    pub fn SkBitmap_makeShader(
        this: *const SkBitmap,
        tmx: SkTileMode,
        tmy: SkTileMode,
        arg1: *const SkSamplingOptions,
        arg2: *const SkMatrix,
    ) -> sk_sp<SkShader>;
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkBitmap7asImageEv"]
    pub fn SkBitmap_asImage(this: *const SkBitmap) -> sk_sp<SkImage>;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkBitmapC1Ev"]
    pub fn SkBitmap_SkBitmap(this: *mut SkBitmap);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkBitmapC1ERKS_"]
    pub fn SkBitmap_SkBitmap1(this: *mut SkBitmap, src: *const SkBitmap);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkBitmapC1EOS_"]
    pub fn SkBitmap_SkBitmap2(this: *mut SkBitmap, src: *mut SkBitmap);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkBitmapD1Ev"]
    pub fn SkBitmap_SkBitmap_destructor(this: *mut SkBitmap);
}
impl SkBitmap {
    #[inline]
    pub unsafe fn swap(&mut self, other: *mut SkBitmap) {
        SkBitmap_swap(self, other)
    }
    #[inline]
    pub unsafe fn colorSpace(&self) -> *mut SkColorSpace {
        SkBitmap_colorSpace(self)
    }
    #[inline]
    pub unsafe fn refColorSpace(&self) -> sk_sp<SkColorSpace> {
        SkBitmap_refColorSpace(self)
    }
    #[inline]
    pub unsafe fn setAlphaType(&mut self, alphaType: SkAlphaType) -> bool {
        SkBitmap_setAlphaType(self, alphaType)
    }
    #[inline]
    pub unsafe fn isImmutable(&self) -> bool {
        SkBitmap_isImmutable(self)
    }
    #[inline]
    pub unsafe fn setImmutable(&mut self) {
        SkBitmap_setImmutable(self)
    }
    #[inline]
    pub unsafe fn reset(&mut self) {
        SkBitmap_reset(self)
    }
    #[inline]
    pub unsafe fn getBounds(&self, bounds: *mut SkRect) {
        SkBitmap_getBounds(self, bounds)
    }
    #[inline]
    pub unsafe fn getBounds1(&self, bounds: *mut SkIRect) {
        SkBitmap_getBounds1(self, bounds)
    }
    #[inline]
    pub unsafe fn setInfo(&mut self, imageInfo: *const SkImageInfo, rowBytes: usize) -> bool {
        SkBitmap_setInfo(self, imageInfo, rowBytes)
    }
    #[inline]
    pub unsafe fn tryAllocPixelsFlags(&mut self, info: *const SkImageInfo, flags: u32) -> bool {
        SkBitmap_tryAllocPixelsFlags(self, info, flags)
    }
    #[inline]
    pub unsafe fn allocPixelsFlags(&mut self, info: *const SkImageInfo, flags: u32) {
        SkBitmap_allocPixelsFlags(self, info, flags)
    }
    #[inline]
    pub unsafe fn tryAllocPixels(&mut self, info: *const SkImageInfo, rowBytes: usize) -> bool {
        SkBitmap_tryAllocPixels(self, info, rowBytes)
    }
    #[inline]
    pub unsafe fn allocPixels(&mut self, info: *const SkImageInfo, rowBytes: usize) {
        SkBitmap_allocPixels(self, info, rowBytes)
    }
    #[inline]
    pub unsafe fn allocPixels1(&mut self, info: *const SkImageInfo) {
        SkBitmap_allocPixels1(self, info)
    }
    #[inline]
    pub unsafe fn tryAllocN32Pixels(
        &mut self,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        isOpaque: bool,
    ) -> bool {
        SkBitmap_tryAllocN32Pixels(self, width, height, isOpaque)
    }
    #[inline]
    pub unsafe fn allocN32Pixels(
        &mut self,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        isOpaque: bool,
    ) {
        SkBitmap_allocN32Pixels(self, width, height, isOpaque)
    }
    #[inline]
    pub unsafe fn installPixels(
        &mut self,
        info: *const SkImageInfo,
        pixels: *mut ::core::ffi::c_void,
        rowBytes: usize,
        releaseProc: ::core::option::Option<
            unsafe extern "C" fn(addr: *mut ::core::ffi::c_void, context: *mut ::core::ffi::c_void),
        >,
        context: *mut ::core::ffi::c_void,
    ) -> bool {
        SkBitmap_installPixels(self, info, pixels, rowBytes, releaseProc, context)
    }
    #[inline]
    pub unsafe fn installPixels1(&mut self, pixmap: *const SkPixmap) -> bool {
        SkBitmap_installPixels1(self, pixmap)
    }
    #[inline]
    pub unsafe fn installMaskPixels(&mut self, mask: *const SkMask) -> bool {
        SkBitmap_installMaskPixels(self, mask)
    }
    #[inline]
    pub unsafe fn setPixels(&mut self, pixels: *mut ::core::ffi::c_void) {
        SkBitmap_setPixels(self, pixels)
    }
    #[inline]
    pub unsafe fn allocPixels2(&mut self) {
        SkBitmap_allocPixels2(self)
    }
    #[inline]
    pub unsafe fn tryAllocPixels1(&mut self, allocator: *mut SkBitmap_Allocator) -> bool {
        SkBitmap_tryAllocPixels1(self, allocator)
    }
    #[inline]
    pub unsafe fn allocPixels3(&mut self, allocator: *mut SkBitmap_Allocator) {
        SkBitmap_allocPixels3(self, allocator)
    }
    #[inline]
    pub unsafe fn pixelRefOrigin(&self) -> SkIPoint {
        SkBitmap_pixelRefOrigin(self)
    }
    #[inline]
    pub unsafe fn setPixelRef(
        &mut self,
        pixelRef: sk_sp<SkPixelRef>,
        dx: ::std::os::raw::c_int,
        dy: ::std::os::raw::c_int,
    ) {
        SkBitmap_setPixelRef(self, pixelRef, dx, dy)
    }
    #[inline]
    pub unsafe fn getGenerationID(&self) -> u32 {
        SkBitmap_getGenerationID(self)
    }
    #[inline]
    pub unsafe fn notifyPixelsChanged(&self) {
        SkBitmap_notifyPixelsChanged(self)
    }
    #[inline]
    pub unsafe fn eraseColor(&self, c: SkColor4f, colorSpace: *mut SkColorSpace) {
        SkBitmap_eraseColor(self, c, colorSpace)
    }
    #[inline]
    pub unsafe fn eraseColor1(&self, c: SkColor) {
        SkBitmap_eraseColor1(self, c)
    }
    #[inline]
    pub unsafe fn erase(&self, c: SkColor4f, colorSpace: *mut SkColorSpace, area: *const SkIRect) {
        SkBitmap_erase(self, c, colorSpace, area)
    }
    #[inline]
    pub unsafe fn erase1(&self, c: SkColor4f, area: *const SkIRect) {
        SkBitmap_erase1(self, c, area)
    }
    #[inline]
    pub unsafe fn erase2(&self, c: SkColor, area: *const SkIRect) {
        SkBitmap_erase2(self, c, area)
    }
    #[inline]
    pub unsafe fn getAddr(
        &self,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
    ) -> *mut ::core::ffi::c_void {
        SkBitmap_getAddr(self, x, y)
    }
    #[inline]
    pub unsafe fn extractSubset(&self, dst: *mut SkBitmap, subset: *const SkIRect) -> bool {
        SkBitmap_extractSubset(self, dst, subset)
    }
    #[inline]
    pub unsafe fn readPixels(
        &self,
        dstInfo: *const SkImageInfo,
        dstPixels: *mut ::core::ffi::c_void,
        dstRowBytes: usize,
        srcX: ::std::os::raw::c_int,
        srcY: ::std::os::raw::c_int,
    ) -> bool {
        SkBitmap_readPixels(self, dstInfo, dstPixels, dstRowBytes, srcX, srcY)
    }
    #[inline]
    pub unsafe fn readPixels1(
        &self,
        dst: *const SkPixmap,
        srcX: ::std::os::raw::c_int,
        srcY: ::std::os::raw::c_int,
    ) -> bool {
        SkBitmap_readPixels1(self, dst, srcX, srcY)
    }
    #[inline]
    pub unsafe fn writePixels(
        &mut self,
        src: *const SkPixmap,
        dstX: ::std::os::raw::c_int,
        dstY: ::std::os::raw::c_int,
    ) -> bool {
        SkBitmap_writePixels(self, src, dstX, dstY)
    }
    #[inline]
    pub unsafe fn extractAlpha(
        &self,
        dst: *mut SkBitmap,
        paint: *const SkPaint,
        allocator: *mut SkBitmap_Allocator,
        offset: *mut SkIPoint,
    ) -> bool {
        SkBitmap_extractAlpha(self, dst, paint, allocator, offset)
    }
    #[inline]
    pub unsafe fn peekPixels(&self, pixmap: *mut SkPixmap) -> bool {
        SkBitmap_peekPixels(self, pixmap)
    }
    #[inline]
    pub unsafe fn makeShader(
        &self,
        tmx: SkTileMode,
        tmy: SkTileMode,
        arg1: *const SkSamplingOptions,
        arg2: *const SkMatrix,
    ) -> sk_sp<SkShader> {
        SkBitmap_makeShader(self, tmx, tmy, arg1, arg2)
    }
    #[inline]
    pub unsafe fn asImage(&self) -> sk_sp<SkImage> {
        SkBitmap_asImage(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkBitmap_SkBitmap(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(src: *const SkBitmap) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkBitmap_SkBitmap1(__bindgen_tmp.as_mut_ptr(), src);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(src: *mut SkBitmap) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkBitmap_SkBitmap2(__bindgen_tmp.as_mut_ptr(), src);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        SkBitmap_SkBitmap_destructor(self)
    }
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkBitmap13HeapAllocator13allocPixelRefEPS_"]
    pub fn SkBitmap_HeapAllocator_allocPixelRef(
        this: *mut ::core::ffi::c_void,
        bitmap: *mut SkBitmap,
    ) -> bool;
}
#[repr(C)]
pub struct SkImageGenerator__bindgen_vtable(::core::ffi::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct SkImageGenerator {
    pub vtable_: *const SkImageGenerator__bindgen_vtable,
    pub fInfo: SkImageInfo,
    pub fUniqueID: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkImageGenerator_Options {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_SkImageGenerator_Options() {
    assert_eq!(
        ::core::mem::size_of::<SkImageGenerator_Options>(),
        1usize,
        concat!("Size of: ", stringify!(SkImageGenerator_Options))
    );
    assert_eq!(
        ::core::mem::align_of::<SkImageGenerator_Options>(),
        1usize,
        concat!("Alignment of ", stringify!(SkImageGenerator_Options))
    );
}
pub const SkImageGenerator_kNeedNewImageUniqueID: ::std::os::raw::c_int = 0;
#[test]
fn bindgen_test_layout_SkImageGenerator() {
    assert_eq!(
        ::core::mem::size_of::<SkImageGenerator>(),
        40usize,
        concat!("Size of: ", stringify!(SkImageGenerator))
    );
    assert_eq!(
        ::core::mem::align_of::<SkImageGenerator>(),
        8usize,
        concat!("Alignment of ", stringify!(SkImageGenerator))
    );
    fn test_field_fInfo() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkImageGenerator>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fInfo) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(SkImageGenerator),
                "::",
                stringify!(fInfo)
            )
        );
    }
    test_field_fInfo();
    fn test_field_fUniqueID() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkImageGenerator>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fUniqueID) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(SkImageGenerator),
                "::",
                stringify!(fUniqueID)
            )
        );
    }
    test_field_fUniqueID();
}
extern "C" {
    #[link_name = "\u{1}__ZN16SkImageGenerator9getPixelsERK11SkImageInfoPvm"]
    pub fn SkImageGenerator_getPixels(
        this: *mut SkImageGenerator,
        info: *const SkImageInfo,
        pixels: *mut ::core::ffi::c_void,
        rowBytes: usize,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK16SkImageGenerator13queryYUVAInfoERKN16SkYUVAPixmapInfo18SupportedDataTypesEPS0_"]
    pub fn SkImageGenerator_queryYUVAInfo(
        this: *const SkImageGenerator,
        supportedDataTypes: *const SkYUVAPixmapInfo_SupportedDataTypes,
        yuvaPixmapInfo: *mut SkYUVAPixmapInfo,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN16SkImageGenerator13getYUVAPlanesERK13SkYUVAPixmaps"]
    pub fn SkImageGenerator_getYUVAPlanes(
        this: *mut SkImageGenerator,
        yuvaPixmaps: *const SkYUVAPixmaps,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN16SkImageGenerator15MakeFromEncodedE5sk_spI6SkDataENSt3__18optionalI11SkAlphaTypeEE"]
    pub fn SkImageGenerator_MakeFromEncoded(arg1: sk_sp<SkData>, arg2: [u32; 2usize]) -> u64;
}
extern "C" {
    #[link_name = "\u{1}__ZN16SkImageGenerator15MakeFromPictureERK7SkISize5sk_spI9SkPictureEPK8SkMatrixPK7SkPaintN7SkImage8BitDepthES3_I12SkColorSpaceE14SkSurfaceProps"]
    pub fn SkImageGenerator_MakeFromPicture(
        arg1: *const SkISize,
        arg2: sk_sp<SkPicture>,
        arg3: *const SkMatrix,
        arg4: *const SkPaint,
        arg5: SkImage_BitDepth,
        arg6: sk_sp<SkColorSpace>,
        props: SkSurfaceProps,
    ) -> u64;
}
extern "C" {
    #[link_name = "\u{1}__ZN16SkImageGeneratorC1ERK11SkImageInfoj"]
    pub fn SkImageGenerator_SkImageGenerator(
        this: *mut SkImageGenerator,
        info: *const SkImageInfo,
        uniqueId: u32,
    );
}
impl SkImageGenerator {
    #[inline]
    pub unsafe fn getPixels(
        &mut self,
        info: *const SkImageInfo,
        pixels: *mut ::core::ffi::c_void,
        rowBytes: usize,
    ) -> bool {
        SkImageGenerator_getPixels(self, info, pixels, rowBytes)
    }
    #[inline]
    pub unsafe fn queryYUVAInfo(
        &self,
        supportedDataTypes: *const SkYUVAPixmapInfo_SupportedDataTypes,
        yuvaPixmapInfo: *mut SkYUVAPixmapInfo,
    ) -> bool {
        SkImageGenerator_queryYUVAInfo(self, supportedDataTypes, yuvaPixmapInfo)
    }
    #[inline]
    pub unsafe fn getYUVAPlanes(&mut self, yuvaPixmaps: *const SkYUVAPixmaps) -> bool {
        SkImageGenerator_getYUVAPlanes(self, yuvaPixmaps)
    }
    #[inline]
    pub unsafe fn MakeFromEncoded(arg1: sk_sp<SkData>, arg2: [u32; 2usize]) -> u64 {
        SkImageGenerator_MakeFromEncoded(arg1, arg2)
    }
    #[inline]
    pub unsafe fn MakeFromPicture(
        arg1: *const SkISize,
        arg2: sk_sp<SkPicture>,
        arg3: *const SkMatrix,
        arg4: *const SkPaint,
        arg5: SkImage_BitDepth,
        arg6: sk_sp<SkColorSpace>,
        props: SkSurfaceProps,
    ) -> u64 {
        SkImageGenerator_MakeFromPicture(arg1, arg2, arg3, arg4, arg5, arg6, props)
    }
    #[inline]
    pub unsafe fn new(info: *const SkImageInfo, uniqueId: u32) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkImageGenerator_SkImageGenerator(__bindgen_tmp.as_mut_ptr(), info, uniqueId);
        __bindgen_tmp.assume_init()
    }
}
impl SkBlurStyle {
    pub const LastEnum: SkBlurStyle = SkBlurStyle::Inner;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkBlurStyle {
    Normal = 0,
    Solid = 1,
    Outer = 2,
    Inner = 3,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct SkMaskFilter {
    pub _bindgen_opaque_blob: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_SkMaskFilter() {
    assert_eq!(
        ::core::mem::size_of::<SkMaskFilter>(),
        16usize,
        concat!("Size of: ", stringify!(SkMaskFilter))
    );
    assert_eq!(
        ::core::mem::align_of::<SkMaskFilter>(),
        8usize,
        concat!("Alignment of ", stringify!(SkMaskFilter))
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN12SkMaskFilter8MakeBlurE11SkBlurStylefb"]
    pub fn SkMaskFilter_MakeBlur(
        style: SkBlurStyle,
        sigma: SkScalar,
        respectCTM: bool,
    ) -> sk_sp<SkMaskFilter>;
}
extern "C" {
    #[link_name = "\u{1}__ZNK12SkMaskFilter25approximateFilteredBoundsERK6SkRect"]
    pub fn SkMaskFilter_approximateFilteredBounds(
        this: *const SkMaskFilter,
        src: *const SkRect,
    ) -> SkRect;
}
extern "C" {
    #[link_name = "\u{1}__ZN12SkMaskFilter11DeserializeEPKvmPK15SkDeserialProcs"]
    pub fn SkMaskFilter_Deserialize(
        data: *const ::core::ffi::c_void,
        size: usize,
        procs: *const SkDeserialProcs,
    ) -> sk_sp<SkMaskFilter>;
}
impl SkMaskFilter {
    #[inline]
    pub unsafe fn MakeBlur(
        style: SkBlurStyle,
        sigma: SkScalar,
        respectCTM: bool,
    ) -> sk_sp<SkMaskFilter> {
        SkMaskFilter_MakeBlur(style, sigma, respectCTM)
    }
    #[inline]
    pub unsafe fn approximateFilteredBounds(&self, src: *const SkRect) -> SkRect {
        SkMaskFilter_approximateFilteredBounds(self, src)
    }
    #[inline]
    pub unsafe fn Deserialize(
        data: *const ::core::ffi::c_void,
        size: usize,
        procs: *const SkDeserialProcs,
    ) -> sk_sp<SkMaskFilter> {
        SkMaskFilter_Deserialize(data, size, procs)
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct SkPathBuilder {
    pub fPts: SkTDArray<SkPoint>,
    pub fVerbs: SkTDArray<u8>,
    pub fConicWeights: SkTDArray<SkScalar>,
    pub fFillType: SkPathFillType,
    pub fIsVolatile: bool,
    pub fSegmentMask: ::std::os::raw::c_uint,
    pub fLastMovePoint: SkPoint,
    pub fLastMoveIndex: ::std::os::raw::c_int,
    pub fNeedsMoveVerb: bool,
    pub fIsA: SkPathBuilder_IsA,
    pub fIsAStart: ::std::os::raw::c_int,
    pub fIsACCW: bool,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkPathBuilder_ArcSize {
    Small = 0,
    Large = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkPathBuilder_IsA {
    kIsA_JustMoves = 0,
    kIsA_MoreThanMoves = 1,
    kIsA_Oval = 2,
    kIsA_RRect = 3,
}
#[test]
fn bindgen_test_layout_SkPathBuilder() {
    assert_eq!(
        ::core::mem::size_of::<SkPathBuilder>(),
        88usize,
        concat!("Size of: ", stringify!(SkPathBuilder))
    );
    assert_eq!(
        ::core::mem::align_of::<SkPathBuilder>(),
        8usize,
        concat!("Alignment of ", stringify!(SkPathBuilder))
    );
    fn test_field_fPts() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkPathBuilder>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fPts) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SkPathBuilder),
                "::",
                stringify!(fPts)
            )
        );
    }
    test_field_fPts();
    fn test_field_fVerbs() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkPathBuilder>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fVerbs) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(SkPathBuilder),
                "::",
                stringify!(fVerbs)
            )
        );
    }
    test_field_fVerbs();
    fn test_field_fConicWeights() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkPathBuilder>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fConicWeights) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(SkPathBuilder),
                "::",
                stringify!(fConicWeights)
            )
        );
    }
    test_field_fConicWeights();
    fn test_field_fFillType() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkPathBuilder>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fFillType) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(SkPathBuilder),
                "::",
                stringify!(fFillType)
            )
        );
    }
    test_field_fFillType();
    fn test_field_fIsVolatile() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkPathBuilder>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fIsVolatile) as usize - ptr as usize
            },
            52usize,
            concat!(
                "Offset of field: ",
                stringify!(SkPathBuilder),
                "::",
                stringify!(fIsVolatile)
            )
        );
    }
    test_field_fIsVolatile();
    fn test_field_fSegmentMask() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkPathBuilder>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fSegmentMask) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(SkPathBuilder),
                "::",
                stringify!(fSegmentMask)
            )
        );
    }
    test_field_fSegmentMask();
    fn test_field_fLastMovePoint() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkPathBuilder>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fLastMovePoint) as usize - ptr as usize
            },
            60usize,
            concat!(
                "Offset of field: ",
                stringify!(SkPathBuilder),
                "::",
                stringify!(fLastMovePoint)
            )
        );
    }
    test_field_fLastMovePoint();
    fn test_field_fLastMoveIndex() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkPathBuilder>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fLastMoveIndex) as usize - ptr as usize
            },
            68usize,
            concat!(
                "Offset of field: ",
                stringify!(SkPathBuilder),
                "::",
                stringify!(fLastMoveIndex)
            )
        );
    }
    test_field_fLastMoveIndex();
    fn test_field_fNeedsMoveVerb() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkPathBuilder>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fNeedsMoveVerb) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(SkPathBuilder),
                "::",
                stringify!(fNeedsMoveVerb)
            )
        );
    }
    test_field_fNeedsMoveVerb();
    fn test_field_fIsA() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkPathBuilder>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fIsA) as usize - ptr as usize
            },
            76usize,
            concat!(
                "Offset of field: ",
                stringify!(SkPathBuilder),
                "::",
                stringify!(fIsA)
            )
        );
    }
    test_field_fIsA();
    fn test_field_fIsAStart() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkPathBuilder>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fIsAStart) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(SkPathBuilder),
                "::",
                stringify!(fIsAStart)
            )
        );
    }
    test_field_fIsAStart();
    fn test_field_fIsACCW() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkPathBuilder>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fIsACCW) as usize - ptr as usize
            },
            84usize,
            concat!(
                "Offset of field: ",
                stringify!(SkPathBuilder),
                "::",
                stringify!(fIsACCW)
            )
        );
    }
    test_field_fIsACCW();
}
extern "C" {
    #[link_name = "\u{1}__ZNK13SkPathBuilder13computeBoundsEv"]
    pub fn SkPathBuilder_computeBounds(this: *const SkPathBuilder) -> SkRect;
}
extern "C" {
    #[link_name = "\u{1}__ZNK13SkPathBuilder8snapshotEv"]
    pub fn SkPathBuilder_snapshot(this: *const SkPathBuilder) -> SkPath;
}
extern "C" {
    #[link_name = "\u{1}__ZN13SkPathBuilder6detachEv"]
    pub fn SkPathBuilder_detach(this: *mut SkPathBuilder) -> SkPath;
}
extern "C" {
    #[link_name = "\u{1}__ZN13SkPathBuilder5resetEv"]
    pub fn SkPathBuilder_reset(this: *mut SkPathBuilder) -> *mut SkPathBuilder;
}
extern "C" {
    #[link_name = "\u{1}__ZN13SkPathBuilder6moveToE7SkPoint"]
    pub fn SkPathBuilder_moveTo(this: *mut SkPathBuilder, pt: SkPoint) -> *mut SkPathBuilder;
}
extern "C" {
    #[link_name = "\u{1}__ZN13SkPathBuilder6lineToE7SkPoint"]
    pub fn SkPathBuilder_lineTo(this: *mut SkPathBuilder, pt: SkPoint) -> *mut SkPathBuilder;
}
extern "C" {
    #[link_name = "\u{1}__ZN13SkPathBuilder6quadToE7SkPointS0_"]
    pub fn SkPathBuilder_quadTo(
        this: *mut SkPathBuilder,
        pt1: SkPoint,
        pt2: SkPoint,
    ) -> *mut SkPathBuilder;
}
extern "C" {
    #[link_name = "\u{1}__ZN13SkPathBuilder7conicToE7SkPointS0_f"]
    pub fn SkPathBuilder_conicTo(
        this: *mut SkPathBuilder,
        pt1: SkPoint,
        pt2: SkPoint,
        w: SkScalar,
    ) -> *mut SkPathBuilder;
}
extern "C" {
    #[link_name = "\u{1}__ZN13SkPathBuilder7cubicToE7SkPointS0_S0_"]
    pub fn SkPathBuilder_cubicTo(
        this: *mut SkPathBuilder,
        pt1: SkPoint,
        pt2: SkPoint,
        pt3: SkPoint,
    ) -> *mut SkPathBuilder;
}
extern "C" {
    #[link_name = "\u{1}__ZN13SkPathBuilder5closeEv"]
    pub fn SkPathBuilder_close(this: *mut SkPathBuilder) -> *mut SkPathBuilder;
}
extern "C" {
    #[link_name = "\u{1}__ZN13SkPathBuilder10polylineToEPK7SkPointi"]
    pub fn SkPathBuilder_polylineTo(
        this: *mut SkPathBuilder,
        pts: *const SkPoint,
        count: ::std::os::raw::c_int,
    ) -> *mut SkPathBuilder;
}
extern "C" {
    #[link_name = "\u{1}__ZN13SkPathBuilder7rLineToE7SkPoint"]
    pub fn SkPathBuilder_rLineTo(this: *mut SkPathBuilder, pt: SkPoint) -> *mut SkPathBuilder;
}
extern "C" {
    #[link_name = "\u{1}__ZN13SkPathBuilder7rQuadToE7SkPointS0_"]
    pub fn SkPathBuilder_rQuadTo(
        this: *mut SkPathBuilder,
        pt1: SkPoint,
        pt2: SkPoint,
    ) -> *mut SkPathBuilder;
}
extern "C" {
    #[link_name = "\u{1}__ZN13SkPathBuilder8rConicToE7SkPointS0_f"]
    pub fn SkPathBuilder_rConicTo(
        this: *mut SkPathBuilder,
        p1: SkPoint,
        p2: SkPoint,
        w: SkScalar,
    ) -> *mut SkPathBuilder;
}
extern "C" {
    #[link_name = "\u{1}__ZN13SkPathBuilder8rCubicToE7SkPointS0_S0_"]
    pub fn SkPathBuilder_rCubicTo(
        this: *mut SkPathBuilder,
        pt1: SkPoint,
        pt2: SkPoint,
        pt3: SkPoint,
    ) -> *mut SkPathBuilder;
}
extern "C" {
    #[link_name = "\u{1}__ZN13SkPathBuilder5arcToERK6SkRectffb"]
    pub fn SkPathBuilder_arcTo(
        this: *mut SkPathBuilder,
        oval: *const SkRect,
        startAngleDeg: SkScalar,
        sweepAngleDeg: SkScalar,
        forceMoveTo: bool,
    ) -> *mut SkPathBuilder;
}
extern "C" {
    #[link_name = "\u{1}__ZN13SkPathBuilder5arcToE7SkPointS0_f"]
    pub fn SkPathBuilder_arcTo1(
        this: *mut SkPathBuilder,
        p1: SkPoint,
        p2: SkPoint,
        radius: SkScalar,
    ) -> *mut SkPathBuilder;
}
extern "C" {
    #[link_name = "\u{1}__ZN13SkPathBuilder5arcToE7SkPointfNS_7ArcSizeE15SkPathDirectionS0_"]
    pub fn SkPathBuilder_arcTo2(
        this: *mut SkPathBuilder,
        r: SkPoint,
        xAxisRotate: SkScalar,
        largeArc: SkPathBuilder_ArcSize,
        sweep: SkPathDirection,
        xy: SkPoint,
    ) -> *mut SkPathBuilder;
}
extern "C" {
    #[link_name = "\u{1}__ZN13SkPathBuilder6addArcERK6SkRectff"]
    pub fn SkPathBuilder_addArc(
        this: *mut SkPathBuilder,
        oval: *const SkRect,
        startAngleDeg: SkScalar,
        sweepAngleDeg: SkScalar,
    ) -> *mut SkPathBuilder;
}
extern "C" {
    #[link_name = "\u{1}__ZN13SkPathBuilder7addRectERK6SkRect15SkPathDirectionj"]
    pub fn SkPathBuilder_addRect(
        this: *mut SkPathBuilder,
        arg1: *const SkRect,
        arg2: SkPathDirection,
        startIndex: ::std::os::raw::c_uint,
    ) -> *mut SkPathBuilder;
}
extern "C" {
    #[link_name = "\u{1}__ZN13SkPathBuilder7addOvalERK6SkRect15SkPathDirectionj"]
    pub fn SkPathBuilder_addOval(
        this: *mut SkPathBuilder,
        arg1: *const SkRect,
        arg2: SkPathDirection,
        startIndex: ::std::os::raw::c_uint,
    ) -> *mut SkPathBuilder;
}
extern "C" {
    #[link_name = "\u{1}__ZN13SkPathBuilder8addRRectERK7SkRRect15SkPathDirectionj"]
    pub fn SkPathBuilder_addRRect(
        this: *mut SkPathBuilder,
        arg1: *const SkRRect,
        arg2: SkPathDirection,
        startIndex: ::std::os::raw::c_uint,
    ) -> *mut SkPathBuilder;
}
extern "C" {
    #[link_name = "\u{1}__ZN13SkPathBuilder9addCircleEfff15SkPathDirection"]
    pub fn SkPathBuilder_addCircle(
        this: *mut SkPathBuilder,
        center_x: SkScalar,
        center_y: SkScalar,
        radius: SkScalar,
        dir: SkPathDirection,
    ) -> *mut SkPathBuilder;
}
extern "C" {
    #[link_name = "\u{1}__ZN13SkPathBuilder10addPolygonEPK7SkPointib"]
    pub fn SkPathBuilder_addPolygon(
        this: *mut SkPathBuilder,
        pts: *const SkPoint,
        count: ::std::os::raw::c_int,
        isClosed: bool,
    ) -> *mut SkPathBuilder;
}
extern "C" {
    #[link_name = "\u{1}__ZN13SkPathBuilder7addPathERK6SkPath"]
    pub fn SkPathBuilder_addPath(
        this: *mut SkPathBuilder,
        arg1: *const SkPath,
    ) -> *mut SkPathBuilder;
}
extern "C" {
    #[link_name = "\u{1}__ZN13SkPathBuilder10incReserveEii"]
    pub fn SkPathBuilder_incReserve(
        this: *mut SkPathBuilder,
        extraPtCount: ::std::os::raw::c_int,
        extraVerbCount: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN13SkPathBuilder6offsetEff"]
    pub fn SkPathBuilder_offset(
        this: *mut SkPathBuilder,
        dx: SkScalar,
        dy: SkScalar,
    ) -> *mut SkPathBuilder;
}
extern "C" {
    #[link_name = "\u{1}__ZN13SkPathBuilderC1Ev"]
    pub fn SkPathBuilder_SkPathBuilder(this: *mut SkPathBuilder);
}
extern "C" {
    #[link_name = "\u{1}__ZN13SkPathBuilderC1E14SkPathFillType"]
    pub fn SkPathBuilder_SkPathBuilder1(this: *mut SkPathBuilder, arg1: SkPathFillType);
}
extern "C" {
    #[link_name = "\u{1}__ZN13SkPathBuilderC1ERK6SkPath"]
    pub fn SkPathBuilder_SkPathBuilder2(this: *mut SkPathBuilder, arg1: *const SkPath);
}
extern "C" {
    #[link_name = "\u{1}__ZN13SkPathBuilderD1Ev"]
    pub fn SkPathBuilder_SkPathBuilder_destructor(this: *mut SkPathBuilder);
}
impl SkPathBuilder {
    #[inline]
    pub unsafe fn computeBounds(&self) -> SkRect {
        SkPathBuilder_computeBounds(self)
    }
    #[inline]
    pub unsafe fn snapshot(&self) -> SkPath {
        SkPathBuilder_snapshot(self)
    }
    #[inline]
    pub unsafe fn detach(&mut self) -> SkPath {
        SkPathBuilder_detach(self)
    }
    #[inline]
    pub unsafe fn reset(&mut self) -> *mut SkPathBuilder {
        SkPathBuilder_reset(self)
    }
    #[inline]
    pub unsafe fn moveTo(&mut self, pt: SkPoint) -> *mut SkPathBuilder {
        SkPathBuilder_moveTo(self, pt)
    }
    #[inline]
    pub unsafe fn lineTo(&mut self, pt: SkPoint) -> *mut SkPathBuilder {
        SkPathBuilder_lineTo(self, pt)
    }
    #[inline]
    pub unsafe fn quadTo(&mut self, pt1: SkPoint, pt2: SkPoint) -> *mut SkPathBuilder {
        SkPathBuilder_quadTo(self, pt1, pt2)
    }
    #[inline]
    pub unsafe fn conicTo(
        &mut self,
        pt1: SkPoint,
        pt2: SkPoint,
        w: SkScalar,
    ) -> *mut SkPathBuilder {
        SkPathBuilder_conicTo(self, pt1, pt2, w)
    }
    #[inline]
    pub unsafe fn cubicTo(
        &mut self,
        pt1: SkPoint,
        pt2: SkPoint,
        pt3: SkPoint,
    ) -> *mut SkPathBuilder {
        SkPathBuilder_cubicTo(self, pt1, pt2, pt3)
    }
    #[inline]
    pub unsafe fn close(&mut self) -> *mut SkPathBuilder {
        SkPathBuilder_close(self)
    }
    #[inline]
    pub unsafe fn polylineTo(
        &mut self,
        pts: *const SkPoint,
        count: ::std::os::raw::c_int,
    ) -> *mut SkPathBuilder {
        SkPathBuilder_polylineTo(self, pts, count)
    }
    #[inline]
    pub unsafe fn rLineTo(&mut self, pt: SkPoint) -> *mut SkPathBuilder {
        SkPathBuilder_rLineTo(self, pt)
    }
    #[inline]
    pub unsafe fn rQuadTo(&mut self, pt1: SkPoint, pt2: SkPoint) -> *mut SkPathBuilder {
        SkPathBuilder_rQuadTo(self, pt1, pt2)
    }
    #[inline]
    pub unsafe fn rConicTo(&mut self, p1: SkPoint, p2: SkPoint, w: SkScalar) -> *mut SkPathBuilder {
        SkPathBuilder_rConicTo(self, p1, p2, w)
    }
    #[inline]
    pub unsafe fn rCubicTo(
        &mut self,
        pt1: SkPoint,
        pt2: SkPoint,
        pt3: SkPoint,
    ) -> *mut SkPathBuilder {
        SkPathBuilder_rCubicTo(self, pt1, pt2, pt3)
    }
    #[inline]
    pub unsafe fn arcTo(
        &mut self,
        oval: *const SkRect,
        startAngleDeg: SkScalar,
        sweepAngleDeg: SkScalar,
        forceMoveTo: bool,
    ) -> *mut SkPathBuilder {
        SkPathBuilder_arcTo(self, oval, startAngleDeg, sweepAngleDeg, forceMoveTo)
    }
    #[inline]
    pub unsafe fn arcTo1(
        &mut self,
        p1: SkPoint,
        p2: SkPoint,
        radius: SkScalar,
    ) -> *mut SkPathBuilder {
        SkPathBuilder_arcTo1(self, p1, p2, radius)
    }
    #[inline]
    pub unsafe fn arcTo2(
        &mut self,
        r: SkPoint,
        xAxisRotate: SkScalar,
        largeArc: SkPathBuilder_ArcSize,
        sweep: SkPathDirection,
        xy: SkPoint,
    ) -> *mut SkPathBuilder {
        SkPathBuilder_arcTo2(self, r, xAxisRotate, largeArc, sweep, xy)
    }
    #[inline]
    pub unsafe fn addArc(
        &mut self,
        oval: *const SkRect,
        startAngleDeg: SkScalar,
        sweepAngleDeg: SkScalar,
    ) -> *mut SkPathBuilder {
        SkPathBuilder_addArc(self, oval, startAngleDeg, sweepAngleDeg)
    }
    #[inline]
    pub unsafe fn addRect(
        &mut self,
        arg1: *const SkRect,
        arg2: SkPathDirection,
        startIndex: ::std::os::raw::c_uint,
    ) -> *mut SkPathBuilder {
        SkPathBuilder_addRect(self, arg1, arg2, startIndex)
    }
    #[inline]
    pub unsafe fn addOval(
        &mut self,
        arg1: *const SkRect,
        arg2: SkPathDirection,
        startIndex: ::std::os::raw::c_uint,
    ) -> *mut SkPathBuilder {
        SkPathBuilder_addOval(self, arg1, arg2, startIndex)
    }
    #[inline]
    pub unsafe fn addRRect(
        &mut self,
        arg1: *const SkRRect,
        arg2: SkPathDirection,
        startIndex: ::std::os::raw::c_uint,
    ) -> *mut SkPathBuilder {
        SkPathBuilder_addRRect(self, arg1, arg2, startIndex)
    }
    #[inline]
    pub unsafe fn addCircle(
        &mut self,
        center_x: SkScalar,
        center_y: SkScalar,
        radius: SkScalar,
        dir: SkPathDirection,
    ) -> *mut SkPathBuilder {
        SkPathBuilder_addCircle(self, center_x, center_y, radius, dir)
    }
    #[inline]
    pub unsafe fn addPolygon(
        &mut self,
        pts: *const SkPoint,
        count: ::std::os::raw::c_int,
        isClosed: bool,
    ) -> *mut SkPathBuilder {
        SkPathBuilder_addPolygon(self, pts, count, isClosed)
    }
    #[inline]
    pub unsafe fn addPath(&mut self, arg1: *const SkPath) -> *mut SkPathBuilder {
        SkPathBuilder_addPath(self, arg1)
    }
    #[inline]
    pub unsafe fn incReserve(
        &mut self,
        extraPtCount: ::std::os::raw::c_int,
        extraVerbCount: ::std::os::raw::c_int,
    ) {
        SkPathBuilder_incReserve(self, extraPtCount, extraVerbCount)
    }
    #[inline]
    pub unsafe fn offset(&mut self, dx: SkScalar, dy: SkScalar) -> *mut SkPathBuilder {
        SkPathBuilder_offset(self, dx, dy)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkPathBuilder_SkPathBuilder(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(arg1: SkPathFillType) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkPathBuilder_SkPathBuilder1(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(arg1: *const SkPath) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkPathBuilder_SkPathBuilder2(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        SkPathBuilder_SkPathBuilder_destructor(self)
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct SkPathMeasure {
    pub fIter: SkContourMeasureIter,
    pub fContour: sk_sp<SkContourMeasure>,
}
pub const SkPathMeasure_MatrixFlags_kGetPosition_MatrixFlag: SkPathMeasure_MatrixFlags = 1;
pub const SkPathMeasure_MatrixFlags_kGetTangent_MatrixFlag: SkPathMeasure_MatrixFlags = 2;
pub const SkPathMeasure_MatrixFlags_kGetPosAndTan_MatrixFlag: SkPathMeasure_MatrixFlags = 3;
pub type SkPathMeasure_MatrixFlags = ::std::os::raw::c_uint;
#[test]
fn bindgen_test_layout_SkPathMeasure() {
    assert_eq!(
        ::core::mem::size_of::<SkPathMeasure>(),
        16usize,
        concat!("Size of: ", stringify!(SkPathMeasure))
    );
    assert_eq!(
        ::core::mem::align_of::<SkPathMeasure>(),
        8usize,
        concat!("Alignment of ", stringify!(SkPathMeasure))
    );
    fn test_field_fIter() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkPathMeasure>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fIter) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SkPathMeasure),
                "::",
                stringify!(fIter)
            )
        );
    }
    test_field_fIter();
    fn test_field_fContour() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkPathMeasure>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fContour) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(SkPathMeasure),
                "::",
                stringify!(fContour)
            )
        );
    }
    test_field_fContour();
}
extern "C" {
    #[link_name = "\u{1}__ZN13SkPathMeasure7setPathEPK6SkPathb"]
    pub fn SkPathMeasure_setPath(this: *mut SkPathMeasure, arg1: *const SkPath, forceClosed: bool);
}
extern "C" {
    #[link_name = "\u{1}__ZN13SkPathMeasure9getLengthEv"]
    pub fn SkPathMeasure_getLength(this: *mut SkPathMeasure) -> SkScalar;
}
extern "C" {
    #[link_name = "\u{1}__ZN13SkPathMeasure9getPosTanEfP7SkPointS1_"]
    pub fn SkPathMeasure_getPosTan(
        this: *mut SkPathMeasure,
        distance: SkScalar,
        position: *mut SkPoint,
        tangent: *mut SkVector,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN13SkPathMeasure9getMatrixEfP8SkMatrixNS_11MatrixFlagsE"]
    pub fn SkPathMeasure_getMatrix(
        this: *mut SkPathMeasure,
        distance: SkScalar,
        matrix: *mut SkMatrix,
        flags: SkPathMeasure_MatrixFlags,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN13SkPathMeasure10getSegmentEffP6SkPathb"]
    pub fn SkPathMeasure_getSegment(
        this: *mut SkPathMeasure,
        startD: SkScalar,
        stopD: SkScalar,
        dst: *mut SkPath,
        startWithMoveTo: bool,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN13SkPathMeasure8isClosedEv"]
    pub fn SkPathMeasure_isClosed(this: *mut SkPathMeasure) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN13SkPathMeasure11nextContourEv"]
    pub fn SkPathMeasure_nextContour(this: *mut SkPathMeasure) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN13SkPathMeasureC1Ev"]
    pub fn SkPathMeasure_SkPathMeasure(this: *mut SkPathMeasure);
}
extern "C" {
    #[link_name = "\u{1}__ZN13SkPathMeasureC1ERK6SkPathbf"]
    pub fn SkPathMeasure_SkPathMeasure1(
        this: *mut SkPathMeasure,
        path: *const SkPath,
        forceClosed: bool,
        resScale: SkScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN13SkPathMeasureD1Ev"]
    pub fn SkPathMeasure_SkPathMeasure_destructor(this: *mut SkPathMeasure);
}
impl SkPathMeasure {
    #[inline]
    pub unsafe fn setPath(&mut self, arg1: *const SkPath, forceClosed: bool) {
        SkPathMeasure_setPath(self, arg1, forceClosed)
    }
    #[inline]
    pub unsafe fn getLength(&mut self) -> SkScalar {
        SkPathMeasure_getLength(self)
    }
    #[inline]
    pub unsafe fn getPosTan(
        &mut self,
        distance: SkScalar,
        position: *mut SkPoint,
        tangent: *mut SkVector,
    ) -> bool {
        SkPathMeasure_getPosTan(self, distance, position, tangent)
    }
    #[inline]
    pub unsafe fn getMatrix(
        &mut self,
        distance: SkScalar,
        matrix: *mut SkMatrix,
        flags: SkPathMeasure_MatrixFlags,
    ) -> bool {
        SkPathMeasure_getMatrix(self, distance, matrix, flags)
    }
    #[inline]
    pub unsafe fn getSegment(
        &mut self,
        startD: SkScalar,
        stopD: SkScalar,
        dst: *mut SkPath,
        startWithMoveTo: bool,
    ) -> bool {
        SkPathMeasure_getSegment(self, startD, stopD, dst, startWithMoveTo)
    }
    #[inline]
    pub unsafe fn isClosed(&mut self) -> bool {
        SkPathMeasure_isClosed(self)
    }
    #[inline]
    pub unsafe fn nextContour(&mut self) -> bool {
        SkPathMeasure_nextContour(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkPathMeasure_SkPathMeasure(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(path: *const SkPath, forceClosed: bool, resScale: SkScalar) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkPathMeasure_SkPathMeasure1(__bindgen_tmp.as_mut_ptr(), path, forceClosed, resScale);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        SkPathMeasure_SkPathMeasure_destructor(self)
    }
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct SkPicture {
    pub _bindgen_opaque_blob: [u64; 3usize],
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct SkPicture_AbortCallback {
    pub _bindgen_opaque_blob: u64,
}
#[test]
fn bindgen_test_layout_SkPicture_AbortCallback() {
    assert_eq!(
        ::core::mem::size_of::<SkPicture_AbortCallback>(),
        8usize,
        concat!("Size of: ", stringify!(SkPicture_AbortCallback))
    );
    assert_eq!(
        ::core::mem::align_of::<SkPicture_AbortCallback>(),
        8usize,
        concat!("Alignment of ", stringify!(SkPicture_AbortCallback))
    );
}
#[test]
fn bindgen_test_layout_SkPicture() {
    assert_eq!(
        ::core::mem::size_of::<SkPicture>(),
        24usize,
        concat!("Size of: ", stringify!(SkPicture))
    );
    assert_eq!(
        ::core::mem::align_of::<SkPicture>(),
        8usize,
        concat!("Alignment of ", stringify!(SkPicture))
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN9SkPicture14MakeFromStreamEP8SkStreamPK15SkDeserialProcs"]
    pub fn SkPicture_MakeFromStream(
        stream: *mut SkStream,
        procs: *const SkDeserialProcs,
    ) -> sk_sp<SkPicture>;
}
extern "C" {
    #[link_name = "\u{1}__ZN9SkPicture12MakeFromDataEPK6SkDataPK15SkDeserialProcs"]
    pub fn SkPicture_MakeFromData(
        data: *const SkData,
        procs: *const SkDeserialProcs,
    ) -> sk_sp<SkPicture>;
}
extern "C" {
    #[link_name = "\u{1}__ZN9SkPicture12MakeFromDataEPKvmPK15SkDeserialProcs"]
    pub fn SkPicture_MakeFromData1(
        data: *const ::core::ffi::c_void,
        size: usize,
        procs: *const SkDeserialProcs,
    ) -> sk_sp<SkPicture>;
}
extern "C" {
    #[link_name = "\u{1}__ZNK9SkPicture9serializeEPK13SkSerialProcs"]
    pub fn SkPicture_serialize(
        this: *const SkPicture,
        procs: *const SkSerialProcs,
    ) -> sk_sp<SkData>;
}
extern "C" {
    #[link_name = "\u{1}__ZNK9SkPicture9serializeEP9SkWStreamPK13SkSerialProcs"]
    pub fn SkPicture_serialize1(
        this: *const SkPicture,
        stream: *mut SkWStream,
        procs: *const SkSerialProcs,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN9SkPicture15MakePlaceholderE6SkRect"]
    pub fn SkPicture_MakePlaceholder(cull: SkRect) -> sk_sp<SkPicture>;
}
extern "C" {
    #[link_name = "\u{1}__ZNK9SkPicture10makeShaderE10SkTileModeS0_12SkFilterModePK8SkMatrixPK6SkRect"]
    pub fn SkPicture_makeShader(
        this: *const SkPicture,
        tmx: SkTileMode,
        tmy: SkTileMode,
        mode: SkFilterMode,
        localMatrix: *const SkMatrix,
        tileRect: *const SkRect,
    ) -> sk_sp<SkShader>;
}
impl SkPicture {
    #[inline]
    pub unsafe fn MakeFromStream(
        stream: *mut SkStream,
        procs: *const SkDeserialProcs,
    ) -> sk_sp<SkPicture> {
        SkPicture_MakeFromStream(stream, procs)
    }
    #[inline]
    pub unsafe fn MakeFromData(
        data: *const SkData,
        procs: *const SkDeserialProcs,
    ) -> sk_sp<SkPicture> {
        SkPicture_MakeFromData(data, procs)
    }
    #[inline]
    pub unsafe fn MakeFromData1(
        data: *const ::core::ffi::c_void,
        size: usize,
        procs: *const SkDeserialProcs,
    ) -> sk_sp<SkPicture> {
        SkPicture_MakeFromData1(data, size, procs)
    }
    #[inline]
    pub unsafe fn serialize(&self, procs: *const SkSerialProcs) -> sk_sp<SkData> {
        SkPicture_serialize(self, procs)
    }
    #[inline]
    pub unsafe fn serialize1(&self, stream: *mut SkWStream, procs: *const SkSerialProcs) {
        SkPicture_serialize1(self, stream, procs)
    }
    #[inline]
    pub unsafe fn MakePlaceholder(cull: SkRect) -> sk_sp<SkPicture> {
        SkPicture_MakePlaceholder(cull)
    }
    #[inline]
    pub unsafe fn makeShader(
        &self,
        tmx: SkTileMode,
        tmy: SkTileMode,
        mode: SkFilterMode,
        localMatrix: *const SkMatrix,
        tileRect: *const SkRect,
    ) -> sk_sp<SkShader> {
        SkPicture_makeShader(self, tmx, tmy, mode, localMatrix, tileRect)
    }
}
extern "C" {
    #[link_name = "\u{1}__ZN9SkPictureD1Ev"]
    pub fn SkPicture_SkPicture_destructor(this: *mut SkPicture);
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct SkBBoxHierarchy {
    pub _bindgen_opaque_blob: [u64; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkBBoxHierarchy_Metadata {
    pub isDraw: bool,
}
#[test]
fn bindgen_test_layout_SkBBoxHierarchy_Metadata() {
    assert_eq!(
        ::core::mem::size_of::<SkBBoxHierarchy_Metadata>(),
        1usize,
        concat!("Size of: ", stringify!(SkBBoxHierarchy_Metadata))
    );
    assert_eq!(
        ::core::mem::align_of::<SkBBoxHierarchy_Metadata>(),
        1usize,
        concat!("Alignment of ", stringify!(SkBBoxHierarchy_Metadata))
    );
    fn test_field_isDraw() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkBBoxHierarchy_Metadata>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).isDraw) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SkBBoxHierarchy_Metadata),
                "::",
                stringify!(isDraw)
            )
        );
    }
    test_field_isDraw();
}
#[test]
fn bindgen_test_layout_SkBBoxHierarchy() {
    assert_eq!(
        ::core::mem::size_of::<SkBBoxHierarchy>(),
        16usize,
        concat!("Size of: ", stringify!(SkBBoxHierarchy))
    );
    assert_eq!(
        ::core::mem::align_of::<SkBBoxHierarchy>(),
        8usize,
        concat!("Alignment of ", stringify!(SkBBoxHierarchy))
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN15SkBBoxHierarchy6insertEPK6SkRectPKNS_8MetadataEi"]
    pub fn SkBBoxHierarchy_insert1(
        this: *mut ::core::ffi::c_void,
        arg1: *const SkRect,
        arg2: *const SkBBoxHierarchy_Metadata,
        N: ::std::os::raw::c_int,
    );
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct SkBBHFactory {
    pub _bindgen_opaque_blob: u64,
}
#[test]
fn bindgen_test_layout_SkBBHFactory() {
    assert_eq!(
        ::core::mem::size_of::<SkBBHFactory>(),
        8usize,
        concat!("Size of: ", stringify!(SkBBHFactory))
    );
    assert_eq!(
        ::core::mem::align_of::<SkBBHFactory>(),
        8usize,
        concat!("Alignment of ", stringify!(SkBBHFactory))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkRecord {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkRecorder {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct SkPictureRecorder {
    pub fActivelyRecording: bool,
    pub fCullRect: SkRect,
    pub fBBH: sk_sp<SkBBoxHierarchy>,
    pub fRecorder: u64,
    pub fRecord: sk_sp<SkRecord>,
}
pub type SkPictureRecorder_FinishFlags = ::std::os::raw::c_uint;
#[test]
fn bindgen_test_layout_SkPictureRecorder() {
    assert_eq!(
        ::core::mem::size_of::<SkPictureRecorder>(),
        48usize,
        concat!("Size of: ", stringify!(SkPictureRecorder))
    );
    assert_eq!(
        ::core::mem::align_of::<SkPictureRecorder>(),
        8usize,
        concat!("Alignment of ", stringify!(SkPictureRecorder))
    );
    fn test_field_fActivelyRecording() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkPictureRecorder>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fActivelyRecording) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SkPictureRecorder),
                "::",
                stringify!(fActivelyRecording)
            )
        );
    }
    test_field_fActivelyRecording();
    fn test_field_fCullRect() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkPictureRecorder>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fCullRect) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(SkPictureRecorder),
                "::",
                stringify!(fCullRect)
            )
        );
    }
    test_field_fCullRect();
    fn test_field_fBBH() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkPictureRecorder>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fBBH) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(SkPictureRecorder),
                "::",
                stringify!(fBBH)
            )
        );
    }
    test_field_fBBH();
    fn test_field_fRecorder() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkPictureRecorder>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fRecorder) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(SkPictureRecorder),
                "::",
                stringify!(fRecorder)
            )
        );
    }
    test_field_fRecorder();
    fn test_field_fRecord() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkPictureRecorder>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fRecord) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(SkPictureRecorder),
                "::",
                stringify!(fRecord)
            )
        );
    }
    test_field_fRecord();
}
extern "C" {
    #[link_name = "\u{1}__ZN17SkPictureRecorder14beginRecordingERK6SkRect5sk_spI15SkBBoxHierarchyE"]
    pub fn SkPictureRecorder_beginRecording(
        this: *mut SkPictureRecorder,
        bounds: *const SkRect,
        bbh: sk_sp<SkBBoxHierarchy>,
    ) -> *mut SkCanvas;
}
extern "C" {
    #[link_name = "\u{1}__ZN17SkPictureRecorder14beginRecordingERK6SkRectP12SkBBHFactory"]
    pub fn SkPictureRecorder_beginRecording1(
        this: *mut SkPictureRecorder,
        bounds: *const SkRect,
        bbhFactory: *mut SkBBHFactory,
    ) -> *mut SkCanvas;
}
extern "C" {
    #[link_name = "\u{1}__ZN17SkPictureRecorder18getRecordingCanvasEv"]
    pub fn SkPictureRecorder_getRecordingCanvas(this: *mut SkPictureRecorder) -> *mut SkCanvas;
}
extern "C" {
    #[link_name = "\u{1}__ZN17SkPictureRecorder24finishRecordingAsPictureEv"]
    pub fn SkPictureRecorder_finishRecordingAsPicture(
        this: *mut SkPictureRecorder,
    ) -> sk_sp<SkPicture>;
}
extern "C" {
    #[link_name = "\u{1}__ZN17SkPictureRecorder32finishRecordingAsPictureWithCullERK6SkRect"]
    pub fn SkPictureRecorder_finishRecordingAsPictureWithCull(
        this: *mut SkPictureRecorder,
        cullRect: *const SkRect,
    ) -> sk_sp<SkPicture>;
}
extern "C" {
    #[link_name = "\u{1}__ZN17SkPictureRecorder25finishRecordingAsDrawableEv"]
    pub fn SkPictureRecorder_finishRecordingAsDrawable(
        this: *mut SkPictureRecorder,
    ) -> sk_sp<SkDrawable>;
}
extern "C" {
    #[link_name = "\u{1}__ZN17SkPictureRecorderC1Ev"]
    pub fn SkPictureRecorder_SkPictureRecorder(this: *mut SkPictureRecorder);
}
extern "C" {
    #[link_name = "\u{1}__ZN17SkPictureRecorderD1Ev"]
    pub fn SkPictureRecorder_SkPictureRecorder_destructor(this: *mut SkPictureRecorder);
}
impl SkPictureRecorder {
    #[inline]
    pub unsafe fn beginRecording(
        &mut self,
        bounds: *const SkRect,
        bbh: sk_sp<SkBBoxHierarchy>,
    ) -> *mut SkCanvas {
        SkPictureRecorder_beginRecording(self, bounds, bbh)
    }
    #[inline]
    pub unsafe fn beginRecording1(
        &mut self,
        bounds: *const SkRect,
        bbhFactory: *mut SkBBHFactory,
    ) -> *mut SkCanvas {
        SkPictureRecorder_beginRecording1(self, bounds, bbhFactory)
    }
    #[inline]
    pub unsafe fn getRecordingCanvas(&mut self) -> *mut SkCanvas {
        SkPictureRecorder_getRecordingCanvas(self)
    }
    #[inline]
    pub unsafe fn finishRecordingAsPicture(&mut self) -> sk_sp<SkPicture> {
        SkPictureRecorder_finishRecordingAsPicture(self)
    }
    #[inline]
    pub unsafe fn finishRecordingAsPictureWithCull(
        &mut self,
        cullRect: *const SkRect,
    ) -> sk_sp<SkPicture> {
        SkPictureRecorder_finishRecordingAsPictureWithCull(self, cullRect)
    }
    #[inline]
    pub unsafe fn finishRecordingAsDrawable(&mut self) -> sk_sp<SkDrawable> {
        SkPictureRecorder_finishRecordingAsDrawable(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkPictureRecorder_SkPictureRecorder(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        SkPictureRecorder_SkPictureRecorder_destructor(self)
    }
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct SkMutex {
    pub _bindgen_opaque_blob: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_SkMutex() {
    assert_eq!(
        ::core::mem::size_of::<SkMutex>(),
        16usize,
        concat!("Size of: ", stringify!(SkMutex))
    );
    assert_eq!(
        ::core::mem::align_of::<SkMutex>(),
        8usize,
        concat!("Alignment of ", stringify!(SkMutex))
    );
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct SkIDChangeListener {
    pub _bindgen_opaque_blob: [u64; 2usize],
}
#[repr(C)]
#[derive(Debug)]
pub struct SkIDChangeListener_List {
    pub fMutex: SkMutex,
    pub fListeners: SkTDArray<*mut SkIDChangeListener>,
}
#[test]
fn bindgen_test_layout_SkIDChangeListener_List() {
    assert_eq!(
        ::core::mem::size_of::<SkIDChangeListener_List>(),
        32usize,
        concat!("Size of: ", stringify!(SkIDChangeListener_List))
    );
    assert_eq!(
        ::core::mem::align_of::<SkIDChangeListener_List>(),
        8usize,
        concat!("Alignment of ", stringify!(SkIDChangeListener_List))
    );
    fn test_field_fMutex() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkIDChangeListener_List>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fMutex) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SkIDChangeListener_List),
                "::",
                stringify!(fMutex)
            )
        );
    }
    test_field_fMutex();
    fn test_field_fListeners() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkIDChangeListener_List>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fListeners) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(SkIDChangeListener_List),
                "::",
                stringify!(fListeners)
            )
        );
    }
    test_field_fListeners();
}
extern "C" {
    #[link_name = "\u{1}__ZN18SkIDChangeListener4List3addE5sk_spIS_E"]
    pub fn SkIDChangeListener_List_add(
        this: *mut SkIDChangeListener_List,
        listener: sk_sp<SkIDChangeListener>,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNK18SkIDChangeListener4List5countEv"]
    pub fn SkIDChangeListener_List_count(
        this: *const SkIDChangeListener_List,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__ZN18SkIDChangeListener4List7changedEv"]
    pub fn SkIDChangeListener_List_changed(this: *mut SkIDChangeListener_List);
}
extern "C" {
    #[link_name = "\u{1}__ZN18SkIDChangeListener4List5resetEv"]
    pub fn SkIDChangeListener_List_reset(this: *mut SkIDChangeListener_List);
}
extern "C" {
    #[link_name = "\u{1}__ZN18SkIDChangeListener4ListC1Ev"]
    pub fn SkIDChangeListener_List_List(this: *mut SkIDChangeListener_List);
}
extern "C" {
    #[link_name = "\u{1}__ZN18SkIDChangeListener4ListD1Ev"]
    pub fn SkIDChangeListener_List_List_destructor(this: *mut SkIDChangeListener_List);
}
impl SkIDChangeListener_List {
    #[inline]
    pub unsafe fn add(&mut self, listener: sk_sp<SkIDChangeListener>) {
        SkIDChangeListener_List_add(self, listener)
    }
    #[inline]
    pub unsafe fn count(&self) -> ::std::os::raw::c_int {
        SkIDChangeListener_List_count(self)
    }
    #[inline]
    pub unsafe fn changed(&mut self) {
        SkIDChangeListener_List_changed(self)
    }
    #[inline]
    pub unsafe fn reset(&mut self) {
        SkIDChangeListener_List_reset(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkIDChangeListener_List_List(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        SkIDChangeListener_List_List_destructor(self)
    }
}
#[test]
fn bindgen_test_layout_SkIDChangeListener() {
    assert_eq!(
        ::core::mem::size_of::<SkIDChangeListener>(),
        16usize,
        concat!("Size of: ", stringify!(SkIDChangeListener))
    );
    assert_eq!(
        ::core::mem::align_of::<SkIDChangeListener>(),
        8usize,
        concat!("Alignment of ", stringify!(SkIDChangeListener))
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN18SkIDChangeListenerC2Ev"]
    pub fn SkIDChangeListener_SkIDChangeListener(this: *mut SkIDChangeListener);
}
impl SkIDChangeListener {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkIDChangeListener_SkIDChangeListener(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}__ZN18SkIDChangeListenerD1Ev"]
    pub fn SkIDChangeListener_SkIDChangeListener_destructor(this: *mut SkIDChangeListener);
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct SkPixelRef {
    pub _bindgen_opaque_blob: [u64; 11usize],
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkPixelRef_Mutability {
    kMutable = 0,
    kTemporarilyImmutable = 1,
    kImmutable = 2,
}
pub type SkPixelRef_INHERITED = SkRefCnt;
#[test]
fn bindgen_test_layout_SkPixelRef() {
    assert_eq!(
        ::core::mem::size_of::<SkPixelRef>(),
        88usize,
        concat!("Size of: ", stringify!(SkPixelRef))
    );
    assert_eq!(
        ::core::mem::align_of::<SkPixelRef>(),
        8usize,
        concat!("Alignment of ", stringify!(SkPixelRef))
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNK10SkPixelRef15getGenerationIDEv"]
    pub fn SkPixelRef_getGenerationID(this: *const SkPixelRef) -> u32;
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkPixelRef19notifyPixelsChangedEv"]
    pub fn SkPixelRef_notifyPixelsChanged(this: *mut SkPixelRef);
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkPixelRef12setImmutableEv"]
    pub fn SkPixelRef_setImmutable(this: *mut SkPixelRef);
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkPixelRef22addGenIDChangeListenerE5sk_spI18SkIDChangeListenerE"]
    pub fn SkPixelRef_addGenIDChangeListener(
        this: *mut SkPixelRef,
        listener: sk_sp<SkIDChangeListener>,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkPixelRef18android_only_resetEiim"]
    pub fn SkPixelRef_android_only_reset(
        this: *mut SkPixelRef,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        rowBytes: usize,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkPixelRefC1EiiPvm"]
    pub fn SkPixelRef_SkPixelRef(
        this: *mut SkPixelRef,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        addr: *mut ::core::ffi::c_void,
        rowBytes: usize,
    );
}
impl SkPixelRef {
    #[inline]
    pub unsafe fn getGenerationID(&self) -> u32 {
        SkPixelRef_getGenerationID(self)
    }
    #[inline]
    pub unsafe fn notifyPixelsChanged(&mut self) {
        SkPixelRef_notifyPixelsChanged(self)
    }
    #[inline]
    pub unsafe fn setImmutable(&mut self) {
        SkPixelRef_setImmutable(self)
    }
    #[inline]
    pub unsafe fn addGenIDChangeListener(&mut self, listener: sk_sp<SkIDChangeListener>) {
        SkPixelRef_addGenIDChangeListener(self, listener)
    }
    #[inline]
    pub unsafe fn android_only_reset(
        &mut self,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        rowBytes: usize,
    ) {
        SkPixelRef_android_only_reset(self, width, height, rowBytes)
    }
    #[inline]
    pub unsafe fn new(
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        addr: *mut ::core::ffi::c_void,
        rowBytes: usize,
    ) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkPixelRef_SkPixelRef(__bindgen_tmp.as_mut_ptr(), width, height, addr, rowBytes);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkPixelRefD1Ev"]
    pub fn SkPixelRef_SkPixelRef_destructor(this: *mut SkPixelRef);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkPoint3 {
    pub fX: SkScalar,
    pub fY: SkScalar,
    pub fZ: SkScalar,
}
#[test]
fn bindgen_test_layout_SkPoint3() {
    assert_eq!(
        ::core::mem::size_of::<SkPoint3>(),
        12usize,
        concat!("Size of: ", stringify!(SkPoint3))
    );
    assert_eq!(
        ::core::mem::align_of::<SkPoint3>(),
        4usize,
        concat!("Alignment of ", stringify!(SkPoint3))
    );
    fn test_field_fX() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkPoint3>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fX) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SkPoint3),
                "::",
                stringify!(fX)
            )
        );
    }
    test_field_fX();
    fn test_field_fY() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkPoint3>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fY) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(SkPoint3),
                "::",
                stringify!(fY)
            )
        );
    }
    test_field_fY();
    fn test_field_fZ() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkPoint3>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fZ) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(SkPoint3),
                "::",
                stringify!(fZ)
            )
        );
    }
    test_field_fZ();
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkPoint36LengthEfff"]
    pub fn SkPoint3_Length(x: SkScalar, y: SkScalar, z: SkScalar) -> SkScalar;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkPoint39normalizeEv"]
    pub fn SkPoint3_normalize(this: *mut SkPoint3) -> bool;
}
impl SkPoint3 {
    #[inline]
    pub unsafe fn Length(x: SkScalar, y: SkScalar, z: SkScalar) -> SkScalar {
        SkPoint3_Length(x, y, z)
    }
    #[inline]
    pub unsafe fn normalize(&mut self) -> bool {
        SkPoint3_normalize(self)
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct SkRegion {
    pub fBounds: SkIRect,
    pub fRunHead: *mut SkRegion_RunHead,
}
pub type SkRegion_RunType = i32;
impl SkRegion_Op {
    pub const LastOp: SkRegion_Op = SkRegion_Op::Replace;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkRegion_Op {
    Difference = 0,
    Intersect = 1,
    Union = 2,
    XOR = 3,
    ReverseDifference = 4,
    Replace = 5,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkRegion_Iterator {
    pub fRgn: *const SkRegion,
    pub fRuns: *const SkRegion_RunType,
    pub fRect: SkIRect,
    pub fDone: bool,
}
#[test]
fn bindgen_test_layout_SkRegion_Iterator() {
    assert_eq!(
        ::core::mem::size_of::<SkRegion_Iterator>(),
        40usize,
        concat!("Size of: ", stringify!(SkRegion_Iterator))
    );
    assert_eq!(
        ::core::mem::align_of::<SkRegion_Iterator>(),
        8usize,
        concat!("Alignment of ", stringify!(SkRegion_Iterator))
    );
    fn test_field_fRgn() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkRegion_Iterator>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fRgn) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SkRegion_Iterator),
                "::",
                stringify!(fRgn)
            )
        );
    }
    test_field_fRgn();
    fn test_field_fRuns() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkRegion_Iterator>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fRuns) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(SkRegion_Iterator),
                "::",
                stringify!(fRuns)
            )
        );
    }
    test_field_fRuns();
    fn test_field_fRect() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkRegion_Iterator>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fRect) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(SkRegion_Iterator),
                "::",
                stringify!(fRect)
            )
        );
    }
    test_field_fRect();
    fn test_field_fDone() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkRegion_Iterator>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fDone) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(SkRegion_Iterator),
                "::",
                stringify!(fDone)
            )
        );
    }
    test_field_fDone();
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkRegion8Iterator6rewindEv"]
    pub fn SkRegion_Iterator_rewind(this: *mut SkRegion_Iterator) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkRegion8Iterator5resetERKS_"]
    pub fn SkRegion_Iterator_reset(this: *mut SkRegion_Iterator, region: *const SkRegion);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkRegion8Iterator4nextEv"]
    pub fn SkRegion_Iterator_next(this: *mut SkRegion_Iterator);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkRegion8IteratorC1ERKS_"]
    pub fn SkRegion_Iterator_Iterator(this: *mut SkRegion_Iterator, region: *const SkRegion);
}
impl SkRegion_Iterator {
    #[inline]
    pub unsafe fn rewind(&mut self) -> bool {
        SkRegion_Iterator_rewind(self)
    }
    #[inline]
    pub unsafe fn reset(&mut self, region: *const SkRegion) {
        SkRegion_Iterator_reset(self, region)
    }
    #[inline]
    pub unsafe fn next(&mut self) {
        SkRegion_Iterator_next(self)
    }
    #[inline]
    pub unsafe fn new(region: *const SkRegion) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkRegion_Iterator_Iterator(__bindgen_tmp.as_mut_ptr(), region);
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkRegion_Cliperator {
    pub fIter: SkRegion_Iterator,
    pub fClip: SkIRect,
    pub fRect: SkIRect,
    pub fDone: bool,
}
#[test]
fn bindgen_test_layout_SkRegion_Cliperator() {
    assert_eq!(
        ::core::mem::size_of::<SkRegion_Cliperator>(),
        80usize,
        concat!("Size of: ", stringify!(SkRegion_Cliperator))
    );
    assert_eq!(
        ::core::mem::align_of::<SkRegion_Cliperator>(),
        8usize,
        concat!("Alignment of ", stringify!(SkRegion_Cliperator))
    );
    fn test_field_fIter() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkRegion_Cliperator>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fIter) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SkRegion_Cliperator),
                "::",
                stringify!(fIter)
            )
        );
    }
    test_field_fIter();
    fn test_field_fClip() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkRegion_Cliperator>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fClip) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(SkRegion_Cliperator),
                "::",
                stringify!(fClip)
            )
        );
    }
    test_field_fClip();
    fn test_field_fRect() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkRegion_Cliperator>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fRect) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(SkRegion_Cliperator),
                "::",
                stringify!(fRect)
            )
        );
    }
    test_field_fRect();
    fn test_field_fDone() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkRegion_Cliperator>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fDone) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(SkRegion_Cliperator),
                "::",
                stringify!(fDone)
            )
        );
    }
    test_field_fDone();
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkRegion10Cliperator4nextEv"]
    pub fn SkRegion_Cliperator_next(this: *mut SkRegion_Cliperator);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkRegion10CliperatorC1ERKS_RK7SkIRect"]
    pub fn SkRegion_Cliperator_Cliperator(
        this: *mut SkRegion_Cliperator,
        region: *const SkRegion,
        clip: *const SkIRect,
    );
}
impl SkRegion_Cliperator {
    #[inline]
    pub unsafe fn next(&mut self) {
        SkRegion_Cliperator_next(self)
    }
    #[inline]
    pub unsafe fn new(region: *const SkRegion, clip: *const SkIRect) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkRegion_Cliperator_Cliperator(__bindgen_tmp.as_mut_ptr(), region, clip);
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkRegion_Spanerator {
    pub fRuns: *const SkRegion_RunType,
    pub fLeft: ::std::os::raw::c_int,
    pub fRight: ::std::os::raw::c_int,
    pub fDone: bool,
}
#[test]
fn bindgen_test_layout_SkRegion_Spanerator() {
    assert_eq!(
        ::core::mem::size_of::<SkRegion_Spanerator>(),
        24usize,
        concat!("Size of: ", stringify!(SkRegion_Spanerator))
    );
    assert_eq!(
        ::core::mem::align_of::<SkRegion_Spanerator>(),
        8usize,
        concat!("Alignment of ", stringify!(SkRegion_Spanerator))
    );
    fn test_field_fRuns() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkRegion_Spanerator>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fRuns) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SkRegion_Spanerator),
                "::",
                stringify!(fRuns)
            )
        );
    }
    test_field_fRuns();
    fn test_field_fLeft() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkRegion_Spanerator>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fLeft) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(SkRegion_Spanerator),
                "::",
                stringify!(fLeft)
            )
        );
    }
    test_field_fLeft();
    fn test_field_fRight() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkRegion_Spanerator>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fRight) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(SkRegion_Spanerator),
                "::",
                stringify!(fRight)
            )
        );
    }
    test_field_fRight();
    fn test_field_fDone() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkRegion_Spanerator>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fDone) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(SkRegion_Spanerator),
                "::",
                stringify!(fDone)
            )
        );
    }
    test_field_fDone();
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkRegion10Spanerator4nextEPiS1_"]
    pub fn SkRegion_Spanerator_next(
        this: *mut SkRegion_Spanerator,
        left: *mut ::std::os::raw::c_int,
        right: *mut ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkRegion10SpaneratorC1ERKS_iii"]
    pub fn SkRegion_Spanerator_Spanerator(
        this: *mut SkRegion_Spanerator,
        region: *const SkRegion,
        y: ::std::os::raw::c_int,
        left: ::std::os::raw::c_int,
        right: ::std::os::raw::c_int,
    );
}
impl SkRegion_Spanerator {
    #[inline]
    pub unsafe fn next(
        &mut self,
        left: *mut ::std::os::raw::c_int,
        right: *mut ::std::os::raw::c_int,
    ) -> bool {
        SkRegion_Spanerator_next(self, left, right)
    }
    #[inline]
    pub unsafe fn new(
        region: *const SkRegion,
        y: ::std::os::raw::c_int,
        left: ::std::os::raw::c_int,
        right: ::std::os::raw::c_int,
    ) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkRegion_Spanerator_Spanerator(__bindgen_tmp.as_mut_ptr(), region, y, left, right);
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkRegion_RunHead {
    _unused: [u8; 0],
}
pub const SkRegion_kOpCnt: ::std::os::raw::c_int = 6;
pub const SkRegion_kOpCount: ::std::os::raw::c_int = 6;
pub const SkRegion_kRectRegionRuns: ::std::os::raw::c_int = 7;
extern "C" {
    #[link_name = "\u{1}__ZN8SkRegion15kRectRunHeadPtrE"]
    pub static SkRegion_kRectRunHeadPtr: *mut SkRegion_RunHead;
}
#[test]
fn bindgen_test_layout_SkRegion() {
    assert_eq!(
        ::core::mem::size_of::<SkRegion>(),
        24usize,
        concat!("Size of: ", stringify!(SkRegion))
    );
    assert_eq!(
        ::core::mem::align_of::<SkRegion>(),
        8usize,
        concat!("Alignment of ", stringify!(SkRegion))
    );
    fn test_field_fBounds() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkRegion>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fBounds) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SkRegion),
                "::",
                stringify!(fBounds)
            )
        );
    }
    test_field_fBounds();
    fn test_field_fRunHead() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkRegion>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fRunHead) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(SkRegion),
                "::",
                stringify!(fRunHead)
            )
        );
    }
    test_field_fRunHead();
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkRegion4swapERS_"]
    pub fn SkRegion_swap(this: *mut SkRegion, other: *mut SkRegion);
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkRegion23computeRegionComplexityEv"]
    pub fn SkRegion_computeRegionComplexity(this: *const SkRegion) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkRegion15getBoundaryPathEP6SkPath"]
    pub fn SkRegion_getBoundaryPath(this: *const SkRegion, path: *mut SkPath) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkRegion8setEmptyEv"]
    pub fn SkRegion_setEmpty(this: *mut SkRegion) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkRegion7setRectERK7SkIRect"]
    pub fn SkRegion_setRect(this: *mut SkRegion, rect: *const SkIRect) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkRegion8setRectsEPK7SkIRecti"]
    pub fn SkRegion_setRects(
        this: *mut SkRegion,
        rects: *const SkIRect,
        count: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkRegion9setRegionERKS_"]
    pub fn SkRegion_setRegion(this: *mut SkRegion, region: *const SkRegion) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkRegion7setPathERK6SkPathRKS_"]
    pub fn SkRegion_setPath(
        this: *mut SkRegion,
        path: *const SkPath,
        clip: *const SkRegion,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkRegion10intersectsERK7SkIRect"]
    pub fn SkRegion_intersects(this: *const SkRegion, rect: *const SkIRect) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkRegion10intersectsERKS_"]
    pub fn SkRegion_intersects1(this: *const SkRegion, other: *const SkRegion) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkRegion8containsEii"]
    pub fn SkRegion_contains(this: *const SkRegion, x: i32, y: i32) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkRegion8containsERK7SkIRect"]
    pub fn SkRegion_contains1(this: *const SkRegion, other: *const SkIRect) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkRegion8containsERKS_"]
    pub fn SkRegion_contains2(this: *const SkRegion, other: *const SkRegion) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkRegion9translateEiiPS_"]
    pub fn SkRegion_translate(
        this: *const SkRegion,
        dx: ::std::os::raw::c_int,
        dy: ::std::os::raw::c_int,
        dst: *mut SkRegion,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkRegion2opERK7SkIRectRKS_NS_2OpE"]
    pub fn SkRegion_op(
        this: *mut SkRegion,
        rect: *const SkIRect,
        rgn: *const SkRegion,
        op: SkRegion_Op,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkRegion2opERKS_RK7SkIRectNS_2OpE"]
    pub fn SkRegion_op1(
        this: *mut SkRegion,
        rgn: *const SkRegion,
        rect: *const SkIRect,
        op: SkRegion_Op,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkRegion2opERKS_S1_NS_2OpE"]
    pub fn SkRegion_op2(
        this: *mut SkRegion,
        rgna: *const SkRegion,
        rgnb: *const SkRegion,
        op: SkRegion_Op,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK8SkRegion13writeToMemoryEPv"]
    pub fn SkRegion_writeToMemory(this: *const SkRegion, buffer: *mut ::core::ffi::c_void)
        -> usize;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkRegion14readFromMemoryEPKvm"]
    pub fn SkRegion_readFromMemory(
        this: *mut SkRegion,
        buffer: *const ::core::ffi::c_void,
        length: usize,
    ) -> usize;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkRegionC1Ev"]
    pub fn SkRegion_SkRegion(this: *mut SkRegion);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkRegionC1ERKS_"]
    pub fn SkRegion_SkRegion1(this: *mut SkRegion, region: *const SkRegion);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkRegionC1ERK7SkIRect"]
    pub fn SkRegion_SkRegion2(this: *mut SkRegion, rect: *const SkIRect);
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkRegionD1Ev"]
    pub fn SkRegion_SkRegion_destructor(this: *mut SkRegion);
}
impl SkRegion {
    #[inline]
    pub unsafe fn swap(&mut self, other: *mut SkRegion) {
        SkRegion_swap(self, other)
    }
    #[inline]
    pub unsafe fn computeRegionComplexity(&self) -> ::std::os::raw::c_int {
        SkRegion_computeRegionComplexity(self)
    }
    #[inline]
    pub unsafe fn getBoundaryPath(&self, path: *mut SkPath) -> bool {
        SkRegion_getBoundaryPath(self, path)
    }
    #[inline]
    pub unsafe fn setEmpty(&mut self) -> bool {
        SkRegion_setEmpty(self)
    }
    #[inline]
    pub unsafe fn setRect(&mut self, rect: *const SkIRect) -> bool {
        SkRegion_setRect(self, rect)
    }
    #[inline]
    pub unsafe fn setRects(&mut self, rects: *const SkIRect, count: ::std::os::raw::c_int) -> bool {
        SkRegion_setRects(self, rects, count)
    }
    #[inline]
    pub unsafe fn setRegion(&mut self, region: *const SkRegion) -> bool {
        SkRegion_setRegion(self, region)
    }
    #[inline]
    pub unsafe fn setPath(&mut self, path: *const SkPath, clip: *const SkRegion) -> bool {
        SkRegion_setPath(self, path, clip)
    }
    #[inline]
    pub unsafe fn intersects(&self, rect: *const SkIRect) -> bool {
        SkRegion_intersects(self, rect)
    }
    #[inline]
    pub unsafe fn intersects1(&self, other: *const SkRegion) -> bool {
        SkRegion_intersects1(self, other)
    }
    #[inline]
    pub unsafe fn contains(&self, x: i32, y: i32) -> bool {
        SkRegion_contains(self, x, y)
    }
    #[inline]
    pub unsafe fn contains1(&self, other: *const SkIRect) -> bool {
        SkRegion_contains1(self, other)
    }
    #[inline]
    pub unsafe fn contains2(&self, other: *const SkRegion) -> bool {
        SkRegion_contains2(self, other)
    }
    #[inline]
    pub unsafe fn translate(
        &self,
        dx: ::std::os::raw::c_int,
        dy: ::std::os::raw::c_int,
        dst: *mut SkRegion,
    ) {
        SkRegion_translate(self, dx, dy, dst)
    }
    #[inline]
    pub unsafe fn op(
        &mut self,
        rect: *const SkIRect,
        rgn: *const SkRegion,
        op: SkRegion_Op,
    ) -> bool {
        SkRegion_op(self, rect, rgn, op)
    }
    #[inline]
    pub unsafe fn op1(
        &mut self,
        rgn: *const SkRegion,
        rect: *const SkIRect,
        op: SkRegion_Op,
    ) -> bool {
        SkRegion_op1(self, rgn, rect, op)
    }
    #[inline]
    pub unsafe fn op2(
        &mut self,
        rgna: *const SkRegion,
        rgnb: *const SkRegion,
        op: SkRegion_Op,
    ) -> bool {
        SkRegion_op2(self, rgna, rgnb, op)
    }
    #[inline]
    pub unsafe fn writeToMemory(&self, buffer: *mut ::core::ffi::c_void) -> usize {
        SkRegion_writeToMemory(self, buffer)
    }
    #[inline]
    pub unsafe fn readFromMemory(
        &mut self,
        buffer: *const ::core::ffi::c_void,
        length: usize,
    ) -> usize {
        SkRegion_readFromMemory(self, buffer, length)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkRegion_SkRegion(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(region: *const SkRegion) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkRegion_SkRegion1(__bindgen_tmp.as_mut_ptr(), region);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(rect: *const SkIRect) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkRegion_SkRegion2(__bindgen_tmp.as_mut_ptr(), rect);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        SkRegion_SkRegion_destructor(self)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkRRect {
    pub fRect: SkRect,
    pub fRadii: [SkVector; 4usize],
    pub fType: i32,
}
impl SkRRect_Type {
    pub const LastType: SkRRect_Type = SkRRect_Type::Complex;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkRRect_Type {
    Empty = 0,
    Rect = 1,
    Oval = 2,
    Simple = 3,
    NinePatch = 4,
    Complex = 5,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkRRect_Corner {
    UpperLeft = 0,
    UpperRight = 1,
    LowerRight = 2,
    LowerLeft = 3,
}
pub const SkRRect_kSizeInMemory: usize = 48;
#[test]
fn bindgen_test_layout_SkRRect() {
    assert_eq!(
        ::core::mem::size_of::<SkRRect>(),
        52usize,
        concat!("Size of: ", stringify!(SkRRect))
    );
    assert_eq!(
        ::core::mem::align_of::<SkRRect>(),
        4usize,
        concat!("Alignment of ", stringify!(SkRRect))
    );
    fn test_field_fRect() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkRRect>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fRect) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SkRRect),
                "::",
                stringify!(fRect)
            )
        );
    }
    test_field_fRect();
    fn test_field_fRadii() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkRRect>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fRadii) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(SkRRect),
                "::",
                stringify!(fRadii)
            )
        );
    }
    test_field_fRadii();
    fn test_field_fType() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkRRect>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fType) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(SkRRect),
                "::",
                stringify!(fType)
            )
        );
    }
    test_field_fType();
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkRRect7setOvalERK6SkRect"]
    pub fn SkRRect_setOval(this: *mut SkRRect, oval: *const SkRect);
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkRRect9setRectXYERK6SkRectff"]
    pub fn SkRRect_setRectXY(
        this: *mut SkRRect,
        rect: *const SkRect,
        xRad: SkScalar,
        yRad: SkScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkRRect12setNinePatchERK6SkRectffff"]
    pub fn SkRRect_setNinePatch(
        this: *mut SkRRect,
        rect: *const SkRect,
        leftRad: SkScalar,
        topRad: SkScalar,
        rightRad: SkScalar,
        bottomRad: SkScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkRRect12setRectRadiiERK6SkRectPK7SkPoint"]
    pub fn SkRRect_setRectRadii(this: *mut SkRRect, rect: *const SkRect, radii: *const SkVector);
}
extern "C" {
    #[link_name = "\u{1}__ZNK7SkRRect5insetEffPS_"]
    pub fn SkRRect_inset(this: *const SkRRect, dx: SkScalar, dy: SkScalar, dst: *mut SkRRect);
}
extern "C" {
    #[link_name = "\u{1}__ZNK7SkRRect8containsERK6SkRect"]
    pub fn SkRRect_contains(this: *const SkRRect, rect: *const SkRect) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK7SkRRect7isValidEv"]
    pub fn SkRRect_isValid(this: *const SkRRect) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK7SkRRect13writeToMemoryEPv"]
    pub fn SkRRect_writeToMemory(this: *const SkRRect, buffer: *mut ::core::ffi::c_void) -> usize;
}
extern "C" {
    #[link_name = "\u{1}__ZN7SkRRect14readFromMemoryEPKvm"]
    pub fn SkRRect_readFromMemory(
        this: *mut SkRRect,
        buffer: *const ::core::ffi::c_void,
        length: usize,
    ) -> usize;
}
extern "C" {
    #[link_name = "\u{1}__ZNK7SkRRect9transformERK8SkMatrixPS_"]
    pub fn SkRRect_transform(
        this: *const SkRRect,
        matrix: *const SkMatrix,
        dst: *mut SkRRect,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK7SkRRect4dumpEb"]
    pub fn SkRRect_dump(this: *const SkRRect, asHex: bool);
}
extern "C" {
    #[link_name = "\u{1}__ZNK7SkRRect12dumpToStringEb"]
    pub fn SkRRect_dumpToString(this: *const SkRRect, asHex: bool) -> SkString;
}
impl SkRRect {
    #[inline]
    pub unsafe fn setOval(&mut self, oval: *const SkRect) {
        SkRRect_setOval(self, oval)
    }
    #[inline]
    pub unsafe fn setRectXY(&mut self, rect: *const SkRect, xRad: SkScalar, yRad: SkScalar) {
        SkRRect_setRectXY(self, rect, xRad, yRad)
    }
    #[inline]
    pub unsafe fn setNinePatch(
        &mut self,
        rect: *const SkRect,
        leftRad: SkScalar,
        topRad: SkScalar,
        rightRad: SkScalar,
        bottomRad: SkScalar,
    ) {
        SkRRect_setNinePatch(self, rect, leftRad, topRad, rightRad, bottomRad)
    }
    #[inline]
    pub unsafe fn setRectRadii(&mut self, rect: *const SkRect, radii: *const SkVector) {
        SkRRect_setRectRadii(self, rect, radii)
    }
    #[inline]
    pub unsafe fn inset(&self, dx: SkScalar, dy: SkScalar, dst: *mut SkRRect) {
        SkRRect_inset(self, dx, dy, dst)
    }
    #[inline]
    pub unsafe fn contains(&self, rect: *const SkRect) -> bool {
        SkRRect_contains(self, rect)
    }
    #[inline]
    pub unsafe fn isValid(&self) -> bool {
        SkRRect_isValid(self)
    }
    #[inline]
    pub unsafe fn writeToMemory(&self, buffer: *mut ::core::ffi::c_void) -> usize {
        SkRRect_writeToMemory(self, buffer)
    }
    #[inline]
    pub unsafe fn readFromMemory(
        &mut self,
        buffer: *const ::core::ffi::c_void,
        length: usize,
    ) -> usize {
        SkRRect_readFromMemory(self, buffer, length)
    }
    #[inline]
    pub unsafe fn transform(&self, matrix: *const SkMatrix, dst: *mut SkRRect) -> bool {
        SkRRect_transform(self, matrix, dst)
    }
    #[inline]
    pub unsafe fn dump(&self, asHex: bool) {
        SkRRect_dump(self, asHex)
    }
    #[inline]
    pub unsafe fn dumpToString(&self, asHex: bool) -> SkString {
        SkRRect_dumpToString(self, asHex)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkRSXform {
    pub fSCos: SkScalar,
    pub fSSin: SkScalar,
    pub fTx: SkScalar,
    pub fTy: SkScalar,
}
#[test]
fn bindgen_test_layout_SkRSXform() {
    assert_eq!(
        ::core::mem::size_of::<SkRSXform>(),
        16usize,
        concat!("Size of: ", stringify!(SkRSXform))
    );
    assert_eq!(
        ::core::mem::align_of::<SkRSXform>(),
        4usize,
        concat!("Alignment of ", stringify!(SkRSXform))
    );
    fn test_field_fSCos() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkRSXform>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fSCos) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SkRSXform),
                "::",
                stringify!(fSCos)
            )
        );
    }
    test_field_fSCos();
    fn test_field_fSSin() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkRSXform>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fSSin) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(SkRSXform),
                "::",
                stringify!(fSSin)
            )
        );
    }
    test_field_fSSin();
    fn test_field_fTx() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkRSXform>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fTx) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(SkRSXform),
                "::",
                stringify!(fTx)
            )
        );
    }
    test_field_fTx();
    fn test_field_fTy() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkRSXform>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fTy) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(SkRSXform),
                "::",
                stringify!(fTy)
            )
        );
    }
    test_field_fTy();
}
extern "C" {
    #[link_name = "\u{1}__ZNK9SkRSXform6toQuadEffP7SkPoint"]
    pub fn SkRSXform_toQuad(
        this: *const SkRSXform,
        width: SkScalar,
        height: SkScalar,
        quad: *mut SkPoint,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNK9SkRSXform10toTriStripEffP7SkPoint"]
    pub fn SkRSXform_toTriStrip(
        this: *const SkRSXform,
        width: SkScalar,
        height: SkScalar,
        strip: *mut SkPoint,
    );
}
impl SkRSXform {
    #[inline]
    pub unsafe fn toQuad(&self, width: SkScalar, height: SkScalar, quad: *mut SkPoint) {
        SkRSXform_toQuad(self, width, height, quad)
    }
    #[inline]
    pub unsafe fn toTriStrip(&self, width: SkScalar, height: SkScalar, strip: *mut SkPoint) {
        SkRSXform_toTriStrip(self, width, height, strip)
    }
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct SkStream {
    pub _bindgen_opaque_blob: u64,
}
#[test]
fn bindgen_test_layout_SkStream() {
    assert_eq!(
        ::core::mem::size_of::<SkStream>(),
        8usize,
        concat!("Size of: ", stringify!(SkStream))
    );
    assert_eq!(
        ::core::mem::align_of::<SkStream>(),
        8usize,
        concat!("Alignment of ", stringify!(SkStream))
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkStream12MakeFromFileEPKc"]
    pub fn SkStream_MakeFromFile(path: *const ::std::os::raw::c_char) -> u64;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkStream6readS8EPa"]
    pub fn SkStream_readS8(this: *mut SkStream, arg1: *mut i8) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkStream7readS16EPs"]
    pub fn SkStream_readS16(this: *mut SkStream, arg1: *mut i16) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkStream7readS32EPi"]
    pub fn SkStream_readS32(this: *mut SkStream, arg1: *mut i32) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkStream10readScalarEPf"]
    pub fn SkStream_readScalar(this: *mut SkStream, arg1: *mut SkScalar) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN8SkStream14readPackedUIntEPm"]
    pub fn SkStream_readPackedUInt(this: *mut SkStream, arg1: *mut usize) -> bool;
}
impl SkStream {
    #[inline]
    pub unsafe fn MakeFromFile(path: *const ::std::os::raw::c_char) -> u64 {
        SkStream_MakeFromFile(path)
    }
    #[inline]
    pub unsafe fn readS8(&mut self, arg1: *mut i8) -> bool {
        SkStream_readS8(self, arg1)
    }
    #[inline]
    pub unsafe fn readS16(&mut self, arg1: *mut i16) -> bool {
        SkStream_readS16(self, arg1)
    }
    #[inline]
    pub unsafe fn readS32(&mut self, arg1: *mut i32) -> bool {
        SkStream_readS32(self, arg1)
    }
    #[inline]
    pub unsafe fn readScalar(&mut self, arg1: *mut SkScalar) -> bool {
        SkStream_readScalar(self, arg1)
    }
    #[inline]
    pub unsafe fn readPackedUInt(&mut self, arg1: *mut usize) -> bool {
        SkStream_readPackedUInt(self, arg1)
    }
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct SkStreamAsset {
    pub _bindgen_opaque_blob: u64,
}
#[test]
fn bindgen_test_layout_SkStreamAsset() {
    assert_eq!(
        ::core::mem::size_of::<SkStreamAsset>(),
        8usize,
        concat!("Size of: ", stringify!(SkStreamAsset))
    );
    assert_eq!(
        ::core::mem::align_of::<SkStreamAsset>(),
        8usize,
        concat!("Alignment of ", stringify!(SkStreamAsset))
    );
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct SkStreamMemory {
    pub _bindgen_opaque_blob: u64,
}
#[test]
fn bindgen_test_layout_SkStreamMemory() {
    assert_eq!(
        ::core::mem::size_of::<SkStreamMemory>(),
        8usize,
        concat!("Size of: ", stringify!(SkStreamMemory))
    );
    assert_eq!(
        ::core::mem::align_of::<SkStreamMemory>(),
        8usize,
        concat!("Alignment of ", stringify!(SkStreamMemory))
    );
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct SkWStream {
    pub _bindgen_opaque_blob: u64,
}
#[test]
fn bindgen_test_layout_SkWStream() {
    assert_eq!(
        ::core::mem::size_of::<SkWStream>(),
        8usize,
        concat!("Size of: ", stringify!(SkWStream))
    );
    assert_eq!(
        ::core::mem::align_of::<SkWStream>(),
        8usize,
        concat!("Alignment of ", stringify!(SkWStream))
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN9SkWStream14writeDecAsTextEi"]
    pub fn SkWStream_writeDecAsText(this: *mut SkWStream, arg1: i32) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN9SkWStream17writeBigDecAsTextExi"]
    pub fn SkWStream_writeBigDecAsText(
        this: *mut SkWStream,
        arg1: i64,
        minDigits: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN9SkWStream14writeHexAsTextEji"]
    pub fn SkWStream_writeHexAsText(
        this: *mut SkWStream,
        arg1: u32,
        minDigits: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN9SkWStream17writeScalarAsTextEf"]
    pub fn SkWStream_writeScalarAsText(this: *mut SkWStream, arg1: SkScalar) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN9SkWStream11writeScalarEf"]
    pub fn SkWStream_writeScalar(this: *mut SkWStream, arg1: SkScalar) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN9SkWStream15writePackedUIntEm"]
    pub fn SkWStream_writePackedUInt(this: *mut SkWStream, arg1: usize) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN9SkWStream11writeStreamEP8SkStreamm"]
    pub fn SkWStream_writeStream(this: *mut SkWStream, input: *mut SkStream, length: usize)
        -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN9SkWStream16SizeOfPackedUIntEm"]
    pub fn SkWStream_SizeOfPackedUInt(value: usize) -> ::std::os::raw::c_int;
}
impl SkWStream {
    #[inline]
    pub unsafe fn writeDecAsText(&mut self, arg1: i32) -> bool {
        SkWStream_writeDecAsText(self, arg1)
    }
    #[inline]
    pub unsafe fn writeBigDecAsText(
        &mut self,
        arg1: i64,
        minDigits: ::std::os::raw::c_int,
    ) -> bool {
        SkWStream_writeBigDecAsText(self, arg1, minDigits)
    }
    #[inline]
    pub unsafe fn writeHexAsText(&mut self, arg1: u32, minDigits: ::std::os::raw::c_int) -> bool {
        SkWStream_writeHexAsText(self, arg1, minDigits)
    }
    #[inline]
    pub unsafe fn writeScalarAsText(&mut self, arg1: SkScalar) -> bool {
        SkWStream_writeScalarAsText(self, arg1)
    }
    #[inline]
    pub unsafe fn writeScalar(&mut self, arg1: SkScalar) -> bool {
        SkWStream_writeScalar(self, arg1)
    }
    #[inline]
    pub unsafe fn writePackedUInt(&mut self, arg1: usize) -> bool {
        SkWStream_writePackedUInt(self, arg1)
    }
    #[inline]
    pub unsafe fn writeStream(&mut self, input: *mut SkStream, length: usize) -> bool {
        SkWStream_writeStream(self, input, length)
    }
    #[inline]
    pub unsafe fn SizeOfPackedUInt(value: usize) -> ::std::os::raw::c_int {
        SkWStream_SizeOfPackedUInt(value)
    }
}
extern "C" {
    #[link_name = "\u{1}__ZN9SkWStreamD1Ev"]
    pub fn SkWStream_SkWStream_destructor(this: *mut SkWStream);
}
extern "C" {
    #[link_name = "\u{1}__ZN9SkWStream5flushEv"]
    pub fn SkWStream_flush(this: *mut ::core::ffi::c_void);
}
#[repr(C)]
#[derive(Debug)]
pub struct SkMemoryStream {
    pub _base: SkStreamMemory,
    pub fData: sk_sp<SkData>,
    pub fOffset: usize,
}
pub type SkMemoryStream_INHERITED = SkStreamMemory;
#[test]
fn bindgen_test_layout_SkMemoryStream() {
    assert_eq!(
        ::core::mem::size_of::<SkMemoryStream>(),
        24usize,
        concat!("Size of: ", stringify!(SkMemoryStream))
    );
    assert_eq!(
        ::core::mem::align_of::<SkMemoryStream>(),
        8usize,
        concat!("Alignment of ", stringify!(SkMemoryStream))
    );
    fn test_field_fData() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkMemoryStream>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fData) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(SkMemoryStream),
                "::",
                stringify!(fData)
            )
        );
    }
    test_field_fData();
    fn test_field_fOffset() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkMemoryStream>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fOffset) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(SkMemoryStream),
                "::",
                stringify!(fOffset)
            )
        );
    }
    test_field_fOffset();
}
extern "C" {
    #[link_name = "\u{1}__ZN14SkMemoryStream8MakeCopyEPKvm"]
    pub fn SkMemoryStream_MakeCopy(data: *const ::core::ffi::c_void, length: usize) -> u64;
}
extern "C" {
    #[link_name = "\u{1}__ZN14SkMemoryStream10MakeDirectEPKvm"]
    pub fn SkMemoryStream_MakeDirect(data: *const ::core::ffi::c_void, length: usize) -> u64;
}
extern "C" {
    #[link_name = "\u{1}__ZN14SkMemoryStream4MakeE5sk_spI6SkDataE"]
    pub fn SkMemoryStream_Make(data: sk_sp<SkData>) -> u64;
}
extern "C" {
    #[link_name = "\u{1}__ZN14SkMemoryStream14setMemoryOwnedEPKvm"]
    pub fn SkMemoryStream_setMemoryOwned(
        this: *mut SkMemoryStream,
        data: *const ::core::ffi::c_void,
        length: usize,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN14SkMemoryStream7setDataE5sk_spI6SkDataE"]
    pub fn SkMemoryStream_setData(this: *mut SkMemoryStream, data: sk_sp<SkData>);
}
extern "C" {
    #[link_name = "\u{1}__ZN14SkMemoryStream12skipToAlign4Ev"]
    pub fn SkMemoryStream_skipToAlign4(this: *mut SkMemoryStream);
}
extern "C" {
    #[link_name = "\u{1}__ZN14SkMemoryStream8getAtPosEv"]
    pub fn SkMemoryStream_getAtPos(this: *mut SkMemoryStream) -> *const ::core::ffi::c_void;
}
extern "C" {
    #[link_name = "\u{1}__ZN14SkMemoryStreamC1Ev"]
    pub fn SkMemoryStream_SkMemoryStream(this: *mut SkMemoryStream);
}
extern "C" {
    #[link_name = "\u{1}__ZN14SkMemoryStreamC1Em"]
    pub fn SkMemoryStream_SkMemoryStream1(this: *mut SkMemoryStream, length: usize);
}
extern "C" {
    #[link_name = "\u{1}__ZN14SkMemoryStreamC1EPKvmb"]
    pub fn SkMemoryStream_SkMemoryStream2(
        this: *mut SkMemoryStream,
        data: *const ::core::ffi::c_void,
        length: usize,
        copyData: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN14SkMemoryStreamC1E5sk_spI6SkDataE"]
    pub fn SkMemoryStream_SkMemoryStream3(this: *mut SkMemoryStream, data: sk_sp<SkData>);
}
impl SkMemoryStream {
    #[inline]
    pub unsafe fn MakeCopy(data: *const ::core::ffi::c_void, length: usize) -> u64 {
        SkMemoryStream_MakeCopy(data, length)
    }
    #[inline]
    pub unsafe fn MakeDirect(data: *const ::core::ffi::c_void, length: usize) -> u64 {
        SkMemoryStream_MakeDirect(data, length)
    }
    #[inline]
    pub unsafe fn Make(data: sk_sp<SkData>) -> u64 {
        SkMemoryStream_Make(data)
    }
    #[inline]
    pub unsafe fn setMemoryOwned(&mut self, data: *const ::core::ffi::c_void, length: usize) {
        SkMemoryStream_setMemoryOwned(self, data, length)
    }
    #[inline]
    pub unsafe fn setData(&mut self, data: sk_sp<SkData>) {
        SkMemoryStream_setData(self, data)
    }
    #[inline]
    pub unsafe fn skipToAlign4(&mut self) {
        SkMemoryStream_skipToAlign4(self)
    }
    #[inline]
    pub unsafe fn getAtPos(&mut self) -> *const ::core::ffi::c_void {
        SkMemoryStream_getAtPos(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkMemoryStream_SkMemoryStream(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(length: usize) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkMemoryStream_SkMemoryStream1(__bindgen_tmp.as_mut_ptr(), length);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(data: *const ::core::ffi::c_void, length: usize, copyData: bool) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkMemoryStream_SkMemoryStream2(__bindgen_tmp.as_mut_ptr(), data, length, copyData);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new3(data: sk_sp<SkData>) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkMemoryStream_SkMemoryStream3(__bindgen_tmp.as_mut_ptr(), data);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}__ZN14SkMemoryStream9setMemoryEPKvmb"]
    pub fn SkMemoryStream_setMemory(
        this: *mut ::core::ffi::c_void,
        data: *const ::core::ffi::c_void,
        length: usize,
        copyData: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN14SkMemoryStream4readEPvm"]
    pub fn SkMemoryStream_read(
        this: *mut ::core::ffi::c_void,
        buffer: *mut ::core::ffi::c_void,
        size: usize,
    ) -> usize;
}
extern "C" {
    #[link_name = "\u{1}__ZNK14SkMemoryStream7isAtEndEv"]
    pub fn SkMemoryStream_isAtEnd(this: *mut ::core::ffi::c_void) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK14SkMemoryStream4peekEPvm"]
    pub fn SkMemoryStream_peek(
        this: *mut ::core::ffi::c_void,
        buffer: *mut ::core::ffi::c_void,
        size: usize,
    ) -> usize;
}
extern "C" {
    #[link_name = "\u{1}__ZN14SkMemoryStream6rewindEv"]
    pub fn SkMemoryStream_rewind(this: *mut ::core::ffi::c_void) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK14SkMemoryStream11getPositionEv"]
    pub fn SkMemoryStream_getPosition(this: *mut ::core::ffi::c_void) -> usize;
}
extern "C" {
    #[link_name = "\u{1}__ZN14SkMemoryStream4seekEm"]
    pub fn SkMemoryStream_seek(this: *mut ::core::ffi::c_void, position: usize) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN14SkMemoryStream4moveEl"]
    pub fn SkMemoryStream_move(
        this: *mut ::core::ffi::c_void,
        offset: ::std::os::raw::c_long,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK14SkMemoryStream9getLengthEv"]
    pub fn SkMemoryStream_getLength(this: *mut ::core::ffi::c_void) -> usize;
}
extern "C" {
    #[link_name = "\u{1}__ZN14SkMemoryStream13getMemoryBaseEv"]
    pub fn SkMemoryStream_getMemoryBase(
        this: *mut ::core::ffi::c_void,
    ) -> *const ::core::ffi::c_void;
}
#[repr(C)]
#[derive(Debug)]
pub struct SkDynamicMemoryWStream {
    pub _base: SkWStream,
    pub fHead: *mut SkDynamicMemoryWStream_Block,
    pub fTail: *mut SkDynamicMemoryWStream_Block,
    pub fBytesWrittenBeforeTail: usize,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkDynamicMemoryWStream_Block {
    _unused: [u8; 0],
}
pub type SkDynamicMemoryWStream_INHERITED = SkWStream;
#[test]
fn bindgen_test_layout_SkDynamicMemoryWStream() {
    assert_eq!(
        ::core::mem::size_of::<SkDynamicMemoryWStream>(),
        32usize,
        concat!("Size of: ", stringify!(SkDynamicMemoryWStream))
    );
    assert_eq!(
        ::core::mem::align_of::<SkDynamicMemoryWStream>(),
        8usize,
        concat!("Alignment of ", stringify!(SkDynamicMemoryWStream))
    );
    fn test_field_fHead() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkDynamicMemoryWStream>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fHead) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(SkDynamicMemoryWStream),
                "::",
                stringify!(fHead)
            )
        );
    }
    test_field_fHead();
    fn test_field_fTail() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkDynamicMemoryWStream>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fTail) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(SkDynamicMemoryWStream),
                "::",
                stringify!(fTail)
            )
        );
    }
    test_field_fTail();
    fn test_field_fBytesWrittenBeforeTail() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkDynamicMemoryWStream>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fBytesWrittenBeforeTail) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(SkDynamicMemoryWStream),
                "::",
                stringify!(fBytesWrittenBeforeTail)
            )
        );
    }
    test_field_fBytesWrittenBeforeTail();
}
extern "C" {
    #[link_name = "\u{1}__ZN22SkDynamicMemoryWStream4readEPvmm"]
    pub fn SkDynamicMemoryWStream_read(
        this: *mut SkDynamicMemoryWStream,
        buffer: *mut ::core::ffi::c_void,
        offset: usize,
        size: usize,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK22SkDynamicMemoryWStream6copyToEPv"]
    pub fn SkDynamicMemoryWStream_copyTo(
        this: *const SkDynamicMemoryWStream,
        dst: *mut ::core::ffi::c_void,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNK22SkDynamicMemoryWStream13writeToStreamEP9SkWStream"]
    pub fn SkDynamicMemoryWStream_writeToStream(
        this: *const SkDynamicMemoryWStream,
        dst: *mut SkWStream,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN22SkDynamicMemoryWStream14copyToAndResetEPv"]
    pub fn SkDynamicMemoryWStream_copyToAndReset(
        this: *mut SkDynamicMemoryWStream,
        dst: *mut ::core::ffi::c_void,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN22SkDynamicMemoryWStream15writeToAndResetEP9SkWStream"]
    pub fn SkDynamicMemoryWStream_writeToAndReset(
        this: *mut SkDynamicMemoryWStream,
        dst: *mut SkWStream,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN22SkDynamicMemoryWStream15writeToAndResetEPS_"]
    pub fn SkDynamicMemoryWStream_writeToAndReset1(
        this: *mut SkDynamicMemoryWStream,
        dst: *mut SkDynamicMemoryWStream,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN22SkDynamicMemoryWStream17prependToAndResetEPS_"]
    pub fn SkDynamicMemoryWStream_prependToAndReset(
        this: *mut SkDynamicMemoryWStream,
        dst: *mut SkDynamicMemoryWStream,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN22SkDynamicMemoryWStream12detachAsDataEv"]
    pub fn SkDynamicMemoryWStream_detachAsData(this: *mut SkDynamicMemoryWStream) -> sk_sp<SkData>;
}
extern "C" {
    #[link_name = "\u{1}__ZN22SkDynamicMemoryWStream14detachAsStreamEv"]
    pub fn SkDynamicMemoryWStream_detachAsStream(this: *mut SkDynamicMemoryWStream) -> u64;
}
extern "C" {
    #[link_name = "\u{1}__ZN22SkDynamicMemoryWStream5resetEv"]
    pub fn SkDynamicMemoryWStream_reset(this: *mut SkDynamicMemoryWStream);
}
extern "C" {
    #[link_name = "\u{1}__ZN22SkDynamicMemoryWStream11padToAlign4Ev"]
    pub fn SkDynamicMemoryWStream_padToAlign4(this: *mut SkDynamicMemoryWStream);
}
extern "C" {
    #[link_name = "\u{1}__ZN22SkDynamicMemoryWStreamC1EOS_"]
    pub fn SkDynamicMemoryWStream_SkDynamicMemoryWStream(
        this: *mut SkDynamicMemoryWStream,
        arg1: *mut SkDynamicMemoryWStream,
    );
}
impl SkDynamicMemoryWStream {
    #[inline]
    pub unsafe fn read(
        &mut self,
        buffer: *mut ::core::ffi::c_void,
        offset: usize,
        size: usize,
    ) -> bool {
        SkDynamicMemoryWStream_read(self, buffer, offset, size)
    }
    #[inline]
    pub unsafe fn copyTo(&self, dst: *mut ::core::ffi::c_void) {
        SkDynamicMemoryWStream_copyTo(self, dst)
    }
    #[inline]
    pub unsafe fn writeToStream(&self, dst: *mut SkWStream) -> bool {
        SkDynamicMemoryWStream_writeToStream(self, dst)
    }
    #[inline]
    pub unsafe fn copyToAndReset(&mut self, dst: *mut ::core::ffi::c_void) {
        SkDynamicMemoryWStream_copyToAndReset(self, dst)
    }
    #[inline]
    pub unsafe fn writeToAndReset(&mut self, dst: *mut SkWStream) -> bool {
        SkDynamicMemoryWStream_writeToAndReset(self, dst)
    }
    #[inline]
    pub unsafe fn writeToAndReset1(&mut self, dst: *mut SkDynamicMemoryWStream) -> bool {
        SkDynamicMemoryWStream_writeToAndReset1(self, dst)
    }
    #[inline]
    pub unsafe fn prependToAndReset(&mut self, dst: *mut SkDynamicMemoryWStream) {
        SkDynamicMemoryWStream_prependToAndReset(self, dst)
    }
    #[inline]
    pub unsafe fn detachAsData(&mut self) -> sk_sp<SkData> {
        SkDynamicMemoryWStream_detachAsData(self)
    }
    #[inline]
    pub unsafe fn detachAsStream(&mut self) -> u64 {
        SkDynamicMemoryWStream_detachAsStream(self)
    }
    #[inline]
    pub unsafe fn reset(&mut self) {
        SkDynamicMemoryWStream_reset(self)
    }
    #[inline]
    pub unsafe fn padToAlign4(&mut self) {
        SkDynamicMemoryWStream_padToAlign4(self)
    }
    #[inline]
    pub unsafe fn new(arg1: *mut SkDynamicMemoryWStream) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkDynamicMemoryWStream_SkDynamicMemoryWStream(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}__ZN22SkDynamicMemoryWStreamD1Ev"]
    pub fn SkDynamicMemoryWStream_SkDynamicMemoryWStream_destructor(
        this: *mut SkDynamicMemoryWStream,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN22SkDynamicMemoryWStream5writeEPKvm"]
    pub fn SkDynamicMemoryWStream_write(
        this: *mut ::core::ffi::c_void,
        buffer: *const ::core::ffi::c_void,
        size: usize,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK22SkDynamicMemoryWStream12bytesWrittenEv"]
    pub fn SkDynamicMemoryWStream_bytesWritten(this: *mut ::core::ffi::c_void) -> usize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkStrokeRec {
    pub fResScale: SkScalar,
    pub fWidth: SkScalar,
    pub fMiterLimit: SkScalar,
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkStrokeRec_InitStyle {
    Hairline = 0,
    Fill = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkStrokeRec_Style {
    Hairline = 0,
    Fill = 1,
    Stroke = 2,
    StrokeAndFill = 3,
}
pub const SkStrokeRec_kStyleCount: ::std::os::raw::c_int = 4;
#[test]
fn bindgen_test_layout_SkStrokeRec() {
    assert_eq!(
        ::core::mem::size_of::<SkStrokeRec>(),
        16usize,
        concat!("Size of: ", stringify!(SkStrokeRec))
    );
    assert_eq!(
        ::core::mem::align_of::<SkStrokeRec>(),
        4usize,
        concat!("Alignment of ", stringify!(SkStrokeRec))
    );
    fn test_field_fResScale() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkStrokeRec>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fResScale) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SkStrokeRec),
                "::",
                stringify!(fResScale)
            )
        );
    }
    test_field_fResScale();
    fn test_field_fWidth() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkStrokeRec>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fWidth) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(SkStrokeRec),
                "::",
                stringify!(fWidth)
            )
        );
    }
    test_field_fWidth();
    fn test_field_fMiterLimit() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkStrokeRec>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fMiterLimit) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(SkStrokeRec),
                "::",
                stringify!(fMiterLimit)
            )
        );
    }
    test_field_fMiterLimit();
}
extern "C" {
    #[link_name = "\u{1}__ZNK11SkStrokeRec8getStyleEv"]
    pub fn SkStrokeRec_getStyle(this: *const SkStrokeRec) -> SkStrokeRec_Style;
}
extern "C" {
    #[link_name = "\u{1}__ZN11SkStrokeRec12setFillStyleEv"]
    pub fn SkStrokeRec_setFillStyle(this: *mut SkStrokeRec);
}
extern "C" {
    #[link_name = "\u{1}__ZN11SkStrokeRec16setHairlineStyleEv"]
    pub fn SkStrokeRec_setHairlineStyle(this: *mut SkStrokeRec);
}
extern "C" {
    #[link_name = "\u{1}__ZN11SkStrokeRec14setStrokeStyleEfb"]
    pub fn SkStrokeRec_setStrokeStyle(this: *mut SkStrokeRec, width: SkScalar, strokeAndFill: bool);
}
extern "C" {
    #[link_name = "\u{1}__ZNK11SkStrokeRec11applyToPathEP6SkPathRKS0_"]
    pub fn SkStrokeRec_applyToPath(
        this: *const SkStrokeRec,
        dst: *mut SkPath,
        src: *const SkPath,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK11SkStrokeRec12applyToPaintEP7SkPaint"]
    pub fn SkStrokeRec_applyToPaint(this: *const SkStrokeRec, paint: *mut SkPaint);
}
extern "C" {
    #[link_name = "\u{1}__ZNK11SkStrokeRec18getInflationRadiusEv"]
    pub fn SkStrokeRec_getInflationRadius(this: *const SkStrokeRec) -> SkScalar;
}
extern "C" {
    #[link_name = "\u{1}__ZN11SkStrokeRec18GetInflationRadiusERK7SkPaintNS0_5StyleE"]
    pub fn SkStrokeRec_GetInflationRadius(arg1: *const SkPaint, arg2: SkPaint_Style) -> SkScalar;
}
extern "C" {
    #[link_name = "\u{1}__ZN11SkStrokeRec18GetInflationRadiusEN7SkPaint4JoinEfNS0_3CapEf"]
    pub fn SkStrokeRec_GetInflationRadius1(
        arg1: SkPaint_Join,
        miterLimit: SkScalar,
        arg2: SkPaint_Cap,
        strokeWidth: SkScalar,
    ) -> SkScalar;
}
extern "C" {
    #[link_name = "\u{1}__ZN11SkStrokeRecC1ENS_9InitStyleE"]
    pub fn SkStrokeRec_SkStrokeRec(this: *mut SkStrokeRec, style: SkStrokeRec_InitStyle);
}
extern "C" {
    #[link_name = "\u{1}__ZN11SkStrokeRecC1ERK7SkPaintNS0_5StyleEf"]
    pub fn SkStrokeRec_SkStrokeRec1(
        this: *mut SkStrokeRec,
        arg1: *const SkPaint,
        arg2: SkPaint_Style,
        resScale: SkScalar,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN11SkStrokeRecC1ERK7SkPaintf"]
    pub fn SkStrokeRec_SkStrokeRec2(
        this: *mut SkStrokeRec,
        arg1: *const SkPaint,
        resScale: SkScalar,
    );
}
impl SkStrokeRec {
    #[inline]
    pub fn fCap(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_fCap(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn fJoin(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 15u8) as u32) }
    }
    #[inline]
    pub fn set_fJoin(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub fn fStrokeAndFill(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fStrokeAndFill(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        fCap: u32,
        fJoin: u32,
        fStrokeAndFill: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let fCap: u32 = unsafe { ::core::mem::transmute(fCap) };
            fCap as u64
        });
        __bindgen_bitfield_unit.set(16usize, 15u8, {
            let fJoin: u32 = unsafe { ::core::mem::transmute(fJoin) };
            fJoin as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let fStrokeAndFill: u32 = unsafe { ::core::mem::transmute(fStrokeAndFill) };
            fStrokeAndFill as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub unsafe fn getStyle(&self) -> SkStrokeRec_Style {
        SkStrokeRec_getStyle(self)
    }
    #[inline]
    pub unsafe fn setFillStyle(&mut self) {
        SkStrokeRec_setFillStyle(self)
    }
    #[inline]
    pub unsafe fn setHairlineStyle(&mut self) {
        SkStrokeRec_setHairlineStyle(self)
    }
    #[inline]
    pub unsafe fn setStrokeStyle(&mut self, width: SkScalar, strokeAndFill: bool) {
        SkStrokeRec_setStrokeStyle(self, width, strokeAndFill)
    }
    #[inline]
    pub unsafe fn applyToPath(&self, dst: *mut SkPath, src: *const SkPath) -> bool {
        SkStrokeRec_applyToPath(self, dst, src)
    }
    #[inline]
    pub unsafe fn applyToPaint(&self, paint: *mut SkPaint) {
        SkStrokeRec_applyToPaint(self, paint)
    }
    #[inline]
    pub unsafe fn getInflationRadius(&self) -> SkScalar {
        SkStrokeRec_getInflationRadius(self)
    }
    #[inline]
    pub unsafe fn GetInflationRadius(arg1: *const SkPaint, arg2: SkPaint_Style) -> SkScalar {
        SkStrokeRec_GetInflationRadius(arg1, arg2)
    }
    #[inline]
    pub unsafe fn GetInflationRadius1(
        arg1: SkPaint_Join,
        miterLimit: SkScalar,
        arg2: SkPaint_Cap,
        strokeWidth: SkScalar,
    ) -> SkScalar {
        SkStrokeRec_GetInflationRadius1(arg1, miterLimit, arg2, strokeWidth)
    }
    #[inline]
    pub unsafe fn new(style: SkStrokeRec_InitStyle) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkStrokeRec_SkStrokeRec(__bindgen_tmp.as_mut_ptr(), style);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(arg1: *const SkPaint, arg2: SkPaint_Style, resScale: SkScalar) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkStrokeRec_SkStrokeRec1(__bindgen_tmp.as_mut_ptr(), arg1, arg2, resScale);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(arg1: *const SkPaint, resScale: SkScalar) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkStrokeRec_SkStrokeRec2(__bindgen_tmp.as_mut_ptr(), arg1, resScale);
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkCapabilities {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GrBackendSemaphore {
    _unused: [u8; 0],
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum GrSurfaceOrigin {
    __bindgen_cannot_repr_c_on_empty_enum = 0,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct SkSurface {
    pub _bindgen_opaque_blob: [u64; 4usize],
}
pub type SkSurface_ReleaseContext = *mut ::core::ffi::c_void;
pub type SkSurface_RenderTargetReleaseProc =
    ::core::option::Option<unsafe extern "C" fn(releaseContext: SkSurface_ReleaseContext)>;
pub type SkSurface_TextureReleaseProc =
    ::core::option::Option<unsafe extern "C" fn(releaseContext: SkSurface_ReleaseContext)>;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkSurface_ContentChangeMode {
    Discard = 0,
    Retain = 1,
}
pub type SkSurface_AsyncReadResult = SkImage_AsyncReadResult;
pub type SkSurface_ReadPixelsContext = *mut ::core::ffi::c_void;
pub type SkSurface_ReadPixelsCallback =
    ::core::option::Option<unsafe extern "C" fn(arg1: SkSurface_ReadPixelsContext, arg2: u8)>;
pub use self::SkImage_RescaleGamma as SkSurface_RescaleGamma;
pub use self::SkImage_RescaleMode as SkSurface_RescaleMode;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkSurface_BackendSurfaceAccess {
    NoAccess = 0,
    Present = 1,
}
pub type SkSurface_INHERITED = SkRefCnt;
#[test]
fn bindgen_test_layout_SkSurface() {
    assert_eq!(
        ::core::mem::size_of::<SkSurface>(),
        32usize,
        concat!("Size of: ", stringify!(SkSurface))
    );
    assert_eq!(
        ::core::mem::align_of::<SkSurface>(),
        8usize,
        concat!("Alignment of ", stringify!(SkSurface))
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN9SkSurface16MakeRasterDirectERK11SkImageInfoPvmPK14SkSurfaceProps"]
    pub fn SkSurface_MakeRasterDirect(
        imageInfo: *const SkImageInfo,
        pixels: *mut ::core::ffi::c_void,
        rowBytes: usize,
        surfaceProps: *const SkSurfaceProps,
    ) -> sk_sp<SkSurface>;
}
extern "C" {
    #[link_name = "\u{1}__ZN9SkSurface27MakeRasterDirectReleaseProcERK11SkImageInfoPvmPFvS3_S3_ES3_PK14SkSurfaceProps"]
    pub fn SkSurface_MakeRasterDirectReleaseProc(
        imageInfo: *const SkImageInfo,
        pixels: *mut ::core::ffi::c_void,
        rowBytes: usize,
        releaseProc: ::core::option::Option<
            unsafe extern "C" fn(
                pixels: *mut ::core::ffi::c_void,
                context: *mut ::core::ffi::c_void,
            ),
        >,
        context: *mut ::core::ffi::c_void,
        surfaceProps: *const SkSurfaceProps,
    ) -> sk_sp<SkSurface>;
}
extern "C" {
    #[link_name = "\u{1}__ZN9SkSurface10MakeRasterERK11SkImageInfomPK14SkSurfaceProps"]
    pub fn SkSurface_MakeRaster(
        imageInfo: *const SkImageInfo,
        rowBytes: usize,
        surfaceProps: *const SkSurfaceProps,
    ) -> sk_sp<SkSurface>;
}
extern "C" {
    #[link_name = "\u{1}__ZN9SkSurface19MakeRasterN32PremulEiiPK14SkSurfaceProps"]
    pub fn SkSurface_MakeRasterN32Premul(
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        surfaceProps: *const SkSurfaceProps,
    ) -> sk_sp<SkSurface>;
}
extern "C" {
    #[link_name = "\u{1}__ZN9SkSurface16MakeRenderTargetEP18GrRecordingContext10SkBudgetedRK11SkImageInfoi15GrSurfaceOriginPK14SkSurfacePropsb"]
    pub fn SkSurface_MakeRenderTarget(
        context: *mut GrRecordingContext,
        budgeted: SkBudgeted,
        imageInfo: *const SkImageInfo,
        sampleCount: ::std::os::raw::c_int,
        surfaceOrigin: GrSurfaceOrigin,
        surfaceProps: *const SkSurfaceProps,
        shouldCreateWithMips: bool,
    ) -> sk_sp<SkSurface>;
}
extern "C" {
    #[link_name = "\u{1}__ZNK9SkSurface12isCompatibleERK25SkSurfaceCharacterization"]
    pub fn SkSurface_isCompatible(
        this: *const SkSurface,
        characterization: *const SkSurfaceCharacterization,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN9SkSurface8MakeNullEii"]
    pub fn SkSurface_MakeNull(
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
    ) -> sk_sp<SkSurface>;
}
extern "C" {
    #[link_name = "\u{1}__ZN9SkSurface9imageInfoEv"]
    pub fn SkSurface_imageInfo(this: *mut SkSurface) -> SkImageInfo;
}
extern "C" {
    #[link_name = "\u{1}__ZN9SkSurface12generationIDEv"]
    pub fn SkSurface_generationID(this: *mut SkSurface) -> u32;
}
extern "C" {
    #[link_name = "\u{1}__ZN9SkSurface23notifyContentWillChangeENS_17ContentChangeModeE"]
    pub fn SkSurface_notifyContentWillChange(
        this: *mut SkSurface,
        mode: SkSurface_ContentChangeMode,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN9SkSurface16recordingContextEv"]
    pub fn SkSurface_recordingContext(this: *mut SkSurface) -> *mut GrRecordingContext;
}
extern "C" {
    #[link_name = "\u{1}__ZN9SkSurface8recorderEv"]
    pub fn SkSurface_recorder(this: *mut SkSurface) -> *mut skgpu_graphite_Recorder;
}
extern "C" {
    #[link_name = "\u{1}__ZN9SkSurface9getCanvasEv"]
    pub fn SkSurface_getCanvas(this: *mut SkSurface) -> *mut SkCanvas;
}
extern "C" {
    #[link_name = "\u{1}__ZN9SkSurface12capabilitiesEv"]
    pub fn SkSurface_capabilities(this: *mut SkSurface) -> sk_sp<SkCapabilities>;
}
extern "C" {
    #[link_name = "\u{1}__ZN9SkSurface11makeSurfaceERK11SkImageInfo"]
    pub fn SkSurface_makeSurface(
        this: *mut SkSurface,
        imageInfo: *const SkImageInfo,
    ) -> sk_sp<SkSurface>;
}
extern "C" {
    #[link_name = "\u{1}__ZN9SkSurface11makeSurfaceEii"]
    pub fn SkSurface_makeSurface1(
        this: *mut SkSurface,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
    ) -> sk_sp<SkSurface>;
}
extern "C" {
    #[link_name = "\u{1}__ZN9SkSurface17makeImageSnapshotEv"]
    pub fn SkSurface_makeImageSnapshot(this: *mut SkSurface) -> sk_sp<SkImage>;
}
extern "C" {
    #[link_name = "\u{1}__ZN9SkSurface17makeImageSnapshotERK7SkIRect"]
    pub fn SkSurface_makeImageSnapshot1(
        this: *mut SkSurface,
        bounds: *const SkIRect,
    ) -> sk_sp<SkImage>;
}
extern "C" {
    #[link_name = "\u{1}__ZN9SkSurface4drawEP8SkCanvasffRK17SkSamplingOptionsPK7SkPaint"]
    pub fn SkSurface_draw(
        this: *mut SkSurface,
        canvas: *mut SkCanvas,
        x: SkScalar,
        y: SkScalar,
        sampling: *const SkSamplingOptions,
        paint: *const SkPaint,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN9SkSurface10peekPixelsEP8SkPixmap"]
    pub fn SkSurface_peekPixels(this: *mut SkSurface, pixmap: *mut SkPixmap) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN9SkSurface10readPixelsERK8SkPixmapii"]
    pub fn SkSurface_readPixels(
        this: *mut SkSurface,
        dst: *const SkPixmap,
        srcX: ::std::os::raw::c_int,
        srcY: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN9SkSurface10readPixelsERK11SkImageInfoPvmii"]
    pub fn SkSurface_readPixels1(
        this: *mut SkSurface,
        dstInfo: *const SkImageInfo,
        dstPixels: *mut ::core::ffi::c_void,
        dstRowBytes: usize,
        srcX: ::std::os::raw::c_int,
        srcY: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN9SkSurface10readPixelsERK8SkBitmapii"]
    pub fn SkSurface_readPixels2(
        this: *mut SkSurface,
        dst: *const SkBitmap,
        srcX: ::std::os::raw::c_int,
        srcY: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN9SkSurface25asyncRescaleAndReadPixelsERK11SkImageInfoRK7SkIRectN7SkImage12RescaleGammaENS6_11RescaleModeEPFvPvNSt3__110unique_ptrIKNS6_15AsyncReadResultENSA_14default_deleteISD_EEEEES9_"]
    pub fn SkSurface_asyncRescaleAndReadPixels(
        this: *mut SkSurface,
        info: *const SkImageInfo,
        srcRect: *const SkIRect,
        rescaleGamma: SkSurface_RescaleGamma,
        rescaleMode: SkSurface_RescaleMode,
        callback: SkSurface_ReadPixelsCallback,
        context: SkSurface_ReadPixelsContext,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN9SkSurface31asyncRescaleAndReadPixelsYUV420E15SkYUVColorSpace5sk_spI12SkColorSpaceERK7SkIRectRK7SkISizeN7SkImage12RescaleGammaENSA_11RescaleModeEPFvPvNSt3__110unique_ptrIKNSA_15AsyncReadResultENSE_14default_deleteISH_EEEEESD_"]
    pub fn SkSurface_asyncRescaleAndReadPixelsYUV420(
        this: *mut SkSurface,
        yuvColorSpace: SkYUVColorSpace,
        dstColorSpace: sk_sp<SkColorSpace>,
        srcRect: *const SkIRect,
        dstSize: *const SkISize,
        rescaleGamma: SkSurface_RescaleGamma,
        rescaleMode: SkSurface_RescaleMode,
        callback: SkSurface_ReadPixelsCallback,
        context: SkSurface_ReadPixelsContext,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN9SkSurface11writePixelsERK8SkPixmapii"]
    pub fn SkSurface_writePixels(
        this: *mut SkSurface,
        src: *const SkPixmap,
        dstX: ::std::os::raw::c_int,
        dstY: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN9SkSurface11writePixelsERK8SkBitmapii"]
    pub fn SkSurface_writePixels1(
        this: *mut SkSurface,
        src: *const SkBitmap,
        dstX: ::std::os::raw::c_int,
        dstY: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN9SkSurface14flushAndSubmitEb"]
    pub fn SkSurface_flushAndSubmit(this: *mut SkSurface, syncCpu: bool);
}
extern "C" {
    #[link_name = "\u{1}__ZN9SkSurface5flushEv"]
    pub fn SkSurface_flush(this: *mut SkSurface);
}
extern "C" {
    #[link_name = "\u{1}__ZN9SkSurface4waitEiPK18GrBackendSemaphoreb"]
    pub fn SkSurface_wait(
        this: *mut SkSurface,
        numSemaphores: ::std::os::raw::c_int,
        waitSemaphores: *const GrBackendSemaphore,
        deleteSemaphoresAfterWait: bool,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK9SkSurface12characterizeEP25SkSurfaceCharacterization"]
    pub fn SkSurface_characterize(
        this: *const SkSurface,
        characterization: *mut SkSurfaceCharacterization,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN9SkSurface4drawE5sk_spIK21SkDeferredDisplayListEii"]
    pub fn SkSurface_draw1(
        this: *mut SkSurface,
        deferredDisplayList: sk_sp<SkDeferredDisplayList>,
        xOffset: ::std::os::raw::c_int,
        yOffset: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN9SkSurfaceC1EiiPK14SkSurfaceProps"]
    pub fn SkSurface_SkSurface(
        this: *mut SkSurface,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        surfaceProps: *const SkSurfaceProps,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN9SkSurfaceC1ERK11SkImageInfoPK14SkSurfaceProps"]
    pub fn SkSurface_SkSurface1(
        this: *mut SkSurface,
        imageInfo: *const SkImageInfo,
        surfaceProps: *const SkSurfaceProps,
    );
}
impl SkSurface {
    #[inline]
    pub unsafe fn MakeRasterDirect(
        imageInfo: *const SkImageInfo,
        pixels: *mut ::core::ffi::c_void,
        rowBytes: usize,
        surfaceProps: *const SkSurfaceProps,
    ) -> sk_sp<SkSurface> {
        SkSurface_MakeRasterDirect(imageInfo, pixels, rowBytes, surfaceProps)
    }
    #[inline]
    pub unsafe fn MakeRasterDirectReleaseProc(
        imageInfo: *const SkImageInfo,
        pixels: *mut ::core::ffi::c_void,
        rowBytes: usize,
        releaseProc: ::core::option::Option<
            unsafe extern "C" fn(
                pixels: *mut ::core::ffi::c_void,
                context: *mut ::core::ffi::c_void,
            ),
        >,
        context: *mut ::core::ffi::c_void,
        surfaceProps: *const SkSurfaceProps,
    ) -> sk_sp<SkSurface> {
        SkSurface_MakeRasterDirectReleaseProc(
            imageInfo,
            pixels,
            rowBytes,
            releaseProc,
            context,
            surfaceProps,
        )
    }
    #[inline]
    pub unsafe fn MakeRaster(
        imageInfo: *const SkImageInfo,
        rowBytes: usize,
        surfaceProps: *const SkSurfaceProps,
    ) -> sk_sp<SkSurface> {
        SkSurface_MakeRaster(imageInfo, rowBytes, surfaceProps)
    }
    #[inline]
    pub unsafe fn MakeRasterN32Premul(
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        surfaceProps: *const SkSurfaceProps,
    ) -> sk_sp<SkSurface> {
        SkSurface_MakeRasterN32Premul(width, height, surfaceProps)
    }
    #[inline]
    pub unsafe fn MakeRenderTarget(
        context: *mut GrRecordingContext,
        budgeted: SkBudgeted,
        imageInfo: *const SkImageInfo,
        sampleCount: ::std::os::raw::c_int,
        surfaceOrigin: GrSurfaceOrigin,
        surfaceProps: *const SkSurfaceProps,
        shouldCreateWithMips: bool,
    ) -> sk_sp<SkSurface> {
        SkSurface_MakeRenderTarget(
            context,
            budgeted,
            imageInfo,
            sampleCount,
            surfaceOrigin,
            surfaceProps,
            shouldCreateWithMips,
        )
    }
    #[inline]
    pub unsafe fn isCompatible(&self, characterization: *const SkSurfaceCharacterization) -> bool {
        SkSurface_isCompatible(self, characterization)
    }
    #[inline]
    pub unsafe fn MakeNull(
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
    ) -> sk_sp<SkSurface> {
        SkSurface_MakeNull(width, height)
    }
    #[inline]
    pub unsafe fn imageInfo(&mut self) -> SkImageInfo {
        SkSurface_imageInfo(self)
    }
    #[inline]
    pub unsafe fn generationID(&mut self) -> u32 {
        SkSurface_generationID(self)
    }
    #[inline]
    pub unsafe fn notifyContentWillChange(&mut self, mode: SkSurface_ContentChangeMode) {
        SkSurface_notifyContentWillChange(self, mode)
    }
    #[inline]
    pub unsafe fn recordingContext(&mut self) -> *mut GrRecordingContext {
        SkSurface_recordingContext(self)
    }
    #[inline]
    pub unsafe fn recorder(&mut self) -> *mut skgpu_graphite_Recorder {
        SkSurface_recorder(self)
    }
    #[inline]
    pub unsafe fn getCanvas(&mut self) -> *mut SkCanvas {
        SkSurface_getCanvas(self)
    }
    #[inline]
    pub unsafe fn capabilities(&mut self) -> sk_sp<SkCapabilities> {
        SkSurface_capabilities(self)
    }
    #[inline]
    pub unsafe fn makeSurface(&mut self, imageInfo: *const SkImageInfo) -> sk_sp<SkSurface> {
        SkSurface_makeSurface(self, imageInfo)
    }
    #[inline]
    pub unsafe fn makeSurface1(
        &mut self,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
    ) -> sk_sp<SkSurface> {
        SkSurface_makeSurface1(self, width, height)
    }
    #[inline]
    pub unsafe fn makeImageSnapshot(&mut self) -> sk_sp<SkImage> {
        SkSurface_makeImageSnapshot(self)
    }
    #[inline]
    pub unsafe fn makeImageSnapshot1(&mut self, bounds: *const SkIRect) -> sk_sp<SkImage> {
        SkSurface_makeImageSnapshot1(self, bounds)
    }
    #[inline]
    pub unsafe fn draw(
        &mut self,
        canvas: *mut SkCanvas,
        x: SkScalar,
        y: SkScalar,
        sampling: *const SkSamplingOptions,
        paint: *const SkPaint,
    ) {
        SkSurface_draw(self, canvas, x, y, sampling, paint)
    }
    #[inline]
    pub unsafe fn peekPixels(&mut self, pixmap: *mut SkPixmap) -> bool {
        SkSurface_peekPixels(self, pixmap)
    }
    #[inline]
    pub unsafe fn readPixels(
        &mut self,
        dst: *const SkPixmap,
        srcX: ::std::os::raw::c_int,
        srcY: ::std::os::raw::c_int,
    ) -> bool {
        SkSurface_readPixels(self, dst, srcX, srcY)
    }
    #[inline]
    pub unsafe fn readPixels1(
        &mut self,
        dstInfo: *const SkImageInfo,
        dstPixels: *mut ::core::ffi::c_void,
        dstRowBytes: usize,
        srcX: ::std::os::raw::c_int,
        srcY: ::std::os::raw::c_int,
    ) -> bool {
        SkSurface_readPixels1(self, dstInfo, dstPixels, dstRowBytes, srcX, srcY)
    }
    #[inline]
    pub unsafe fn readPixels2(
        &mut self,
        dst: *const SkBitmap,
        srcX: ::std::os::raw::c_int,
        srcY: ::std::os::raw::c_int,
    ) -> bool {
        SkSurface_readPixels2(self, dst, srcX, srcY)
    }
    #[inline]
    pub unsafe fn asyncRescaleAndReadPixels(
        &mut self,
        info: *const SkImageInfo,
        srcRect: *const SkIRect,
        rescaleGamma: SkSurface_RescaleGamma,
        rescaleMode: SkSurface_RescaleMode,
        callback: SkSurface_ReadPixelsCallback,
        context: SkSurface_ReadPixelsContext,
    ) {
        SkSurface_asyncRescaleAndReadPixels(
            self,
            info,
            srcRect,
            rescaleGamma,
            rescaleMode,
            callback,
            context,
        )
    }
    #[inline]
    pub unsafe fn asyncRescaleAndReadPixelsYUV420(
        &mut self,
        yuvColorSpace: SkYUVColorSpace,
        dstColorSpace: sk_sp<SkColorSpace>,
        srcRect: *const SkIRect,
        dstSize: *const SkISize,
        rescaleGamma: SkSurface_RescaleGamma,
        rescaleMode: SkSurface_RescaleMode,
        callback: SkSurface_ReadPixelsCallback,
        context: SkSurface_ReadPixelsContext,
    ) {
        SkSurface_asyncRescaleAndReadPixelsYUV420(
            self,
            yuvColorSpace,
            dstColorSpace,
            srcRect,
            dstSize,
            rescaleGamma,
            rescaleMode,
            callback,
            context,
        )
    }
    #[inline]
    pub unsafe fn writePixels(
        &mut self,
        src: *const SkPixmap,
        dstX: ::std::os::raw::c_int,
        dstY: ::std::os::raw::c_int,
    ) {
        SkSurface_writePixels(self, src, dstX, dstY)
    }
    #[inline]
    pub unsafe fn writePixels1(
        &mut self,
        src: *const SkBitmap,
        dstX: ::std::os::raw::c_int,
        dstY: ::std::os::raw::c_int,
    ) {
        SkSurface_writePixels1(self, src, dstX, dstY)
    }
    #[inline]
    pub unsafe fn flushAndSubmit(&mut self, syncCpu: bool) {
        SkSurface_flushAndSubmit(self, syncCpu)
    }
    #[inline]
    pub unsafe fn flush(&mut self) {
        SkSurface_flush(self)
    }
    #[inline]
    pub unsafe fn wait(
        &mut self,
        numSemaphores: ::std::os::raw::c_int,
        waitSemaphores: *const GrBackendSemaphore,
        deleteSemaphoresAfterWait: bool,
    ) -> bool {
        SkSurface_wait(
            self,
            numSemaphores,
            waitSemaphores,
            deleteSemaphoresAfterWait,
        )
    }
    #[inline]
    pub unsafe fn characterize(&self, characterization: *mut SkSurfaceCharacterization) -> bool {
        SkSurface_characterize(self, characterization)
    }
    #[inline]
    pub unsafe fn draw1(
        &mut self,
        deferredDisplayList: sk_sp<SkDeferredDisplayList>,
        xOffset: ::std::os::raw::c_int,
        yOffset: ::std::os::raw::c_int,
    ) -> bool {
        SkSurface_draw1(self, deferredDisplayList, xOffset, yOffset)
    }
    #[inline]
    pub unsafe fn new(
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        surfaceProps: *const SkSurfaceProps,
    ) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkSurface_SkSurface(__bindgen_tmp.as_mut_ptr(), width, height, surfaceProps);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(imageInfo: *const SkImageInfo, surfaceProps: *const SkSurfaceProps) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkSurface_SkSurface1(__bindgen_tmp.as_mut_ptr(), imageInfo, surfaceProps);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}__Z8SkSwapRBPjPKji"]
    pub fn SkSwapRB(dest: *mut u32, src: *const u32, count: ::std::os::raw::c_int);
}
#[repr(C)]
#[derive(Debug)]
pub struct SkTextBlob {
    pub _base: SkNVRefCnt,
    pub fBounds: SkRect,
    pub fUniqueID: u32,
    pub fCacheID: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkTextBlob_RunRecord {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkTextBlob_Iter {
    pub fRunRecord: *const SkTextBlob_RunRecord,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkTextBlob_Iter_Run {
    pub fTypeface: *mut SkTypeface,
    pub fGlyphCount: ::std::os::raw::c_int,
    pub fGlyphIndices: *const u16,
}
#[test]
fn bindgen_test_layout_SkTextBlob_Iter_Run() {
    assert_eq!(
        ::core::mem::size_of::<SkTextBlob_Iter_Run>(),
        24usize,
        concat!("Size of: ", stringify!(SkTextBlob_Iter_Run))
    );
    assert_eq!(
        ::core::mem::align_of::<SkTextBlob_Iter_Run>(),
        8usize,
        concat!("Alignment of ", stringify!(SkTextBlob_Iter_Run))
    );
    fn test_field_fTypeface() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkTextBlob_Iter_Run>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fTypeface) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SkTextBlob_Iter_Run),
                "::",
                stringify!(fTypeface)
            )
        );
    }
    test_field_fTypeface();
    fn test_field_fGlyphCount() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkTextBlob_Iter_Run>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fGlyphCount) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(SkTextBlob_Iter_Run),
                "::",
                stringify!(fGlyphCount)
            )
        );
    }
    test_field_fGlyphCount();
    fn test_field_fGlyphIndices() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkTextBlob_Iter_Run>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fGlyphIndices) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(SkTextBlob_Iter_Run),
                "::",
                stringify!(fGlyphIndices)
            )
        );
    }
    test_field_fGlyphIndices();
}
#[repr(C)]
#[derive(Debug)]
pub struct SkTextBlob_Iter_ExperimentalRun {
    pub font: SkFont,
    pub count: ::std::os::raw::c_int,
    pub glyphs: *const u16,
    pub positions: *const SkPoint,
}
#[test]
fn bindgen_test_layout_SkTextBlob_Iter_ExperimentalRun() {
    assert_eq!(
        ::core::mem::size_of::<SkTextBlob_Iter_ExperimentalRun>(),
        48usize,
        concat!("Size of: ", stringify!(SkTextBlob_Iter_ExperimentalRun))
    );
    assert_eq!(
        ::core::mem::align_of::<SkTextBlob_Iter_ExperimentalRun>(),
        8usize,
        concat!("Alignment of ", stringify!(SkTextBlob_Iter_ExperimentalRun))
    );
    fn test_field_font() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkTextBlob_Iter_ExperimentalRun>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).font) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SkTextBlob_Iter_ExperimentalRun),
                "::",
                stringify!(font)
            )
        );
    }
    test_field_font();
    fn test_field_count() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkTextBlob_Iter_ExperimentalRun>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).count) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(SkTextBlob_Iter_ExperimentalRun),
                "::",
                stringify!(count)
            )
        );
    }
    test_field_count();
    fn test_field_glyphs() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkTextBlob_Iter_ExperimentalRun>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).glyphs) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(SkTextBlob_Iter_ExperimentalRun),
                "::",
                stringify!(glyphs)
            )
        );
    }
    test_field_glyphs();
    fn test_field_positions() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkTextBlob_Iter_ExperimentalRun>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).positions) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(SkTextBlob_Iter_ExperimentalRun),
                "::",
                stringify!(positions)
            )
        );
    }
    test_field_positions();
}
#[test]
fn bindgen_test_layout_SkTextBlob_Iter() {
    assert_eq!(
        ::core::mem::size_of::<SkTextBlob_Iter>(),
        8usize,
        concat!("Size of: ", stringify!(SkTextBlob_Iter))
    );
    assert_eq!(
        ::core::mem::align_of::<SkTextBlob_Iter>(),
        8usize,
        concat!("Alignment of ", stringify!(SkTextBlob_Iter))
    );
    fn test_field_fRunRecord() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkTextBlob_Iter>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fRunRecord) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SkTextBlob_Iter),
                "::",
                stringify!(fRunRecord)
            )
        );
    }
    test_field_fRunRecord();
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkTextBlob4Iter4nextEPNS0_3RunE"]
    pub fn SkTextBlob_Iter_next(this: *mut SkTextBlob_Iter, arg1: *mut SkTextBlob_Iter_Run)
        -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkTextBlob4Iter16experimentalNextEPNS0_15ExperimentalRunE"]
    pub fn SkTextBlob_Iter_experimentalNext(
        this: *mut SkTextBlob_Iter,
        arg1: *mut SkTextBlob_Iter_ExperimentalRun,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkTextBlob4IterC1ERKS_"]
    pub fn SkTextBlob_Iter_Iter(this: *mut SkTextBlob_Iter, arg1: *const SkTextBlob);
}
impl SkTextBlob_Iter {
    #[inline]
    pub unsafe fn next(&mut self, arg1: *mut SkTextBlob_Iter_Run) -> bool {
        SkTextBlob_Iter_next(self, arg1)
    }
    #[inline]
    pub unsafe fn experimentalNext(&mut self, arg1: *mut SkTextBlob_Iter_ExperimentalRun) -> bool {
        SkTextBlob_Iter_experimentalNext(self, arg1)
    }
    #[inline]
    pub unsafe fn new(arg1: *const SkTextBlob) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkTextBlob_Iter_Iter(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
}
#[repr(u8)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkTextBlob_GlyphPositioning {
    __bindgen_cannot_repr_c_on_empty_enum = 0,
}
pub type SkTextBlob_INHERITED = SkRefCnt;
#[test]
fn bindgen_test_layout_SkTextBlob() {
    assert_eq!(
        ::core::mem::size_of::<SkTextBlob>(),
        28usize,
        concat!("Size of: ", stringify!(SkTextBlob))
    );
    assert_eq!(
        ::core::mem::align_of::<SkTextBlob>(),
        4usize,
        concat!("Alignment of ", stringify!(SkTextBlob))
    );
    fn test_field_fBounds() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkTextBlob>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fBounds) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(SkTextBlob),
                "::",
                stringify!(fBounds)
            )
        );
    }
    test_field_fBounds();
    fn test_field_fUniqueID() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkTextBlob>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fUniqueID) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(SkTextBlob),
                "::",
                stringify!(fUniqueID)
            )
        );
    }
    test_field_fUniqueID();
    fn test_field_fCacheID() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkTextBlob>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fCacheID) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(SkTextBlob),
                "::",
                stringify!(fCacheID)
            )
        );
    }
    test_field_fCacheID();
}
extern "C" {
    #[link_name = "\u{1}__ZNK10SkTextBlob13getInterceptsEPKfPfPK7SkPaint"]
    pub fn SkTextBlob_getIntercepts(
        this: *const SkTextBlob,
        bounds: *const SkScalar,
        intervals: *mut SkScalar,
        paint: *const SkPaint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkTextBlob12MakeFromTextEPKvmRK6SkFont14SkTextEncoding"]
    pub fn SkTextBlob_MakeFromText(
        text: *const ::core::ffi::c_void,
        byteLength: usize,
        font: *const SkFont,
        encoding: SkTextEncoding,
    ) -> sk_sp<SkTextBlob>;
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkTextBlob16MakeFromPosTextHEPKvmPKffRK6SkFont14SkTextEncoding"]
    pub fn SkTextBlob_MakeFromPosTextH(
        text: *const ::core::ffi::c_void,
        byteLength: usize,
        xpos: *const SkScalar,
        constY: SkScalar,
        font: *const SkFont,
        encoding: SkTextEncoding,
    ) -> sk_sp<SkTextBlob>;
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkTextBlob15MakeFromPosTextEPKvmPK7SkPointRK6SkFont14SkTextEncoding"]
    pub fn SkTextBlob_MakeFromPosText(
        text: *const ::core::ffi::c_void,
        byteLength: usize,
        pos: *const SkPoint,
        font: *const SkFont,
        encoding: SkTextEncoding,
    ) -> sk_sp<SkTextBlob>;
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkTextBlob15MakeFromRSXformEPKvmPK9SkRSXformRK6SkFont14SkTextEncoding"]
    pub fn SkTextBlob_MakeFromRSXform(
        text: *const ::core::ffi::c_void,
        byteLength: usize,
        xform: *const SkRSXform,
        font: *const SkFont,
        encoding: SkTextEncoding,
    ) -> sk_sp<SkTextBlob>;
}
extern "C" {
    #[link_name = "\u{1}__ZNK10SkTextBlob9serializeERK13SkSerialProcsPvm"]
    pub fn SkTextBlob_serialize(
        this: *const SkTextBlob,
        procs: *const SkSerialProcs,
        memory: *mut ::core::ffi::c_void,
        memory_size: usize,
    ) -> usize;
}
extern "C" {
    #[link_name = "\u{1}__ZNK10SkTextBlob9serializeERK13SkSerialProcs"]
    pub fn SkTextBlob_serialize1(
        this: *const SkTextBlob,
        procs: *const SkSerialProcs,
    ) -> sk_sp<SkData>;
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkTextBlob11DeserializeEPKvmRK15SkDeserialProcs"]
    pub fn SkTextBlob_Deserialize(
        data: *const ::core::ffi::c_void,
        size: usize,
        procs: *const SkDeserialProcs,
    ) -> sk_sp<SkTextBlob>;
}
impl SkTextBlob {
    #[inline]
    pub unsafe fn getIntercepts(
        &self,
        bounds: *const SkScalar,
        intervals: *mut SkScalar,
        paint: *const SkPaint,
    ) -> ::std::os::raw::c_int {
        SkTextBlob_getIntercepts(self, bounds, intervals, paint)
    }
    #[inline]
    pub unsafe fn MakeFromText(
        text: *const ::core::ffi::c_void,
        byteLength: usize,
        font: *const SkFont,
        encoding: SkTextEncoding,
    ) -> sk_sp<SkTextBlob> {
        SkTextBlob_MakeFromText(text, byteLength, font, encoding)
    }
    #[inline]
    pub unsafe fn MakeFromPosTextH(
        text: *const ::core::ffi::c_void,
        byteLength: usize,
        xpos: *const SkScalar,
        constY: SkScalar,
        font: *const SkFont,
        encoding: SkTextEncoding,
    ) -> sk_sp<SkTextBlob> {
        SkTextBlob_MakeFromPosTextH(text, byteLength, xpos, constY, font, encoding)
    }
    #[inline]
    pub unsafe fn MakeFromPosText(
        text: *const ::core::ffi::c_void,
        byteLength: usize,
        pos: *const SkPoint,
        font: *const SkFont,
        encoding: SkTextEncoding,
    ) -> sk_sp<SkTextBlob> {
        SkTextBlob_MakeFromPosText(text, byteLength, pos, font, encoding)
    }
    #[inline]
    pub unsafe fn MakeFromRSXform(
        text: *const ::core::ffi::c_void,
        byteLength: usize,
        xform: *const SkRSXform,
        font: *const SkFont,
        encoding: SkTextEncoding,
    ) -> sk_sp<SkTextBlob> {
        SkTextBlob_MakeFromRSXform(text, byteLength, xform, font, encoding)
    }
    #[inline]
    pub unsafe fn serialize(
        &self,
        procs: *const SkSerialProcs,
        memory: *mut ::core::ffi::c_void,
        memory_size: usize,
    ) -> usize {
        SkTextBlob_serialize(self, procs, memory, memory_size)
    }
    #[inline]
    pub unsafe fn serialize1(&self, procs: *const SkSerialProcs) -> sk_sp<SkData> {
        SkTextBlob_serialize1(self, procs)
    }
    #[inline]
    pub unsafe fn Deserialize(
        data: *const ::core::ffi::c_void,
        size: usize,
        procs: *const SkDeserialProcs,
    ) -> sk_sp<SkTextBlob> {
        SkTextBlob_Deserialize(data, size, procs)
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct SkTextBlobBuilder {
    pub fStorage: u64,
    pub fStorageSize: usize,
    pub fStorageUsed: usize,
    pub fBounds: SkRect,
    pub fRunCount: ::std::os::raw::c_int,
    pub fDeferredBounds: bool,
    pub fLastRun: usize,
    pub fCurrentRunBuffer: SkTextBlobBuilder_RunBuffer,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkTextBlobBuilder_RunBuffer {
    pub glyphs: *mut SkGlyphID,
    pub pos: *mut SkScalar,
    pub utf8text: *mut ::std::os::raw::c_char,
    pub clusters: *mut u32,
}
#[test]
fn bindgen_test_layout_SkTextBlobBuilder_RunBuffer() {
    assert_eq!(
        ::core::mem::size_of::<SkTextBlobBuilder_RunBuffer>(),
        32usize,
        concat!("Size of: ", stringify!(SkTextBlobBuilder_RunBuffer))
    );
    assert_eq!(
        ::core::mem::align_of::<SkTextBlobBuilder_RunBuffer>(),
        8usize,
        concat!("Alignment of ", stringify!(SkTextBlobBuilder_RunBuffer))
    );
    fn test_field_glyphs() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkTextBlobBuilder_RunBuffer>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).glyphs) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SkTextBlobBuilder_RunBuffer),
                "::",
                stringify!(glyphs)
            )
        );
    }
    test_field_glyphs();
    fn test_field_pos() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkTextBlobBuilder_RunBuffer>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).pos) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(SkTextBlobBuilder_RunBuffer),
                "::",
                stringify!(pos)
            )
        );
    }
    test_field_pos();
    fn test_field_utf8text() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkTextBlobBuilder_RunBuffer>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).utf8text) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(SkTextBlobBuilder_RunBuffer),
                "::",
                stringify!(utf8text)
            )
        );
    }
    test_field_utf8text();
    fn test_field_clusters() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkTextBlobBuilder_RunBuffer>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).clusters) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(SkTextBlobBuilder_RunBuffer),
                "::",
                stringify!(clusters)
            )
        );
    }
    test_field_clusters();
}
#[test]
fn bindgen_test_layout_SkTextBlobBuilder() {
    assert_eq!(
        ::core::mem::size_of::<SkTextBlobBuilder>(),
        88usize,
        concat!("Size of: ", stringify!(SkTextBlobBuilder))
    );
    assert_eq!(
        ::core::mem::align_of::<SkTextBlobBuilder>(),
        8usize,
        concat!("Alignment of ", stringify!(SkTextBlobBuilder))
    );
    fn test_field_fStorage() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkTextBlobBuilder>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fStorage) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SkTextBlobBuilder),
                "::",
                stringify!(fStorage)
            )
        );
    }
    test_field_fStorage();
    fn test_field_fStorageSize() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkTextBlobBuilder>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fStorageSize) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(SkTextBlobBuilder),
                "::",
                stringify!(fStorageSize)
            )
        );
    }
    test_field_fStorageSize();
    fn test_field_fStorageUsed() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkTextBlobBuilder>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fStorageUsed) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(SkTextBlobBuilder),
                "::",
                stringify!(fStorageUsed)
            )
        );
    }
    test_field_fStorageUsed();
    fn test_field_fBounds() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkTextBlobBuilder>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fBounds) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(SkTextBlobBuilder),
                "::",
                stringify!(fBounds)
            )
        );
    }
    test_field_fBounds();
    fn test_field_fRunCount() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkTextBlobBuilder>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fRunCount) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(SkTextBlobBuilder),
                "::",
                stringify!(fRunCount)
            )
        );
    }
    test_field_fRunCount();
    fn test_field_fDeferredBounds() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkTextBlobBuilder>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fDeferredBounds) as usize - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(SkTextBlobBuilder),
                "::",
                stringify!(fDeferredBounds)
            )
        );
    }
    test_field_fDeferredBounds();
    fn test_field_fLastRun() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkTextBlobBuilder>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fLastRun) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(SkTextBlobBuilder),
                "::",
                stringify!(fLastRun)
            )
        );
    }
    test_field_fLastRun();
    fn test_field_fCurrentRunBuffer() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkTextBlobBuilder>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fCurrentRunBuffer) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(SkTextBlobBuilder),
                "::",
                stringify!(fCurrentRunBuffer)
            )
        );
    }
    test_field_fCurrentRunBuffer();
}
extern "C" {
    #[link_name = "\u{1}__ZN17SkTextBlobBuilder4makeEv"]
    pub fn SkTextBlobBuilder_make(this: *mut SkTextBlobBuilder) -> sk_sp<SkTextBlob>;
}
extern "C" {
    #[link_name = "\u{1}__ZN17SkTextBlobBuilder8allocRunERK6SkFontiffPK6SkRect"]
    pub fn SkTextBlobBuilder_allocRun(
        this: *mut SkTextBlobBuilder,
        font: *const SkFont,
        count: ::std::os::raw::c_int,
        x: SkScalar,
        y: SkScalar,
        bounds: *const SkRect,
    ) -> *const SkTextBlobBuilder_RunBuffer;
}
extern "C" {
    #[link_name = "\u{1}__ZN17SkTextBlobBuilder12allocRunPosHERK6SkFontifPK6SkRect"]
    pub fn SkTextBlobBuilder_allocRunPosH(
        this: *mut SkTextBlobBuilder,
        font: *const SkFont,
        count: ::std::os::raw::c_int,
        y: SkScalar,
        bounds: *const SkRect,
    ) -> *const SkTextBlobBuilder_RunBuffer;
}
extern "C" {
    #[link_name = "\u{1}__ZN17SkTextBlobBuilder11allocRunPosERK6SkFontiPK6SkRect"]
    pub fn SkTextBlobBuilder_allocRunPos(
        this: *mut SkTextBlobBuilder,
        font: *const SkFont,
        count: ::std::os::raw::c_int,
        bounds: *const SkRect,
    ) -> *const SkTextBlobBuilder_RunBuffer;
}
extern "C" {
    #[link_name = "\u{1}__ZN17SkTextBlobBuilder15allocRunRSXformERK6SkFonti"]
    pub fn SkTextBlobBuilder_allocRunRSXform(
        this: *mut SkTextBlobBuilder,
        font: *const SkFont,
        count: ::std::os::raw::c_int,
    ) -> *const SkTextBlobBuilder_RunBuffer;
}
extern "C" {
    #[link_name = "\u{1}__ZN17SkTextBlobBuilder12allocRunTextERK6SkFontiffiPK6SkRect"]
    pub fn SkTextBlobBuilder_allocRunText(
        this: *mut SkTextBlobBuilder,
        font: *const SkFont,
        count: ::std::os::raw::c_int,
        x: SkScalar,
        y: SkScalar,
        textByteCount: ::std::os::raw::c_int,
        bounds: *const SkRect,
    ) -> *const SkTextBlobBuilder_RunBuffer;
}
extern "C" {
    #[link_name = "\u{1}__ZN17SkTextBlobBuilder16allocRunTextPosHERK6SkFontifiPK6SkRect"]
    pub fn SkTextBlobBuilder_allocRunTextPosH(
        this: *mut SkTextBlobBuilder,
        font: *const SkFont,
        count: ::std::os::raw::c_int,
        y: SkScalar,
        textByteCount: ::std::os::raw::c_int,
        bounds: *const SkRect,
    ) -> *const SkTextBlobBuilder_RunBuffer;
}
extern "C" {
    #[link_name = "\u{1}__ZN17SkTextBlobBuilder15allocRunTextPosERK6SkFontiiPK6SkRect"]
    pub fn SkTextBlobBuilder_allocRunTextPos(
        this: *mut SkTextBlobBuilder,
        font: *const SkFont,
        count: ::std::os::raw::c_int,
        textByteCount: ::std::os::raw::c_int,
        bounds: *const SkRect,
    ) -> *const SkTextBlobBuilder_RunBuffer;
}
extern "C" {
    #[link_name = "\u{1}__ZN17SkTextBlobBuilder19allocRunTextRSXformERK6SkFontiiPK6SkRect"]
    pub fn SkTextBlobBuilder_allocRunTextRSXform(
        this: *mut SkTextBlobBuilder,
        font: *const SkFont,
        count: ::std::os::raw::c_int,
        textByteCount: ::std::os::raw::c_int,
        bounds: *const SkRect,
    ) -> *const SkTextBlobBuilder_RunBuffer;
}
extern "C" {
    #[link_name = "\u{1}__ZN17SkTextBlobBuilderC1Ev"]
    pub fn SkTextBlobBuilder_SkTextBlobBuilder(this: *mut SkTextBlobBuilder);
}
extern "C" {
    #[link_name = "\u{1}__ZN17SkTextBlobBuilderD1Ev"]
    pub fn SkTextBlobBuilder_SkTextBlobBuilder_destructor(this: *mut SkTextBlobBuilder);
}
impl SkTextBlobBuilder {
    #[inline]
    pub unsafe fn make(&mut self) -> sk_sp<SkTextBlob> {
        SkTextBlobBuilder_make(self)
    }
    #[inline]
    pub unsafe fn allocRun(
        &mut self,
        font: *const SkFont,
        count: ::std::os::raw::c_int,
        x: SkScalar,
        y: SkScalar,
        bounds: *const SkRect,
    ) -> *const SkTextBlobBuilder_RunBuffer {
        SkTextBlobBuilder_allocRun(self, font, count, x, y, bounds)
    }
    #[inline]
    pub unsafe fn allocRunPosH(
        &mut self,
        font: *const SkFont,
        count: ::std::os::raw::c_int,
        y: SkScalar,
        bounds: *const SkRect,
    ) -> *const SkTextBlobBuilder_RunBuffer {
        SkTextBlobBuilder_allocRunPosH(self, font, count, y, bounds)
    }
    #[inline]
    pub unsafe fn allocRunPos(
        &mut self,
        font: *const SkFont,
        count: ::std::os::raw::c_int,
        bounds: *const SkRect,
    ) -> *const SkTextBlobBuilder_RunBuffer {
        SkTextBlobBuilder_allocRunPos(self, font, count, bounds)
    }
    #[inline]
    pub unsafe fn allocRunRSXform(
        &mut self,
        font: *const SkFont,
        count: ::std::os::raw::c_int,
    ) -> *const SkTextBlobBuilder_RunBuffer {
        SkTextBlobBuilder_allocRunRSXform(self, font, count)
    }
    #[inline]
    pub unsafe fn allocRunText(
        &mut self,
        font: *const SkFont,
        count: ::std::os::raw::c_int,
        x: SkScalar,
        y: SkScalar,
        textByteCount: ::std::os::raw::c_int,
        bounds: *const SkRect,
    ) -> *const SkTextBlobBuilder_RunBuffer {
        SkTextBlobBuilder_allocRunText(self, font, count, x, y, textByteCount, bounds)
    }
    #[inline]
    pub unsafe fn allocRunTextPosH(
        &mut self,
        font: *const SkFont,
        count: ::std::os::raw::c_int,
        y: SkScalar,
        textByteCount: ::std::os::raw::c_int,
        bounds: *const SkRect,
    ) -> *const SkTextBlobBuilder_RunBuffer {
        SkTextBlobBuilder_allocRunTextPosH(self, font, count, y, textByteCount, bounds)
    }
    #[inline]
    pub unsafe fn allocRunTextPos(
        &mut self,
        font: *const SkFont,
        count: ::std::os::raw::c_int,
        textByteCount: ::std::os::raw::c_int,
        bounds: *const SkRect,
    ) -> *const SkTextBlobBuilder_RunBuffer {
        SkTextBlobBuilder_allocRunTextPos(self, font, count, textByteCount, bounds)
    }
    #[inline]
    pub unsafe fn allocRunTextRSXform(
        &mut self,
        font: *const SkFont,
        count: ::std::os::raw::c_int,
        textByteCount: ::std::os::raw::c_int,
        bounds: *const SkRect,
    ) -> *const SkTextBlobBuilder_RunBuffer {
        SkTextBlobBuilder_allocRunTextRSXform(self, font, count, textByteCount, bounds)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkTextBlobBuilder_SkTextBlobBuilder(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        SkTextBlobBuilder_SkTextBlobBuilder_destructor(self)
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct SkVertices {
    pub _base: SkNVRefCnt,
    pub fUniqueID: u32,
    pub fPositions: *mut SkPoint,
    pub fIndices: *mut u16,
    pub fTexs: *mut SkPoint,
    pub fColors: *mut SkColor,
    pub fBounds: SkRect,
    pub fVertexCount: ::std::os::raw::c_int,
    pub fIndexCount: ::std::os::raw::c_int,
    pub fMode: SkVertices_VertexMode,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkVertices_Desc {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkVertices_Sizes {
    _unused: [u8; 0],
}
impl SkVertices_VertexMode {
    pub const Last: SkVertices_VertexMode = SkVertices_VertexMode::TriangleFan;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkVertices_VertexMode {
    Triangles = 0,
    TriangleStrip = 1,
    TriangleFan = 2,
}
pub const SkVertices_BuilderFlags_kHasTexCoords_BuilderFlag: SkVertices_BuilderFlags = 1;
pub const SkVertices_BuilderFlags_kHasColors_BuilderFlag: SkVertices_BuilderFlags = 2;
pub type SkVertices_BuilderFlags = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug)]
pub struct SkVertices_Builder {
    pub fVertices: sk_sp<SkVertices>,
    pub fIntermediateFanIndices: u64,
}
#[test]
fn bindgen_test_layout_SkVertices_Builder() {
    assert_eq!(
        ::core::mem::size_of::<SkVertices_Builder>(),
        16usize,
        concat!("Size of: ", stringify!(SkVertices_Builder))
    );
    assert_eq!(
        ::core::mem::align_of::<SkVertices_Builder>(),
        8usize,
        concat!("Alignment of ", stringify!(SkVertices_Builder))
    );
    fn test_field_fVertices() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkVertices_Builder>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fVertices) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SkVertices_Builder),
                "::",
                stringify!(fVertices)
            )
        );
    }
    test_field_fVertices();
    fn test_field_fIntermediateFanIndices() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkVertices_Builder>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fIntermediateFanIndices) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(SkVertices_Builder),
                "::",
                stringify!(fIntermediateFanIndices)
            )
        );
    }
    test_field_fIntermediateFanIndices();
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkVertices7Builder9positionsEv"]
    pub fn SkVertices_Builder_positions(this: *mut SkVertices_Builder) -> *mut SkPoint;
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkVertices7Builder7indicesEv"]
    pub fn SkVertices_Builder_indices(this: *mut SkVertices_Builder) -> *mut u16;
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkVertices7Builder9texCoordsEv"]
    pub fn SkVertices_Builder_texCoords(this: *mut SkVertices_Builder) -> *mut SkPoint;
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkVertices7Builder6colorsEv"]
    pub fn SkVertices_Builder_colors(this: *mut SkVertices_Builder) -> *mut SkColor;
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkVertices7Builder6detachEv"]
    pub fn SkVertices_Builder_detach(this: *mut SkVertices_Builder) -> sk_sp<SkVertices>;
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkVertices7BuilderC1ENS_10VertexModeEiij"]
    pub fn SkVertices_Builder_Builder(
        this: *mut SkVertices_Builder,
        mode: SkVertices_VertexMode,
        vertexCount: ::std::os::raw::c_int,
        indexCount: ::std::os::raw::c_int,
        flags: u32,
    );
}
impl SkVertices_Builder {
    #[inline]
    pub unsafe fn positions(&mut self) -> *mut SkPoint {
        SkVertices_Builder_positions(self)
    }
    #[inline]
    pub unsafe fn indices(&mut self) -> *mut u16 {
        SkVertices_Builder_indices(self)
    }
    #[inline]
    pub unsafe fn texCoords(&mut self) -> *mut SkPoint {
        SkVertices_Builder_texCoords(self)
    }
    #[inline]
    pub unsafe fn colors(&mut self) -> *mut SkColor {
        SkVertices_Builder_colors(self)
    }
    #[inline]
    pub unsafe fn detach(&mut self) -> sk_sp<SkVertices> {
        SkVertices_Builder_detach(self)
    }
    #[inline]
    pub unsafe fn new(
        mode: SkVertices_VertexMode,
        vertexCount: ::std::os::raw::c_int,
        indexCount: ::std::os::raw::c_int,
        flags: u32,
    ) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkVertices_Builder_Builder(
            __bindgen_tmp.as_mut_ptr(),
            mode,
            vertexCount,
            indexCount,
            flags,
        );
        __bindgen_tmp.assume_init()
    }
}
#[test]
fn bindgen_test_layout_SkVertices() {
    assert_eq!(
        ::core::mem::size_of::<SkVertices>(),
        72usize,
        concat!("Size of: ", stringify!(SkVertices))
    );
    assert_eq!(
        ::core::mem::align_of::<SkVertices>(),
        8usize,
        concat!("Alignment of ", stringify!(SkVertices))
    );
    fn test_field_fUniqueID() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkVertices>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fUniqueID) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(SkVertices),
                "::",
                stringify!(fUniqueID)
            )
        );
    }
    test_field_fUniqueID();
    fn test_field_fPositions() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkVertices>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fPositions) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(SkVertices),
                "::",
                stringify!(fPositions)
            )
        );
    }
    test_field_fPositions();
    fn test_field_fIndices() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkVertices>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fIndices) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(SkVertices),
                "::",
                stringify!(fIndices)
            )
        );
    }
    test_field_fIndices();
    fn test_field_fTexs() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkVertices>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fTexs) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(SkVertices),
                "::",
                stringify!(fTexs)
            )
        );
    }
    test_field_fTexs();
    fn test_field_fColors() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkVertices>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fColors) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(SkVertices),
                "::",
                stringify!(fColors)
            )
        );
    }
    test_field_fColors();
    fn test_field_fBounds() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkVertices>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fBounds) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(SkVertices),
                "::",
                stringify!(fBounds)
            )
        );
    }
    test_field_fBounds();
    fn test_field_fVertexCount() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkVertices>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fVertexCount) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(SkVertices),
                "::",
                stringify!(fVertexCount)
            )
        );
    }
    test_field_fVertexCount();
    fn test_field_fIndexCount() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkVertices>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fIndexCount) as usize - ptr as usize
            },
            60usize,
            concat!(
                "Offset of field: ",
                stringify!(SkVertices),
                "::",
                stringify!(fIndexCount)
            )
        );
    }
    test_field_fIndexCount();
    fn test_field_fMode() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkVertices>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fMode) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(SkVertices),
                "::",
                stringify!(fMode)
            )
        );
    }
    test_field_fMode();
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkVertices8MakeCopyENS_10VertexModeEiPK7SkPointS3_PKjiPKt"]
    pub fn SkVertices_MakeCopy(
        mode: SkVertices_VertexMode,
        vertexCount: ::std::os::raw::c_int,
        positions: *const SkPoint,
        texs: *const SkPoint,
        colors: *const SkColor,
        indexCount: ::std::os::raw::c_int,
        indices: *const u16,
    ) -> sk_sp<SkVertices>;
}
extern "C" {
    #[link_name = "\u{1}__ZNK10SkVertices15approximateSizeEv"]
    pub fn SkVertices_approximateSize(this: *const SkVertices) -> usize;
}
impl SkVertices {
    #[inline]
    pub unsafe fn MakeCopy(
        mode: SkVertices_VertexMode,
        vertexCount: ::std::os::raw::c_int,
        positions: *const SkPoint,
        texs: *const SkPoint,
        colors: *const SkColor,
        indexCount: ::std::os::raw::c_int,
        indices: *const u16,
    ) -> sk_sp<SkVertices> {
        SkVertices_MakeCopy(
            mode,
            vertexCount,
            positions,
            texs,
            colors,
            indexCount,
            indices,
        )
    }
    #[inline]
    pub unsafe fn approximateSize(&self) -> usize {
        SkVertices_approximateSize(self)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkTime_DateTime {
    pub fTimeZoneMinutes: i16,
    pub fYear: u16,
    pub fMonth: u8,
    pub fDayOfWeek: u8,
    pub fDay: u8,
    pub fHour: u8,
    pub fMinute: u8,
    pub fSecond: u8,
}
#[test]
fn bindgen_test_layout_SkTime_DateTime() {
    assert_eq!(
        ::core::mem::size_of::<SkTime_DateTime>(),
        10usize,
        concat!("Size of: ", stringify!(SkTime_DateTime))
    );
    assert_eq!(
        ::core::mem::align_of::<SkTime_DateTime>(),
        2usize,
        concat!("Alignment of ", stringify!(SkTime_DateTime))
    );
    fn test_field_fTimeZoneMinutes() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkTime_DateTime>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fTimeZoneMinutes) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SkTime_DateTime),
                "::",
                stringify!(fTimeZoneMinutes)
            )
        );
    }
    test_field_fTimeZoneMinutes();
    fn test_field_fYear() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkTime_DateTime>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fYear) as usize - ptr as usize
            },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(SkTime_DateTime),
                "::",
                stringify!(fYear)
            )
        );
    }
    test_field_fYear();
    fn test_field_fMonth() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkTime_DateTime>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fMonth) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(SkTime_DateTime),
                "::",
                stringify!(fMonth)
            )
        );
    }
    test_field_fMonth();
    fn test_field_fDayOfWeek() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkTime_DateTime>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fDayOfWeek) as usize - ptr as usize
            },
            5usize,
            concat!(
                "Offset of field: ",
                stringify!(SkTime_DateTime),
                "::",
                stringify!(fDayOfWeek)
            )
        );
    }
    test_field_fDayOfWeek();
    fn test_field_fDay() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkTime_DateTime>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fDay) as usize - ptr as usize
            },
            6usize,
            concat!(
                "Offset of field: ",
                stringify!(SkTime_DateTime),
                "::",
                stringify!(fDay)
            )
        );
    }
    test_field_fDay();
    fn test_field_fHour() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkTime_DateTime>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fHour) as usize - ptr as usize
            },
            7usize,
            concat!(
                "Offset of field: ",
                stringify!(SkTime_DateTime),
                "::",
                stringify!(fHour)
            )
        );
    }
    test_field_fHour();
    fn test_field_fMinute() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkTime_DateTime>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fMinute) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(SkTime_DateTime),
                "::",
                stringify!(fMinute)
            )
        );
    }
    test_field_fMinute();
    fn test_field_fSecond() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkTime_DateTime>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fSecond) as usize - ptr as usize
            },
            9usize,
            concat!(
                "Offset of field: ",
                stringify!(SkTime_DateTime),
                "::",
                stringify!(fSecond)
            )
        );
    }
    test_field_fSecond();
}
extern "C" {
    #[link_name = "\u{1}__ZNK6SkTime8DateTime9toISO8601EP8SkString"]
    pub fn SkTime_DateTime_toISO8601(this: *const SkTime_DateTime, dst: *mut SkString);
}
impl SkTime_DateTime {
    #[inline]
    pub unsafe fn toISO8601(&self, dst: *mut SkString) {
        SkTime_DateTime_toISO8601(self, dst)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkExecutor {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkPDFArray {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct SkPDF_AttributeList {
    pub fAttrs: u64,
}
#[test]
fn bindgen_test_layout_SkPDF_AttributeList() {
    assert_eq!(
        ::core::mem::size_of::<SkPDF_AttributeList>(),
        8usize,
        concat!("Size of: ", stringify!(SkPDF_AttributeList))
    );
    assert_eq!(
        ::core::mem::align_of::<SkPDF_AttributeList>(),
        8usize,
        concat!("Alignment of ", stringify!(SkPDF_AttributeList))
    );
    fn test_field_fAttrs() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkPDF_AttributeList>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fAttrs) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SkPDF_AttributeList),
                "::",
                stringify!(fAttrs)
            )
        );
    }
    test_field_fAttrs();
}
extern "C" {
    #[link_name = "\u{1}__ZN5SkPDF13AttributeList9appendIntEPKcS2_i"]
    pub fn SkPDF_AttributeList_appendInt(
        this: *mut SkPDF_AttributeList,
        owner: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        value: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN5SkPDF13AttributeList11appendFloatEPKcS2_f"]
    pub fn SkPDF_AttributeList_appendFloat(
        this: *mut SkPDF_AttributeList,
        owner: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        value: f32,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN5SkPDF13AttributeList10appendNameEPKcS2_S2_"]
    pub fn SkPDF_AttributeList_appendName(
        this: *mut SkPDF_AttributeList,
        owner: *const ::std::os::raw::c_char,
        attrName: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN5SkPDF13AttributeList16appendFloatArrayEPKcS2_RKNSt3__16vectorIfNS3_9allocatorIfEEEE"]
    pub fn SkPDF_AttributeList_appendFloatArray(
        this: *mut SkPDF_AttributeList,
        owner: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        value: *const [u64; 3usize],
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN5SkPDF13AttributeList17appendNodeIdArrayEPKcS2_RKNSt3__16vectorIiNS3_9allocatorIiEEEE"]
    pub fn SkPDF_AttributeList_appendNodeIdArray(
        this: *mut SkPDF_AttributeList,
        owner: *const ::std::os::raw::c_char,
        attrName: *const ::std::os::raw::c_char,
        nodeIds: *const [u64; 3usize],
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN5SkPDF13AttributeListC1Ev"]
    pub fn SkPDF_AttributeList_AttributeList(this: *mut SkPDF_AttributeList);
}
extern "C" {
    #[link_name = "\u{1}__ZN5SkPDF13AttributeListD1Ev"]
    pub fn SkPDF_AttributeList_AttributeList_destructor(this: *mut SkPDF_AttributeList);
}
impl SkPDF_AttributeList {
    #[inline]
    pub unsafe fn appendInt(
        &mut self,
        owner: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        value: ::std::os::raw::c_int,
    ) {
        SkPDF_AttributeList_appendInt(self, owner, name, value)
    }
    #[inline]
    pub unsafe fn appendFloat(
        &mut self,
        owner: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        value: f32,
    ) {
        SkPDF_AttributeList_appendFloat(self, owner, name, value)
    }
    #[inline]
    pub unsafe fn appendName(
        &mut self,
        owner: *const ::std::os::raw::c_char,
        attrName: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) {
        SkPDF_AttributeList_appendName(self, owner, attrName, value)
    }
    #[inline]
    pub unsafe fn appendFloatArray(
        &mut self,
        owner: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        value: *const [u64; 3usize],
    ) {
        SkPDF_AttributeList_appendFloatArray(self, owner, name, value)
    }
    #[inline]
    pub unsafe fn appendNodeIdArray(
        &mut self,
        owner: *const ::std::os::raw::c_char,
        attrName: *const ::std::os::raw::c_char,
        nodeIds: *const [u64; 3usize],
    ) {
        SkPDF_AttributeList_appendNodeIdArray(self, owner, attrName, nodeIds)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkPDF_AttributeList_AttributeList(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        SkPDF_AttributeList_AttributeList_destructor(self)
    }
}
#[repr(C)]
pub struct SkPDF_StructureElementNode {
    pub fTypeString: SkString,
    pub fChildVector: [u64; 3usize],
    pub fNodeId: ::std::os::raw::c_int,
    pub fAdditionalNodeIds: [u64; 3usize],
    pub fAttributes: SkPDF_AttributeList,
    pub fAlt: SkString,
    pub fLang: SkString,
}
#[test]
fn bindgen_test_layout_SkPDF_StructureElementNode() {
    assert_eq!(
        ::core::mem::size_of::<SkPDF_StructureElementNode>(),
        88usize,
        concat!("Size of: ", stringify!(SkPDF_StructureElementNode))
    );
    assert_eq!(
        ::core::mem::align_of::<SkPDF_StructureElementNode>(),
        8usize,
        concat!("Alignment of ", stringify!(SkPDF_StructureElementNode))
    );
    fn test_field_fTypeString() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkPDF_StructureElementNode>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fTypeString) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SkPDF_StructureElementNode),
                "::",
                stringify!(fTypeString)
            )
        );
    }
    test_field_fTypeString();
    fn test_field_fChildVector() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkPDF_StructureElementNode>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fChildVector) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(SkPDF_StructureElementNode),
                "::",
                stringify!(fChildVector)
            )
        );
    }
    test_field_fChildVector();
    fn test_field_fNodeId() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkPDF_StructureElementNode>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fNodeId) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(SkPDF_StructureElementNode),
                "::",
                stringify!(fNodeId)
            )
        );
    }
    test_field_fNodeId();
    fn test_field_fAdditionalNodeIds() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkPDF_StructureElementNode>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fAdditionalNodeIds) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(SkPDF_StructureElementNode),
                "::",
                stringify!(fAdditionalNodeIds)
            )
        );
    }
    test_field_fAdditionalNodeIds();
    fn test_field_fAttributes() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkPDF_StructureElementNode>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fAttributes) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(SkPDF_StructureElementNode),
                "::",
                stringify!(fAttributes)
            )
        );
    }
    test_field_fAttributes();
    fn test_field_fAlt() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkPDF_StructureElementNode>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fAlt) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(SkPDF_StructureElementNode),
                "::",
                stringify!(fAlt)
            )
        );
    }
    test_field_fAlt();
    fn test_field_fLang() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkPDF_StructureElementNode>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fLang) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(SkPDF_StructureElementNode),
                "::",
                stringify!(fLang)
            )
        );
    }
    test_field_fLang();
}
#[repr(C)]
#[derive(Debug)]
pub struct SkPDF_Metadata {
    pub fTitle: SkString,
    pub fAuthor: SkString,
    pub fSubject: SkString,
    pub fKeywords: SkString,
    pub fCreator: SkString,
    pub fProducer: SkString,
    pub fCreation: SkTime_DateTime,
    pub fModified: SkTime_DateTime,
    pub fRasterDPI: SkScalar,
    pub fPDFA: bool,
    pub fEncodingQuality: ::std::os::raw::c_int,
    pub fStructureElementTreeRoot: *mut SkPDF_StructureElementNode,
    pub fExecutor: *mut SkExecutor,
    pub fSubsetter: SkPDF_Metadata_Subsetter,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkPDF_Metadata_Subsetter {
    kHarfbuzz_Subsetter = 0,
    kSfntly_Subsetter = 1,
}
#[test]
fn bindgen_test_layout_SkPDF_Metadata() {
    assert_eq!(
        ::core::mem::size_of::<SkPDF_Metadata>(),
        104usize,
        concat!("Size of: ", stringify!(SkPDF_Metadata))
    );
    assert_eq!(
        ::core::mem::align_of::<SkPDF_Metadata>(),
        8usize,
        concat!("Alignment of ", stringify!(SkPDF_Metadata))
    );
    fn test_field_fTitle() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkPDF_Metadata>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fTitle) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SkPDF_Metadata),
                "::",
                stringify!(fTitle)
            )
        );
    }
    test_field_fTitle();
    fn test_field_fAuthor() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkPDF_Metadata>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fAuthor) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(SkPDF_Metadata),
                "::",
                stringify!(fAuthor)
            )
        );
    }
    test_field_fAuthor();
    fn test_field_fSubject() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkPDF_Metadata>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fSubject) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(SkPDF_Metadata),
                "::",
                stringify!(fSubject)
            )
        );
    }
    test_field_fSubject();
    fn test_field_fKeywords() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkPDF_Metadata>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fKeywords) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(SkPDF_Metadata),
                "::",
                stringify!(fKeywords)
            )
        );
    }
    test_field_fKeywords();
    fn test_field_fCreator() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkPDF_Metadata>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fCreator) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(SkPDF_Metadata),
                "::",
                stringify!(fCreator)
            )
        );
    }
    test_field_fCreator();
    fn test_field_fProducer() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkPDF_Metadata>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fProducer) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(SkPDF_Metadata),
                "::",
                stringify!(fProducer)
            )
        );
    }
    test_field_fProducer();
    fn test_field_fCreation() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkPDF_Metadata>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fCreation) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(SkPDF_Metadata),
                "::",
                stringify!(fCreation)
            )
        );
    }
    test_field_fCreation();
    fn test_field_fModified() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkPDF_Metadata>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fModified) as usize - ptr as usize
            },
            58usize,
            concat!(
                "Offset of field: ",
                stringify!(SkPDF_Metadata),
                "::",
                stringify!(fModified)
            )
        );
    }
    test_field_fModified();
    fn test_field_fRasterDPI() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkPDF_Metadata>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fRasterDPI) as usize - ptr as usize
            },
            68usize,
            concat!(
                "Offset of field: ",
                stringify!(SkPDF_Metadata),
                "::",
                stringify!(fRasterDPI)
            )
        );
    }
    test_field_fRasterDPI();
    fn test_field_fPDFA() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkPDF_Metadata>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fPDFA) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(SkPDF_Metadata),
                "::",
                stringify!(fPDFA)
            )
        );
    }
    test_field_fPDFA();
    fn test_field_fEncodingQuality() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkPDF_Metadata>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fEncodingQuality) as usize - ptr as usize
            },
            76usize,
            concat!(
                "Offset of field: ",
                stringify!(SkPDF_Metadata),
                "::",
                stringify!(fEncodingQuality)
            )
        );
    }
    test_field_fEncodingQuality();
    fn test_field_fStructureElementTreeRoot() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkPDF_Metadata>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fStructureElementTreeRoot) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(SkPDF_Metadata),
                "::",
                stringify!(fStructureElementTreeRoot)
            )
        );
    }
    test_field_fStructureElementTreeRoot();
    fn test_field_fExecutor() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkPDF_Metadata>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fExecutor) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(SkPDF_Metadata),
                "::",
                stringify!(fExecutor)
            )
        );
    }
    test_field_fExecutor();
    fn test_field_fSubsetter() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkPDF_Metadata>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fSubsetter) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(SkPDF_Metadata),
                "::",
                stringify!(fSubsetter)
            )
        );
    }
    test_field_fSubsetter();
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct SkPathEffect {
    pub _bindgen_opaque_blob: [u64; 2usize],
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkPathEffect_DashType {
    kNone_DashType = 0,
    kDash_DashType = 1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkPathEffect_DashInfo {
    pub fIntervals: *mut SkScalar,
    pub fCount: i32,
    pub fPhase: SkScalar,
}
#[test]
fn bindgen_test_layout_SkPathEffect_DashInfo() {
    assert_eq!(
        ::core::mem::size_of::<SkPathEffect_DashInfo>(),
        16usize,
        concat!("Size of: ", stringify!(SkPathEffect_DashInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<SkPathEffect_DashInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(SkPathEffect_DashInfo))
    );
    fn test_field_fIntervals() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkPathEffect_DashInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fIntervals) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SkPathEffect_DashInfo),
                "::",
                stringify!(fIntervals)
            )
        );
    }
    test_field_fIntervals();
    fn test_field_fCount() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkPathEffect_DashInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fCount) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(SkPathEffect_DashInfo),
                "::",
                stringify!(fCount)
            )
        );
    }
    test_field_fCount();
    fn test_field_fPhase() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkPathEffect_DashInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fPhase) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(SkPathEffect_DashInfo),
                "::",
                stringify!(fPhase)
            )
        );
    }
    test_field_fPhase();
}
pub type SkPathEffect_INHERITED = SkFlattenable;
#[test]
fn bindgen_test_layout_SkPathEffect() {
    assert_eq!(
        ::core::mem::size_of::<SkPathEffect>(),
        16usize,
        concat!("Size of: ", stringify!(SkPathEffect))
    );
    assert_eq!(
        ::core::mem::align_of::<SkPathEffect>(),
        8usize,
        concat!("Alignment of ", stringify!(SkPathEffect))
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN12SkPathEffect7MakeSumE5sk_spIS_ES1_"]
    pub fn SkPathEffect_MakeSum(
        first: sk_sp<SkPathEffect>,
        second: sk_sp<SkPathEffect>,
    ) -> sk_sp<SkPathEffect>;
}
extern "C" {
    #[link_name = "\u{1}__ZN12SkPathEffect11MakeComposeE5sk_spIS_ES1_"]
    pub fn SkPathEffect_MakeCompose(
        outer: sk_sp<SkPathEffect>,
        inner: sk_sp<SkPathEffect>,
    ) -> sk_sp<SkPathEffect>;
}
extern "C" {
    #[link_name = "\u{1}__ZNK12SkPathEffect7asADashEPNS_8DashInfoE"]
    pub fn SkPathEffect_asADash(
        this: *const SkPathEffect,
        info: *mut SkPathEffect_DashInfo,
    ) -> SkPathEffect_DashType;
}
extern "C" {
    #[link_name = "\u{1}__ZNK12SkPathEffect10filterPathEP6SkPathRKS0_P11SkStrokeRecPK6SkRect"]
    pub fn SkPathEffect_filterPath(
        this: *const SkPathEffect,
        dst: *mut SkPath,
        src: *const SkPath,
        arg1: *mut SkStrokeRec,
        cullR: *const SkRect,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK12SkPathEffect10filterPathEP6SkPathRKS0_P11SkStrokeRecPK6SkRectRK8SkMatrix"]
    pub fn SkPathEffect_filterPath1(
        this: *const SkPathEffect,
        dst: *mut SkPath,
        src: *const SkPath,
        arg1: *mut SkStrokeRec,
        cullR: *const SkRect,
        ctm: *const SkMatrix,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK12SkPathEffect8needsCTMEv"]
    pub fn SkPathEffect_needsCTM(this: *const SkPathEffect) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN12SkPathEffect11DeserializeEPKvmPK15SkDeserialProcs"]
    pub fn SkPathEffect_Deserialize(
        data: *const ::core::ffi::c_void,
        size: usize,
        procs: *const SkDeserialProcs,
    ) -> sk_sp<SkPathEffect>;
}
impl SkPathEffect {
    #[inline]
    pub unsafe fn MakeSum(
        first: sk_sp<SkPathEffect>,
        second: sk_sp<SkPathEffect>,
    ) -> sk_sp<SkPathEffect> {
        SkPathEffect_MakeSum(first, second)
    }
    #[inline]
    pub unsafe fn MakeCompose(
        outer: sk_sp<SkPathEffect>,
        inner: sk_sp<SkPathEffect>,
    ) -> sk_sp<SkPathEffect> {
        SkPathEffect_MakeCompose(outer, inner)
    }
    #[inline]
    pub unsafe fn asADash(&self, info: *mut SkPathEffect_DashInfo) -> SkPathEffect_DashType {
        SkPathEffect_asADash(self, info)
    }
    #[inline]
    pub unsafe fn filterPath(
        &self,
        dst: *mut SkPath,
        src: *const SkPath,
        arg1: *mut SkStrokeRec,
        cullR: *const SkRect,
    ) -> bool {
        SkPathEffect_filterPath(self, dst, src, arg1, cullR)
    }
    #[inline]
    pub unsafe fn filterPath1(
        &self,
        dst: *mut SkPath,
        src: *const SkPath,
        arg1: *mut SkStrokeRec,
        cullR: *const SkRect,
        ctm: *const SkMatrix,
    ) -> bool {
        SkPathEffect_filterPath1(self, dst, src, arg1, cullR, ctm)
    }
    #[inline]
    pub unsafe fn needsCTM(&self) -> bool {
        SkPathEffect_needsCTM(self)
    }
    #[inline]
    pub unsafe fn Deserialize(
        data: *const ::core::ffi::c_void,
        size: usize,
        procs: *const SkDeserialProcs,
    ) -> sk_sp<SkPathEffect> {
        SkPathEffect_Deserialize(data, size, procs)
    }
}
impl SkPath1DPathEffect_Style {
    pub const LastEnum: SkPath1DPathEffect_Style = SkPath1DPathEffect_Style::Morph;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkPath1DPathEffect_Style {
    Translate = 0,
    Rotate = 1,
    Morph = 2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkBlender {
    pub _base: SkFlattenable,
}
pub type SkBlender_INHERITED = SkFlattenable;
#[test]
fn bindgen_test_layout_SkBlender() {
    assert_eq!(
        ::core::mem::size_of::<SkBlender>(),
        16usize,
        concat!("Size of: ", stringify!(SkBlender))
    );
    assert_eq!(
        ::core::mem::align_of::<SkBlender>(),
        8usize,
        concat!("Alignment of ", stringify!(SkBlender))
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN9SkBlender4ModeE11SkBlendMode"]
    pub fn SkBlender_Mode(mode: SkBlendMode) -> sk_sp<SkBlender>;
}
impl SkBlender {
    #[inline]
    pub unsafe fn Mode(mode: SkBlendMode) -> sk_sp<SkBlender> {
        SkBlender_Mode(mode)
    }
}
#[repr(C)]
pub struct SkColorMatrix {
    pub fMat: [u32; 20usize],
}
#[test]
fn bindgen_test_layout_SkColorMatrix() {
    assert_eq!(
        ::core::mem::size_of::<SkColorMatrix>(),
        80usize,
        concat!("Size of: ", stringify!(SkColorMatrix))
    );
    assert_eq!(
        ::core::mem::align_of::<SkColorMatrix>(),
        4usize,
        concat!("Alignment of ", stringify!(SkColorMatrix))
    );
    fn test_field_fMat() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkColorMatrix>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fMat) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SkColorMatrix),
                "::",
                stringify!(fMat)
            )
        );
    }
    test_field_fMat();
}
extern "C" {
    #[link_name = "\u{1}__ZN13SkColorMatrix8RGBtoYUVE15SkYUVColorSpace"]
    pub fn SkColorMatrix_RGBtoYUV(arg1: SkYUVColorSpace) -> SkColorMatrix;
}
extern "C" {
    #[link_name = "\u{1}__ZN13SkColorMatrix8YUVtoRGBE15SkYUVColorSpace"]
    pub fn SkColorMatrix_YUVtoRGB(arg1: SkYUVColorSpace) -> SkColorMatrix;
}
extern "C" {
    #[link_name = "\u{1}__ZN13SkColorMatrix11setIdentityEv"]
    pub fn SkColorMatrix_setIdentity(this: *mut SkColorMatrix);
}
extern "C" {
    #[link_name = "\u{1}__ZN13SkColorMatrix8setScaleEffff"]
    pub fn SkColorMatrix_setScale(
        this: *mut SkColorMatrix,
        rScale: f32,
        gScale: f32,
        bScale: f32,
        aScale: f32,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN13SkColorMatrix13postTranslateEffff"]
    pub fn SkColorMatrix_postTranslate(
        this: *mut SkColorMatrix,
        dr: f32,
        dg: f32,
        db: f32,
        da: f32,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN13SkColorMatrix9setConcatERKS_S1_"]
    pub fn SkColorMatrix_setConcat(
        this: *mut SkColorMatrix,
        a: *const SkColorMatrix,
        b: *const SkColorMatrix,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN13SkColorMatrix13setSaturationEf"]
    pub fn SkColorMatrix_setSaturation(this: *mut SkColorMatrix, sat: f32);
}
impl SkColorMatrix {
    #[inline]
    pub unsafe fn RGBtoYUV(arg1: SkYUVColorSpace) -> SkColorMatrix {
        SkColorMatrix_RGBtoYUV(arg1)
    }
    #[inline]
    pub unsafe fn YUVtoRGB(arg1: SkYUVColorSpace) -> SkColorMatrix {
        SkColorMatrix_YUVtoRGB(arg1)
    }
    #[inline]
    pub unsafe fn setIdentity(&mut self) {
        SkColorMatrix_setIdentity(self)
    }
    #[inline]
    pub unsafe fn setScale(&mut self, rScale: f32, gScale: f32, bScale: f32, aScale: f32) {
        SkColorMatrix_setScale(self, rScale, gScale, bScale, aScale)
    }
    #[inline]
    pub unsafe fn postTranslate(&mut self, dr: f32, dg: f32, db: f32, da: f32) {
        SkColorMatrix_postTranslate(self, dr, dg, db, da)
    }
    #[inline]
    pub unsafe fn setConcat(&mut self, a: *const SkColorMatrix, b: *const SkColorMatrix) {
        SkColorMatrix_setConcat(self, a, b)
    }
    #[inline]
    pub unsafe fn setSaturation(&mut self, sat: f32) {
        SkColorMatrix_setSaturation(self, sat)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkGradientShader {
    pub _address: u8,
}
pub const SkGradientShader_Flags_kInterpolateColorsInPremul_Flag: SkGradientShader_Flags = 1;
pub type SkGradientShader_Flags = ::std::os::raw::c_uint;
#[test]
fn bindgen_test_layout_SkGradientShader() {
    assert_eq!(
        ::core::mem::size_of::<SkGradientShader>(),
        1usize,
        concat!("Size of: ", stringify!(SkGradientShader))
    );
    assert_eq!(
        ::core::mem::align_of::<SkGradientShader>(),
        1usize,
        concat!("Alignment of ", stringify!(SkGradientShader))
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN16SkGradientShader10MakeLinearEPK7SkPointPKjPKfi10SkTileModejPK8SkMatrix"]
    pub fn SkGradientShader_MakeLinear(
        pts: *const SkPoint,
        colors: *const SkColor,
        pos: *const SkScalar,
        count: ::std::os::raw::c_int,
        mode: SkTileMode,
        flags: u32,
        localMatrix: *const SkMatrix,
    ) -> sk_sp<SkShader>;
}
extern "C" {
    #[link_name = "\u{1}__ZN16SkGradientShader10MakeLinearEPK7SkPointPK8SkRGBA4fIL11SkAlphaType3EE5sk_spI12SkColorSpaceEPKfi10SkTileModejPK8SkMatrix"]
    pub fn SkGradientShader_MakeLinear1(
        pts: *const SkPoint,
        colors: *const SkColor4f,
        colorSpace: sk_sp<SkColorSpace>,
        pos: *const SkScalar,
        count: ::std::os::raw::c_int,
        mode: SkTileMode,
        flags: u32,
        localMatrix: *const SkMatrix,
    ) -> sk_sp<SkShader>;
}
extern "C" {
    #[link_name = "\u{1}__ZN16SkGradientShader10MakeLinearEPK7SkPointPK8SkRGBA4fIL11SkAlphaType3EE5sk_spI12SkColorSpaceEPKfi10SkTileMode"]
    pub fn SkGradientShader_MakeLinear2(
        pts: *const SkPoint,
        colors: *const SkColor4f,
        colorSpace: sk_sp<SkColorSpace>,
        pos: *const SkScalar,
        count: ::std::os::raw::c_int,
        mode: SkTileMode,
    ) -> sk_sp<SkShader>;
}
extern "C" {
    #[link_name = "\u{1}__ZN16SkGradientShader10MakeRadialERK7SkPointfPKjPKfi10SkTileModejPK8SkMatrix"]
    pub fn SkGradientShader_MakeRadial(
        center: *const SkPoint,
        radius: SkScalar,
        colors: *const SkColor,
        pos: *const SkScalar,
        count: ::std::os::raw::c_int,
        mode: SkTileMode,
        flags: u32,
        localMatrix: *const SkMatrix,
    ) -> sk_sp<SkShader>;
}
extern "C" {
    #[link_name = "\u{1}__ZN16SkGradientShader10MakeRadialERK7SkPointfPK8SkRGBA4fIL11SkAlphaType3EE5sk_spI12SkColorSpaceEPKfi10SkTileModejPK8SkMatrix"]
    pub fn SkGradientShader_MakeRadial1(
        center: *const SkPoint,
        radius: SkScalar,
        colors: *const SkColor4f,
        colorSpace: sk_sp<SkColorSpace>,
        pos: *const SkScalar,
        count: ::std::os::raw::c_int,
        mode: SkTileMode,
        flags: u32,
        localMatrix: *const SkMatrix,
    ) -> sk_sp<SkShader>;
}
extern "C" {
    #[link_name = "\u{1}__ZN16SkGradientShader10MakeRadialERK7SkPointfPK8SkRGBA4fIL11SkAlphaType3EE5sk_spI12SkColorSpaceEPKfi10SkTileMode"]
    pub fn SkGradientShader_MakeRadial2(
        center: *const SkPoint,
        radius: SkScalar,
        colors: *const SkColor4f,
        colorSpace: sk_sp<SkColorSpace>,
        pos: *const SkScalar,
        count: ::std::os::raw::c_int,
        mode: SkTileMode,
    ) -> sk_sp<SkShader>;
}
extern "C" {
    #[link_name = "\u{1}__ZN16SkGradientShader19MakeTwoPointConicalERK7SkPointfS2_fPKjPKfi10SkTileModejPK8SkMatrix"]
    pub fn SkGradientShader_MakeTwoPointConical(
        start: *const SkPoint,
        startRadius: SkScalar,
        end: *const SkPoint,
        endRadius: SkScalar,
        colors: *const SkColor,
        pos: *const SkScalar,
        count: ::std::os::raw::c_int,
        mode: SkTileMode,
        flags: u32,
        localMatrix: *const SkMatrix,
    ) -> sk_sp<SkShader>;
}
extern "C" {
    #[link_name = "\u{1}__ZN16SkGradientShader19MakeTwoPointConicalERK7SkPointfS2_fPK8SkRGBA4fIL11SkAlphaType3EE5sk_spI12SkColorSpaceEPKfi10SkTileModejPK8SkMatrix"]
    pub fn SkGradientShader_MakeTwoPointConical1(
        start: *const SkPoint,
        startRadius: SkScalar,
        end: *const SkPoint,
        endRadius: SkScalar,
        colors: *const SkColor4f,
        colorSpace: sk_sp<SkColorSpace>,
        pos: *const SkScalar,
        count: ::std::os::raw::c_int,
        mode: SkTileMode,
        flags: u32,
        localMatrix: *const SkMatrix,
    ) -> sk_sp<SkShader>;
}
extern "C" {
    #[link_name = "\u{1}__ZN16SkGradientShader19MakeTwoPointConicalERK7SkPointfS2_fPK8SkRGBA4fIL11SkAlphaType3EE5sk_spI12SkColorSpaceEPKfi10SkTileMode"]
    pub fn SkGradientShader_MakeTwoPointConical2(
        start: *const SkPoint,
        startRadius: SkScalar,
        end: *const SkPoint,
        endRadius: SkScalar,
        colors: *const SkColor4f,
        colorSpace: sk_sp<SkColorSpace>,
        pos: *const SkScalar,
        count: ::std::os::raw::c_int,
        mode: SkTileMode,
    ) -> sk_sp<SkShader>;
}
extern "C" {
    #[link_name = "\u{1}__ZN16SkGradientShader9MakeSweepEffPKjPKfi10SkTileModeffjPK8SkMatrix"]
    pub fn SkGradientShader_MakeSweep(
        cx: SkScalar,
        cy: SkScalar,
        colors: *const SkColor,
        pos: *const SkScalar,
        count: ::std::os::raw::c_int,
        mode: SkTileMode,
        startAngle: SkScalar,
        endAngle: SkScalar,
        flags: u32,
        localMatrix: *const SkMatrix,
    ) -> sk_sp<SkShader>;
}
extern "C" {
    #[link_name = "\u{1}__ZN16SkGradientShader9MakeSweepEffPK8SkRGBA4fIL11SkAlphaType3EE5sk_spI12SkColorSpaceEPKfi10SkTileModeffjPK8SkMatrix"]
    pub fn SkGradientShader_MakeSweep1(
        cx: SkScalar,
        cy: SkScalar,
        colors: *const SkColor4f,
        colorSpace: sk_sp<SkColorSpace>,
        pos: *const SkScalar,
        count: ::std::os::raw::c_int,
        mode: SkTileMode,
        startAngle: SkScalar,
        endAngle: SkScalar,
        flags: u32,
        localMatrix: *const SkMatrix,
    ) -> sk_sp<SkShader>;
}
extern "C" {
    #[link_name = "\u{1}__ZN16SkGradientShader9MakeSweepEffPK8SkRGBA4fIL11SkAlphaType3EE5sk_spI12SkColorSpaceEPKfijPK8SkMatrix"]
    pub fn SkGradientShader_MakeSweep2(
        cx: SkScalar,
        cy: SkScalar,
        colors: *const SkColor4f,
        colorSpace: sk_sp<SkColorSpace>,
        pos: *const SkScalar,
        count: ::std::os::raw::c_int,
        flags: u32,
        localMatrix: *const SkMatrix,
    ) -> sk_sp<SkShader>;
}
extern "C" {
    #[link_name = "\u{1}__ZN16SkGradientShader9MakeSweepEffPK8SkRGBA4fIL11SkAlphaType3EE5sk_spI12SkColorSpaceEPKfi"]
    pub fn SkGradientShader_MakeSweep3(
        cx: SkScalar,
        cy: SkScalar,
        colors: *const SkColor4f,
        colorSpace: sk_sp<SkColorSpace>,
        pos: *const SkScalar,
        count: ::std::os::raw::c_int,
    ) -> sk_sp<SkShader>;
}
extern "C" {
    #[link_name = "\u{1}__ZN16SkGradientShader20RegisterFlattenablesEv"]
    pub fn SkGradientShader_RegisterFlattenables();
}
impl SkGradientShader {
    #[inline]
    pub unsafe fn MakeLinear(
        pts: *const SkPoint,
        colors: *const SkColor,
        pos: *const SkScalar,
        count: ::std::os::raw::c_int,
        mode: SkTileMode,
        flags: u32,
        localMatrix: *const SkMatrix,
    ) -> sk_sp<SkShader> {
        SkGradientShader_MakeLinear(pts, colors, pos, count, mode, flags, localMatrix)
    }
    #[inline]
    pub unsafe fn MakeLinear1(
        pts: *const SkPoint,
        colors: *const SkColor4f,
        colorSpace: sk_sp<SkColorSpace>,
        pos: *const SkScalar,
        count: ::std::os::raw::c_int,
        mode: SkTileMode,
        flags: u32,
        localMatrix: *const SkMatrix,
    ) -> sk_sp<SkShader> {
        SkGradientShader_MakeLinear1(
            pts,
            colors,
            colorSpace,
            pos,
            count,
            mode,
            flags,
            localMatrix,
        )
    }
    #[inline]
    pub unsafe fn MakeLinear2(
        pts: *const SkPoint,
        colors: *const SkColor4f,
        colorSpace: sk_sp<SkColorSpace>,
        pos: *const SkScalar,
        count: ::std::os::raw::c_int,
        mode: SkTileMode,
    ) -> sk_sp<SkShader> {
        SkGradientShader_MakeLinear2(pts, colors, colorSpace, pos, count, mode)
    }
    #[inline]
    pub unsafe fn MakeRadial(
        center: *const SkPoint,
        radius: SkScalar,
        colors: *const SkColor,
        pos: *const SkScalar,
        count: ::std::os::raw::c_int,
        mode: SkTileMode,
        flags: u32,
        localMatrix: *const SkMatrix,
    ) -> sk_sp<SkShader> {
        SkGradientShader_MakeRadial(center, radius, colors, pos, count, mode, flags, localMatrix)
    }
    #[inline]
    pub unsafe fn MakeRadial1(
        center: *const SkPoint,
        radius: SkScalar,
        colors: *const SkColor4f,
        colorSpace: sk_sp<SkColorSpace>,
        pos: *const SkScalar,
        count: ::std::os::raw::c_int,
        mode: SkTileMode,
        flags: u32,
        localMatrix: *const SkMatrix,
    ) -> sk_sp<SkShader> {
        SkGradientShader_MakeRadial1(
            center,
            radius,
            colors,
            colorSpace,
            pos,
            count,
            mode,
            flags,
            localMatrix,
        )
    }
    #[inline]
    pub unsafe fn MakeRadial2(
        center: *const SkPoint,
        radius: SkScalar,
        colors: *const SkColor4f,
        colorSpace: sk_sp<SkColorSpace>,
        pos: *const SkScalar,
        count: ::std::os::raw::c_int,
        mode: SkTileMode,
    ) -> sk_sp<SkShader> {
        SkGradientShader_MakeRadial2(center, radius, colors, colorSpace, pos, count, mode)
    }
    #[inline]
    pub unsafe fn MakeTwoPointConical(
        start: *const SkPoint,
        startRadius: SkScalar,
        end: *const SkPoint,
        endRadius: SkScalar,
        colors: *const SkColor,
        pos: *const SkScalar,
        count: ::std::os::raw::c_int,
        mode: SkTileMode,
        flags: u32,
        localMatrix: *const SkMatrix,
    ) -> sk_sp<SkShader> {
        SkGradientShader_MakeTwoPointConical(
            start,
            startRadius,
            end,
            endRadius,
            colors,
            pos,
            count,
            mode,
            flags,
            localMatrix,
        )
    }
    #[inline]
    pub unsafe fn MakeTwoPointConical1(
        start: *const SkPoint,
        startRadius: SkScalar,
        end: *const SkPoint,
        endRadius: SkScalar,
        colors: *const SkColor4f,
        colorSpace: sk_sp<SkColorSpace>,
        pos: *const SkScalar,
        count: ::std::os::raw::c_int,
        mode: SkTileMode,
        flags: u32,
        localMatrix: *const SkMatrix,
    ) -> sk_sp<SkShader> {
        SkGradientShader_MakeTwoPointConical1(
            start,
            startRadius,
            end,
            endRadius,
            colors,
            colorSpace,
            pos,
            count,
            mode,
            flags,
            localMatrix,
        )
    }
    #[inline]
    pub unsafe fn MakeTwoPointConical2(
        start: *const SkPoint,
        startRadius: SkScalar,
        end: *const SkPoint,
        endRadius: SkScalar,
        colors: *const SkColor4f,
        colorSpace: sk_sp<SkColorSpace>,
        pos: *const SkScalar,
        count: ::std::os::raw::c_int,
        mode: SkTileMode,
    ) -> sk_sp<SkShader> {
        SkGradientShader_MakeTwoPointConical2(
            start,
            startRadius,
            end,
            endRadius,
            colors,
            colorSpace,
            pos,
            count,
            mode,
        )
    }
    #[inline]
    pub unsafe fn MakeSweep(
        cx: SkScalar,
        cy: SkScalar,
        colors: *const SkColor,
        pos: *const SkScalar,
        count: ::std::os::raw::c_int,
        mode: SkTileMode,
        startAngle: SkScalar,
        endAngle: SkScalar,
        flags: u32,
        localMatrix: *const SkMatrix,
    ) -> sk_sp<SkShader> {
        SkGradientShader_MakeSweep(
            cx,
            cy,
            colors,
            pos,
            count,
            mode,
            startAngle,
            endAngle,
            flags,
            localMatrix,
        )
    }
    #[inline]
    pub unsafe fn MakeSweep1(
        cx: SkScalar,
        cy: SkScalar,
        colors: *const SkColor4f,
        colorSpace: sk_sp<SkColorSpace>,
        pos: *const SkScalar,
        count: ::std::os::raw::c_int,
        mode: SkTileMode,
        startAngle: SkScalar,
        endAngle: SkScalar,
        flags: u32,
        localMatrix: *const SkMatrix,
    ) -> sk_sp<SkShader> {
        SkGradientShader_MakeSweep1(
            cx,
            cy,
            colors,
            colorSpace,
            pos,
            count,
            mode,
            startAngle,
            endAngle,
            flags,
            localMatrix,
        )
    }
    #[inline]
    pub unsafe fn MakeSweep2(
        cx: SkScalar,
        cy: SkScalar,
        colors: *const SkColor4f,
        colorSpace: sk_sp<SkColorSpace>,
        pos: *const SkScalar,
        count: ::std::os::raw::c_int,
        flags: u32,
        localMatrix: *const SkMatrix,
    ) -> sk_sp<SkShader> {
        SkGradientShader_MakeSweep2(cx, cy, colors, colorSpace, pos, count, flags, localMatrix)
    }
    #[inline]
    pub unsafe fn MakeSweep3(
        cx: SkScalar,
        cy: SkScalar,
        colors: *const SkColor4f,
        colorSpace: sk_sp<SkColorSpace>,
        pos: *const SkScalar,
        count: ::std::os::raw::c_int,
    ) -> sk_sp<SkShader> {
        SkGradientShader_MakeSweep3(cx, cy, colors, colorSpace, pos, count)
    }
    #[inline]
    pub unsafe fn RegisterFlattenables() {
        SkGradientShader_RegisterFlattenables()
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkHighContrastConfig {
    pub fGrayscale: bool,
    pub fInvertStyle: SkHighContrastConfig_InvertStyle,
    pub fContrast: SkScalar,
}
impl SkHighContrastConfig_InvertStyle {
    pub const Last: SkHighContrastConfig_InvertStyle =
        SkHighContrastConfig_InvertStyle::InvertLightness;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkHighContrastConfig_InvertStyle {
    NoInvert = 0,
    InvertBrightness = 1,
    InvertLightness = 2,
}
#[test]
fn bindgen_test_layout_SkHighContrastConfig() {
    assert_eq!(
        ::core::mem::size_of::<SkHighContrastConfig>(),
        12usize,
        concat!("Size of: ", stringify!(SkHighContrastConfig))
    );
    assert_eq!(
        ::core::mem::align_of::<SkHighContrastConfig>(),
        4usize,
        concat!("Alignment of ", stringify!(SkHighContrastConfig))
    );
    fn test_field_fGrayscale() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkHighContrastConfig>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fGrayscale) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SkHighContrastConfig),
                "::",
                stringify!(fGrayscale)
            )
        );
    }
    test_field_fGrayscale();
    fn test_field_fInvertStyle() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkHighContrastConfig>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fInvertStyle) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(SkHighContrastConfig),
                "::",
                stringify!(fInvertStyle)
            )
        );
    }
    test_field_fInvertStyle();
    fn test_field_fContrast() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkHighContrastConfig>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fContrast) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(SkHighContrastConfig),
                "::",
                stringify!(fContrast)
            )
        );
    }
    test_field_fContrast();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkSpan<T> {
    pub fPtr: *mut T,
    pub fSize: usize,
    pub _phantom_0: ::core::marker::PhantomData<::core::cell::UnsafeCell<T>>,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkSL_Version {
    k100 = 0,
    k300 = 1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkSL_DebugTrace {
    _unused: [u8; 0],
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct SkRuntimeEffect {
    pub _bindgen_opaque_blob: [u64; 15usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkRuntimeEffect_Uniform {
    pub name: std_string_view,
    pub offset: usize,
    pub type_: SkRuntimeEffect_Uniform_Type,
    pub count: ::std::os::raw::c_int,
    pub flags: u32,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkRuntimeEffect_Uniform_Type {
    Float = 0,
    Float2 = 1,
    Float3 = 2,
    Float4 = 3,
    Float2x2 = 4,
    Float3x3 = 5,
    Float4x4 = 6,
    Int = 7,
    Int2 = 8,
    Int3 = 9,
    Int4 = 10,
}
pub const SkRuntimeEffect_Uniform_Flags_kArray_Flag: SkRuntimeEffect_Uniform_Flags = 1;
pub const SkRuntimeEffect_Uniform_Flags_kColor_Flag: SkRuntimeEffect_Uniform_Flags = 2;
pub const SkRuntimeEffect_Uniform_Flags_kVertex_Flag: SkRuntimeEffect_Uniform_Flags = 4;
pub const SkRuntimeEffect_Uniform_Flags_kFragment_Flag: SkRuntimeEffect_Uniform_Flags = 8;
pub const SkRuntimeEffect_Uniform_Flags_kHalfPrecision_Flag: SkRuntimeEffect_Uniform_Flags = 16;
pub type SkRuntimeEffect_Uniform_Flags = ::std::os::raw::c_uint;
#[test]
fn bindgen_test_layout_SkRuntimeEffect_Uniform() {
    assert_eq!(
        ::core::mem::size_of::<SkRuntimeEffect_Uniform>(),
        40usize,
        concat!("Size of: ", stringify!(SkRuntimeEffect_Uniform))
    );
    assert_eq!(
        ::core::mem::align_of::<SkRuntimeEffect_Uniform>(),
        8usize,
        concat!("Alignment of ", stringify!(SkRuntimeEffect_Uniform))
    );
    fn test_field_name() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkRuntimeEffect_Uniform>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SkRuntimeEffect_Uniform),
                "::",
                stringify!(name)
            )
        );
    }
    test_field_name();
    fn test_field_offset() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkRuntimeEffect_Uniform>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).offset) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(SkRuntimeEffect_Uniform),
                "::",
                stringify!(offset)
            )
        );
    }
    test_field_offset();
    fn test_field_type() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkRuntimeEffect_Uniform>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(SkRuntimeEffect_Uniform),
                "::",
                stringify!(type_)
            )
        );
    }
    test_field_type();
    fn test_field_count() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkRuntimeEffect_Uniform>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).count) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(SkRuntimeEffect_Uniform),
                "::",
                stringify!(count)
            )
        );
    }
    test_field_count();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkRuntimeEffect_Uniform>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(SkRuntimeEffect_Uniform),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
}
extern "C" {
    #[link_name = "\u{1}__ZNK15SkRuntimeEffect7Uniform11sizeInBytesEv"]
    pub fn SkRuntimeEffect_Uniform_sizeInBytes(this: *const SkRuntimeEffect_Uniform) -> usize;
}
impl SkRuntimeEffect_Uniform {
    #[inline]
    pub unsafe fn sizeInBytes(&self) -> usize {
        SkRuntimeEffect_Uniform_sizeInBytes(self)
    }
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkRuntimeEffect_ChildType {
    Shader = 0,
    ColorFilter = 1,
    Blender = 2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkRuntimeEffect_Child {
    pub name: std_string_view,
    pub type_: SkRuntimeEffect_ChildType,
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_SkRuntimeEffect_Child() {
    assert_eq!(
        ::core::mem::size_of::<SkRuntimeEffect_Child>(),
        24usize,
        concat!("Size of: ", stringify!(SkRuntimeEffect_Child))
    );
    assert_eq!(
        ::core::mem::align_of::<SkRuntimeEffect_Child>(),
        8usize,
        concat!("Alignment of ", stringify!(SkRuntimeEffect_Child))
    );
    fn test_field_name() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkRuntimeEffect_Child>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SkRuntimeEffect_Child),
                "::",
                stringify!(name)
            )
        );
    }
    test_field_name();
    fn test_field_type() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkRuntimeEffect_Child>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(SkRuntimeEffect_Child),
                "::",
                stringify!(type_)
            )
        );
    }
    test_field_type();
    fn test_field_index() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkRuntimeEffect_Child>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).index) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(SkRuntimeEffect_Child),
                "::",
                stringify!(index)
            )
        );
    }
    test_field_index();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkRuntimeEffect_Options {
    pub forceUnoptimized: bool,
    pub usePrivateRTShaderModule: bool,
    pub maxVersionAllowed: SkSL_Version,
}
#[test]
fn bindgen_test_layout_SkRuntimeEffect_Options() {
    assert_eq!(
        ::core::mem::size_of::<SkRuntimeEffect_Options>(),
        8usize,
        concat!("Size of: ", stringify!(SkRuntimeEffect_Options))
    );
    assert_eq!(
        ::core::mem::align_of::<SkRuntimeEffect_Options>(),
        4usize,
        concat!("Alignment of ", stringify!(SkRuntimeEffect_Options))
    );
    fn test_field_forceUnoptimized() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkRuntimeEffect_Options>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).forceUnoptimized) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SkRuntimeEffect_Options),
                "::",
                stringify!(forceUnoptimized)
            )
        );
    }
    test_field_forceUnoptimized();
    fn test_field_usePrivateRTShaderModule() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkRuntimeEffect_Options>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).usePrivateRTShaderModule) as usize - ptr as usize
            },
            1usize,
            concat!(
                "Offset of field: ",
                stringify!(SkRuntimeEffect_Options),
                "::",
                stringify!(usePrivateRTShaderModule)
            )
        );
    }
    test_field_usePrivateRTShaderModule();
    fn test_field_maxVersionAllowed() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkRuntimeEffect_Options>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).maxVersionAllowed) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(SkRuntimeEffect_Options),
                "::",
                stringify!(maxVersionAllowed)
            )
        );
    }
    test_field_maxVersionAllowed();
}
#[repr(C)]
#[derive(Debug)]
pub struct SkRuntimeEffect_Result {
    pub effect: sk_sp<SkRuntimeEffect>,
    pub errorText: SkString,
}
#[test]
fn bindgen_test_layout_SkRuntimeEffect_Result() {
    assert_eq!(
        ::core::mem::size_of::<SkRuntimeEffect_Result>(),
        16usize,
        concat!("Size of: ", stringify!(SkRuntimeEffect_Result))
    );
    assert_eq!(
        ::core::mem::align_of::<SkRuntimeEffect_Result>(),
        8usize,
        concat!("Alignment of ", stringify!(SkRuntimeEffect_Result))
    );
    fn test_field_effect() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkRuntimeEffect_Result>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).effect) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SkRuntimeEffect_Result),
                "::",
                stringify!(effect)
            )
        );
    }
    test_field_effect();
    fn test_field_errorText() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkRuntimeEffect_Result>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).errorText) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(SkRuntimeEffect_Result),
                "::",
                stringify!(errorText)
            )
        );
    }
    test_field_errorText();
}
#[repr(C)]
#[derive(Debug)]
pub struct SkRuntimeEffect_ChildPtr {
    pub fChild: sk_sp<SkFlattenable>,
}
#[test]
fn bindgen_test_layout_SkRuntimeEffect_ChildPtr() {
    assert_eq!(
        ::core::mem::size_of::<SkRuntimeEffect_ChildPtr>(),
        8usize,
        concat!("Size of: ", stringify!(SkRuntimeEffect_ChildPtr))
    );
    assert_eq!(
        ::core::mem::align_of::<SkRuntimeEffect_ChildPtr>(),
        8usize,
        concat!("Alignment of ", stringify!(SkRuntimeEffect_ChildPtr))
    );
    fn test_field_fChild() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkRuntimeEffect_ChildPtr>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fChild) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SkRuntimeEffect_ChildPtr),
                "::",
                stringify!(fChild)
            )
        );
    }
    test_field_fChild();
}
extern "C" {
    #[link_name = "\u{1}__ZNK15SkRuntimeEffect8ChildPtr4typeEv"]
    pub fn SkRuntimeEffect_ChildPtr_type(this: *const SkRuntimeEffect_ChildPtr) -> u8;
}
extern "C" {
    #[link_name = "\u{1}__ZNK15SkRuntimeEffect8ChildPtr6shaderEv"]
    pub fn SkRuntimeEffect_ChildPtr_shader(this: *const SkRuntimeEffect_ChildPtr) -> *mut SkShader;
}
extern "C" {
    #[link_name = "\u{1}__ZNK15SkRuntimeEffect8ChildPtr11colorFilterEv"]
    pub fn SkRuntimeEffect_ChildPtr_colorFilter(
        this: *const SkRuntimeEffect_ChildPtr,
    ) -> *mut SkColorFilter;
}
extern "C" {
    #[link_name = "\u{1}__ZNK15SkRuntimeEffect8ChildPtr7blenderEv"]
    pub fn SkRuntimeEffect_ChildPtr_blender(
        this: *const SkRuntimeEffect_ChildPtr,
    ) -> *mut SkBlender;
}
extern "C" {
    #[link_name = "\u{1}__ZN15SkRuntimeEffect8ChildPtrC1E5sk_spI13SkFlattenableE"]
    pub fn SkRuntimeEffect_ChildPtr_ChildPtr(
        this: *mut SkRuntimeEffect_ChildPtr,
        f: sk_sp<SkFlattenable>,
    );
}
impl SkRuntimeEffect_ChildPtr {
    #[inline]
    pub unsafe fn type_(&self) -> u8 {
        SkRuntimeEffect_ChildPtr_type(self)
    }
    #[inline]
    pub unsafe fn shader(&self) -> *mut SkShader {
        SkRuntimeEffect_ChildPtr_shader(self)
    }
    #[inline]
    pub unsafe fn colorFilter(&self) -> *mut SkColorFilter {
        SkRuntimeEffect_ChildPtr_colorFilter(self)
    }
    #[inline]
    pub unsafe fn blender(&self) -> *mut SkBlender {
        SkRuntimeEffect_ChildPtr_blender(self)
    }
    #[inline]
    pub unsafe fn new(f: sk_sp<SkFlattenable>) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkRuntimeEffect_ChildPtr_ChildPtr(__bindgen_tmp.as_mut_ptr(), f);
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct SkRuntimeEffect_TracedShader {
    pub shader: sk_sp<SkShader>,
    pub debugTrace: sk_sp<SkSL_DebugTrace>,
}
#[test]
fn bindgen_test_layout_SkRuntimeEffect_TracedShader() {
    assert_eq!(
        ::core::mem::size_of::<SkRuntimeEffect_TracedShader>(),
        16usize,
        concat!("Size of: ", stringify!(SkRuntimeEffect_TracedShader))
    );
    assert_eq!(
        ::core::mem::align_of::<SkRuntimeEffect_TracedShader>(),
        8usize,
        concat!("Alignment of ", stringify!(SkRuntimeEffect_TracedShader))
    );
    fn test_field_shader() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkRuntimeEffect_TracedShader>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).shader) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SkRuntimeEffect_TracedShader),
                "::",
                stringify!(shader)
            )
        );
    }
    test_field_shader();
    fn test_field_debugTrace() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkRuntimeEffect_TracedShader>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).debugTrace) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(SkRuntimeEffect_TracedShader),
                "::",
                stringify!(debugTrace)
            )
        );
    }
    test_field_debugTrace();
}
pub const SkRuntimeEffect_Flags_kUsesSampleCoords_Flag: SkRuntimeEffect_Flags = 1;
pub const SkRuntimeEffect_Flags_kAllowColorFilter_Flag: SkRuntimeEffect_Flags = 2;
pub const SkRuntimeEffect_Flags_kAllowShader_Flag: SkRuntimeEffect_Flags = 4;
pub const SkRuntimeEffect_Flags_kAllowBlender_Flag: SkRuntimeEffect_Flags = 8;
pub const SkRuntimeEffect_Flags_kSamplesOutsideMain_Flag: SkRuntimeEffect_Flags = 16;
pub const SkRuntimeEffect_Flags_kUsesColorTransform_Flag: SkRuntimeEffect_Flags = 32;
pub const SkRuntimeEffect_Flags_kAlwaysOpaque_Flag: SkRuntimeEffect_Flags = 64;
pub type SkRuntimeEffect_Flags = ::std::os::raw::c_uint;
#[test]
fn bindgen_test_layout_SkRuntimeEffect() {
    assert_eq!(
        ::core::mem::size_of::<SkRuntimeEffect>(),
        120usize,
        concat!("Size of: ", stringify!(SkRuntimeEffect))
    );
    assert_eq!(
        ::core::mem::align_of::<SkRuntimeEffect>(),
        8usize,
        concat!("Alignment of ", stringify!(SkRuntimeEffect))
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN15SkRuntimeEffect18MakeForColorFilterE8SkStringRKNS_7OptionsE"]
    pub fn SkRuntimeEffect_MakeForColorFilter(
        sksl: SkString,
        arg1: *const SkRuntimeEffect_Options,
    ) -> SkRuntimeEffect_Result;
}
extern "C" {
    #[link_name = "\u{1}__ZN15SkRuntimeEffect13MakeForShaderE8SkStringRKNS_7OptionsE"]
    pub fn SkRuntimeEffect_MakeForShader(
        sksl: SkString,
        arg1: *const SkRuntimeEffect_Options,
    ) -> SkRuntimeEffect_Result;
}
extern "C" {
    #[link_name = "\u{1}__ZN15SkRuntimeEffect14MakeForBlenderE8SkStringRKNS_7OptionsE"]
    pub fn SkRuntimeEffect_MakeForBlender(
        sksl: SkString,
        arg1: *const SkRuntimeEffect_Options,
    ) -> SkRuntimeEffect_Result;
}
extern "C" {
    #[link_name = "\u{1}__ZNK15SkRuntimeEffect10makeShaderE5sk_spIK6SkDataEPS0_I8SkShaderEmPK8SkMatrix"]
    pub fn SkRuntimeEffect_makeShader(
        this: *const SkRuntimeEffect,
        uniforms: sk_sp<SkData>,
        children: *mut sk_sp<SkShader>,
        childCount: usize,
        localMatrix: *const SkMatrix,
    ) -> sk_sp<SkShader>;
}
extern "C" {
    #[link_name = "\u{1}__ZNK15SkRuntimeEffect10makeShaderE5sk_spIK6SkDataE6SkSpanINS_8ChildPtrEEPK8SkMatrix"]
    pub fn SkRuntimeEffect_makeShader1(
        this: *const SkRuntimeEffect,
        uniforms: sk_sp<SkData>,
        children: SkSpan<SkRuntimeEffect_ChildPtr>,
        localMatrix: *const SkMatrix,
    ) -> sk_sp<SkShader>;
}
extern "C" {
    #[link_name = "\u{1}__ZNK15SkRuntimeEffect9makeImageEP18GrRecordingContext5sk_spIK6SkDataE6SkSpanINS_8ChildPtrEEPK8SkMatrix11SkImageInfob"]
    pub fn SkRuntimeEffect_makeImage(
        this: *const SkRuntimeEffect,
        arg1: *mut GrRecordingContext,
        uniforms: sk_sp<SkData>,
        children: SkSpan<SkRuntimeEffect_ChildPtr>,
        localMatrix: *const SkMatrix,
        resultInfo: SkImageInfo,
        mipmapped: bool,
    ) -> sk_sp<SkImage>;
}
extern "C" {
    #[link_name = "\u{1}__ZNK15SkRuntimeEffect15makeColorFilterE5sk_spIK6SkDataE"]
    pub fn SkRuntimeEffect_makeColorFilter(
        this: *const SkRuntimeEffect,
        uniforms: sk_sp<SkData>,
    ) -> sk_sp<SkColorFilter>;
}
extern "C" {
    #[link_name = "\u{1}__ZNK15SkRuntimeEffect15makeColorFilterE5sk_spIK6SkDataEPS0_I13SkColorFilterEm"]
    pub fn SkRuntimeEffect_makeColorFilter1(
        this: *const SkRuntimeEffect,
        uniforms: sk_sp<SkData>,
        children: *mut sk_sp<SkColorFilter>,
        childCount: usize,
    ) -> sk_sp<SkColorFilter>;
}
extern "C" {
    #[link_name = "\u{1}__ZNK15SkRuntimeEffect15makeColorFilterE5sk_spIK6SkDataE6SkSpanINS_8ChildPtrEE"]
    pub fn SkRuntimeEffect_makeColorFilter2(
        this: *const SkRuntimeEffect,
        uniforms: sk_sp<SkData>,
        children: SkSpan<SkRuntimeEffect_ChildPtr>,
    ) -> sk_sp<SkColorFilter>;
}
extern "C" {
    #[link_name = "\u{1}__ZNK15SkRuntimeEffect11makeBlenderE5sk_spIK6SkDataE6SkSpanINS_8ChildPtrEE"]
    pub fn SkRuntimeEffect_makeBlender(
        this: *const SkRuntimeEffect,
        uniforms: sk_sp<SkData>,
        children: SkSpan<SkRuntimeEffect_ChildPtr>,
    ) -> sk_sp<SkBlender>;
}
extern "C" {
    #[link_name = "\u{1}__ZN15SkRuntimeEffect10MakeTracedE5sk_spI8SkShaderERK8SkIPoint"]
    pub fn SkRuntimeEffect_MakeTraced(
        shader: sk_sp<SkShader>,
        traceCoord: *const SkIPoint,
    ) -> SkRuntimeEffect_TracedShader;
}
extern "C" {
    #[link_name = "\u{1}__ZNK15SkRuntimeEffect6sourceEv"]
    pub fn SkRuntimeEffect_source(this: *const SkRuntimeEffect) -> *const std_string;
}
extern "C" {
    #[link_name = "\u{1}__ZNK15SkRuntimeEffect11uniformSizeEv"]
    pub fn SkRuntimeEffect_uniformSize(this: *const SkRuntimeEffect) -> usize;
}
extern "C" {
    #[link_name = "\u{1}__ZNK15SkRuntimeEffect11findUniformENSt3__117basic_string_viewIcNS0_11char_traitsIcEEEE"]
    pub fn SkRuntimeEffect_findUniform(
        this: *const SkRuntimeEffect,
        name: std_string_view,
    ) -> *const SkRuntimeEffect_Uniform;
}
extern "C" {
    #[link_name = "\u{1}__ZNK15SkRuntimeEffect9findChildENSt3__117basic_string_viewIcNS0_11char_traitsIcEEEE"]
    pub fn SkRuntimeEffect_findChild(
        this: *const SkRuntimeEffect,
        name: std_string_view,
    ) -> *const SkRuntimeEffect_Child;
}
extern "C" {
    #[link_name = "\u{1}__ZN15SkRuntimeEffect20RegisterFlattenablesEv"]
    pub fn SkRuntimeEffect_RegisterFlattenables();
}
impl SkRuntimeEffect {
    #[inline]
    pub unsafe fn MakeForColorFilter(
        sksl: SkString,
        arg1: *const SkRuntimeEffect_Options,
    ) -> SkRuntimeEffect_Result {
        SkRuntimeEffect_MakeForColorFilter(sksl, arg1)
    }
    #[inline]
    pub unsafe fn MakeForShader(
        sksl: SkString,
        arg1: *const SkRuntimeEffect_Options,
    ) -> SkRuntimeEffect_Result {
        SkRuntimeEffect_MakeForShader(sksl, arg1)
    }
    #[inline]
    pub unsafe fn MakeForBlender(
        sksl: SkString,
        arg1: *const SkRuntimeEffect_Options,
    ) -> SkRuntimeEffect_Result {
        SkRuntimeEffect_MakeForBlender(sksl, arg1)
    }
    #[inline]
    pub unsafe fn makeShader(
        &self,
        uniforms: sk_sp<SkData>,
        children: *mut sk_sp<SkShader>,
        childCount: usize,
        localMatrix: *const SkMatrix,
    ) -> sk_sp<SkShader> {
        SkRuntimeEffect_makeShader(self, uniforms, children, childCount, localMatrix)
    }
    #[inline]
    pub unsafe fn makeShader1(
        &self,
        uniforms: sk_sp<SkData>,
        children: SkSpan<SkRuntimeEffect_ChildPtr>,
        localMatrix: *const SkMatrix,
    ) -> sk_sp<SkShader> {
        SkRuntimeEffect_makeShader1(self, uniforms, children, localMatrix)
    }
    #[inline]
    pub unsafe fn makeImage(
        &self,
        arg1: *mut GrRecordingContext,
        uniforms: sk_sp<SkData>,
        children: SkSpan<SkRuntimeEffect_ChildPtr>,
        localMatrix: *const SkMatrix,
        resultInfo: SkImageInfo,
        mipmapped: bool,
    ) -> sk_sp<SkImage> {
        SkRuntimeEffect_makeImage(
            self,
            arg1,
            uniforms,
            children,
            localMatrix,
            resultInfo,
            mipmapped,
        )
    }
    #[inline]
    pub unsafe fn makeColorFilter(&self, uniforms: sk_sp<SkData>) -> sk_sp<SkColorFilter> {
        SkRuntimeEffect_makeColorFilter(self, uniforms)
    }
    #[inline]
    pub unsafe fn makeColorFilter1(
        &self,
        uniforms: sk_sp<SkData>,
        children: *mut sk_sp<SkColorFilter>,
        childCount: usize,
    ) -> sk_sp<SkColorFilter> {
        SkRuntimeEffect_makeColorFilter1(self, uniforms, children, childCount)
    }
    #[inline]
    pub unsafe fn makeColorFilter2(
        &self,
        uniforms: sk_sp<SkData>,
        children: SkSpan<SkRuntimeEffect_ChildPtr>,
    ) -> sk_sp<SkColorFilter> {
        SkRuntimeEffect_makeColorFilter2(self, uniforms, children)
    }
    #[inline]
    pub unsafe fn makeBlender(
        &self,
        uniforms: sk_sp<SkData>,
        children: SkSpan<SkRuntimeEffect_ChildPtr>,
    ) -> sk_sp<SkBlender> {
        SkRuntimeEffect_makeBlender(self, uniforms, children)
    }
    #[inline]
    pub unsafe fn MakeTraced(
        shader: sk_sp<SkShader>,
        traceCoord: *const SkIPoint,
    ) -> SkRuntimeEffect_TracedShader {
        SkRuntimeEffect_MakeTraced(shader, traceCoord)
    }
    #[inline]
    pub unsafe fn source(&self) -> *const std_string {
        SkRuntimeEffect_source(self)
    }
    #[inline]
    pub unsafe fn uniformSize(&self) -> usize {
        SkRuntimeEffect_uniformSize(self)
    }
    #[inline]
    pub unsafe fn findUniform(&self, name: std_string_view) -> *const SkRuntimeEffect_Uniform {
        SkRuntimeEffect_findUniform(self, name)
    }
    #[inline]
    pub unsafe fn findChild(&self, name: std_string_view) -> *const SkRuntimeEffect_Child {
        SkRuntimeEffect_findChild(self, name)
    }
    #[inline]
    pub unsafe fn RegisterFlattenables() {
        SkRuntimeEffect_RegisterFlattenables()
    }
}
extern "C" {
    #[link_name = "\u{1}__ZN15SkRuntimeEffectD1Ev"]
    pub fn SkRuntimeEffect_SkRuntimeEffect_destructor(this: *mut SkRuntimeEffect);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkImageFilters_CropRect {
    pub fCropRect: SkRect,
}
#[test]
fn bindgen_test_layout_SkImageFilters_CropRect() {
    assert_eq!(
        ::core::mem::size_of::<SkImageFilters_CropRect>(),
        16usize,
        concat!("Size of: ", stringify!(SkImageFilters_CropRect))
    );
    assert_eq!(
        ::core::mem::align_of::<SkImageFilters_CropRect>(),
        4usize,
        concat!("Alignment of ", stringify!(SkImageFilters_CropRect))
    );
    fn test_field_fCropRect() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkImageFilters_CropRect>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fCropRect) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SkImageFilters_CropRect),
                "::",
                stringify!(fCropRect)
            )
        );
    }
    test_field_fCropRect();
}
#[repr(u8)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkImageFilters_Dither {
    No = 0,
    Yes = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkPathOp {
    Difference = 0,
    Intersect = 1,
    Union = 2,
    XOR = 3,
    ReverseDifference = 4,
}
extern "C" {
    #[link_name = "\u{1}__Z2OpRK6SkPathS1_8SkPathOpPS_"]
    pub fn Op(one: *const SkPath, two: *const SkPath, op: SkPathOp, result: *mut SkPath) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__Z8SimplifyRK6SkPathPS_"]
    pub fn Simplify(path: *const SkPath, result: *mut SkPath) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__Z11TightBoundsRK6SkPathP6SkRect"]
    pub fn TightBounds(path: *const SkPath, result: *mut SkRect) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__Z9AsWindingRK6SkPathPS_"]
    pub fn AsWinding(path: *const SkPath, result: *mut SkPath) -> bool;
}
#[repr(C)]
#[derive(Debug)]
pub struct SkOpBuilder {
    pub fPathRefs: [u64; 2usize],
    pub fOps: SkTDArray<SkPathOp>,
}
#[test]
fn bindgen_test_layout_SkOpBuilder() {
    assert_eq!(
        ::core::mem::size_of::<SkOpBuilder>(),
        32usize,
        concat!("Size of: ", stringify!(SkOpBuilder))
    );
    assert_eq!(
        ::core::mem::align_of::<SkOpBuilder>(),
        8usize,
        concat!("Alignment of ", stringify!(SkOpBuilder))
    );
    fn test_field_fPathRefs() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkOpBuilder>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fPathRefs) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SkOpBuilder),
                "::",
                stringify!(fPathRefs)
            )
        );
    }
    test_field_fPathRefs();
    fn test_field_fOps() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkOpBuilder>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fOps) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(SkOpBuilder),
                "::",
                stringify!(fOps)
            )
        );
    }
    test_field_fOps();
}
extern "C" {
    #[link_name = "\u{1}__ZN11SkOpBuilder3addERK6SkPath8SkPathOp"]
    pub fn SkOpBuilder_add(this: *mut SkOpBuilder, path: *const SkPath, _operator: SkPathOp);
}
extern "C" {
    #[link_name = "\u{1}__ZN11SkOpBuilder7resolveEP6SkPath"]
    pub fn SkOpBuilder_resolve(this: *mut SkOpBuilder, result: *mut SkPath) -> bool;
}
impl SkOpBuilder {
    #[inline]
    pub unsafe fn add(&mut self, path: *const SkPath, _operator: SkPathOp) {
        SkOpBuilder_add(self, path, _operator)
    }
    #[inline]
    pub unsafe fn resolve(&mut self, result: *mut SkPath) -> bool {
        SkOpBuilder_resolve(self, result)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkTableMaskFilter {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_SkTableMaskFilter() {
    assert_eq!(
        ::core::mem::size_of::<SkTableMaskFilter>(),
        1usize,
        concat!("Size of: ", stringify!(SkTableMaskFilter))
    );
    assert_eq!(
        ::core::mem::align_of::<SkTableMaskFilter>(),
        1usize,
        concat!("Alignment of ", stringify!(SkTableMaskFilter))
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN17SkTableMaskFilter14MakeGammaTableEPhf"]
    pub fn SkTableMaskFilter_MakeGammaTable(table: *mut u8, gamma: SkScalar);
}
extern "C" {
    #[link_name = "\u{1}__ZN17SkTableMaskFilter13MakeClipTableEPhhh"]
    pub fn SkTableMaskFilter_MakeClipTable(table: *mut u8, min: u8, max: u8);
}
extern "C" {
    #[link_name = "\u{1}__ZN17SkTableMaskFilter6CreateEPKh"]
    pub fn SkTableMaskFilter_Create(table: *const u8) -> *mut SkMaskFilter;
}
extern "C" {
    #[link_name = "\u{1}__ZN17SkTableMaskFilter11CreateGammaEf"]
    pub fn SkTableMaskFilter_CreateGamma(gamma: SkScalar) -> *mut SkMaskFilter;
}
extern "C" {
    #[link_name = "\u{1}__ZN17SkTableMaskFilter10CreateClipEhh"]
    pub fn SkTableMaskFilter_CreateClip(min: u8, max: u8) -> *mut SkMaskFilter;
}
impl SkTableMaskFilter {
    #[inline]
    pub unsafe fn MakeGammaTable(table: *mut u8, gamma: SkScalar) {
        SkTableMaskFilter_MakeGammaTable(table, gamma)
    }
    #[inline]
    pub unsafe fn MakeClipTable(table: *mut u8, min: u8, max: u8) {
        SkTableMaskFilter_MakeClipTable(table, min, max)
    }
    #[inline]
    pub unsafe fn Create(table: *const u8) -> *mut SkMaskFilter {
        SkTableMaskFilter_Create(table)
    }
    #[inline]
    pub unsafe fn CreateGamma(gamma: SkScalar) -> *mut SkMaskFilter {
        SkTableMaskFilter_CreateGamma(gamma)
    }
    #[inline]
    pub unsafe fn CreateClip(min: u8, max: u8) -> *mut SkMaskFilter {
        SkTableMaskFilter_CreateClip(min, max)
    }
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkTrimPathEffect_Mode {
    Normal = 0,
    Inverted = 1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkSVGCanvas {
    pub _address: u8,
}
pub const SkSVGCanvas_kConvertTextToPaths_Flag: SkSVGCanvas__bindgen_ty_1 =
    SkSVGCanvas__bindgen_ty_1::kConvertTextToPaths_Flag;
pub const SkSVGCanvas_kNoPrettyXML_Flag: SkSVGCanvas__bindgen_ty_1 =
    SkSVGCanvas__bindgen_ty_1::kNoPrettyXML_Flag;
pub const SkSVGCanvas_kRelativePathEncoding_Flag: SkSVGCanvas__bindgen_ty_1 =
    SkSVGCanvas__bindgen_ty_1::kRelativePathEncoding_Flag;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkSVGCanvas__bindgen_ty_1 {
    kConvertTextToPaths_Flag = 1,
    kNoPrettyXML_Flag = 2,
    kRelativePathEncoding_Flag = 4,
}
#[test]
fn bindgen_test_layout_SkSVGCanvas() {
    assert_eq!(
        ::core::mem::size_of::<SkSVGCanvas>(),
        1usize,
        concat!("Size of: ", stringify!(SkSVGCanvas))
    );
    assert_eq!(
        ::core::mem::align_of::<SkSVGCanvas>(),
        1usize,
        concat!("Alignment of ", stringify!(SkSVGCanvas))
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN11SkSVGCanvas4MakeERK6SkRectP9SkWStreamj"]
    pub fn SkSVGCanvas_Make(bounds: *const SkRect, arg1: *mut SkWStream, flags: u32) -> u64;
}
impl SkSVGCanvas {
    #[inline]
    pub unsafe fn Make(bounds: *const SkRect, arg1: *mut SkWStream, flags: u32) -> u64 {
        SkSVGCanvas_Make(bounds, arg1, flags)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkPatch3D {
    pub fU: SkV3,
    pub fV: SkV3,
    pub fOrigin: SkV3,
}
#[test]
fn bindgen_test_layout_SkPatch3D() {
    assert_eq!(
        ::core::mem::size_of::<SkPatch3D>(),
        36usize,
        concat!("Size of: ", stringify!(SkPatch3D))
    );
    assert_eq!(
        ::core::mem::align_of::<SkPatch3D>(),
        4usize,
        concat!("Alignment of ", stringify!(SkPatch3D))
    );
    fn test_field_fU() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkPatch3D>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fU) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SkPatch3D),
                "::",
                stringify!(fU)
            )
        );
    }
    test_field_fU();
    fn test_field_fV() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkPatch3D>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fV) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(SkPatch3D),
                "::",
                stringify!(fV)
            )
        );
    }
    test_field_fV();
    fn test_field_fOrigin() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkPatch3D>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fOrigin) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(SkPatch3D),
                "::",
                stringify!(fOrigin)
            )
        );
    }
    test_field_fOrigin();
}
extern "C" {
    #[link_name = "\u{1}__ZN9SkPatch3D5resetEv"]
    pub fn SkPatch3D_reset(this: *mut SkPatch3D);
}
extern "C" {
    #[link_name = "\u{1}__ZNK9SkPatch3D9transformERK5SkM44PS_"]
    pub fn SkPatch3D_transform(this: *const SkPatch3D, arg1: *const SkM44, dst: *mut SkPatch3D);
}
extern "C" {
    #[link_name = "\u{1}__ZNK9SkPatch3D7dotWithEfff"]
    pub fn SkPatch3D_dotWith(
        this: *const SkPatch3D,
        dx: SkScalar,
        dy: SkScalar,
        dz: SkScalar,
    ) -> SkScalar;
}
extern "C" {
    #[link_name = "\u{1}__ZN9SkPatch3DC1Ev"]
    pub fn SkPatch3D_SkPatch3D(this: *mut SkPatch3D);
}
impl SkPatch3D {
    #[inline]
    pub unsafe fn reset(&mut self) {
        SkPatch3D_reset(self)
    }
    #[inline]
    pub unsafe fn transform(&self, arg1: *const SkM44, dst: *mut SkPatch3D) {
        SkPatch3D_transform(self, arg1, dst)
    }
    #[inline]
    pub unsafe fn dotWith(&self, dx: SkScalar, dy: SkScalar, dz: SkScalar) -> SkScalar {
        SkPatch3D_dotWith(self, dx, dy, dz)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkPatch3D_SkPatch3D(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkCamera3D {
    pub fLocation: SkV3,
    pub fAxis: SkV3,
    pub fZenith: SkV3,
    pub fObserver: SkV3,
    pub fOrientation: SkMatrix,
    pub fNeedToUpdate: bool,
}
#[test]
fn bindgen_test_layout_SkCamera3D() {
    assert_eq!(
        ::core::mem::size_of::<SkCamera3D>(),
        92usize,
        concat!("Size of: ", stringify!(SkCamera3D))
    );
    assert_eq!(
        ::core::mem::align_of::<SkCamera3D>(),
        4usize,
        concat!("Alignment of ", stringify!(SkCamera3D))
    );
    fn test_field_fLocation() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkCamera3D>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fLocation) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SkCamera3D),
                "::",
                stringify!(fLocation)
            )
        );
    }
    test_field_fLocation();
    fn test_field_fAxis() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkCamera3D>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fAxis) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(SkCamera3D),
                "::",
                stringify!(fAxis)
            )
        );
    }
    test_field_fAxis();
    fn test_field_fZenith() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkCamera3D>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fZenith) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(SkCamera3D),
                "::",
                stringify!(fZenith)
            )
        );
    }
    test_field_fZenith();
    fn test_field_fObserver() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkCamera3D>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fObserver) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(SkCamera3D),
                "::",
                stringify!(fObserver)
            )
        );
    }
    test_field_fObserver();
    fn test_field_fOrientation() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkCamera3D>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fOrientation) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(SkCamera3D),
                "::",
                stringify!(fOrientation)
            )
        );
    }
    test_field_fOrientation();
    fn test_field_fNeedToUpdate() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkCamera3D>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fNeedToUpdate) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(SkCamera3D),
                "::",
                stringify!(fNeedToUpdate)
            )
        );
    }
    test_field_fNeedToUpdate();
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkCamera3D5resetEv"]
    pub fn SkCamera3D_reset(this: *mut SkCamera3D);
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkCamera3D6updateEv"]
    pub fn SkCamera3D_update(this: *mut SkCamera3D);
}
extern "C" {
    #[link_name = "\u{1}__ZNK10SkCamera3D13patchToMatrixERK9SkPatch3DP8SkMatrix"]
    pub fn SkCamera3D_patchToMatrix(
        this: *const SkCamera3D,
        arg1: *const SkPatch3D,
        matrix: *mut SkMatrix,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN10SkCamera3DC1Ev"]
    pub fn SkCamera3D_SkCamera3D(this: *mut SkCamera3D);
}
impl SkCamera3D {
    #[inline]
    pub unsafe fn reset(&mut self) {
        SkCamera3D_reset(self)
    }
    #[inline]
    pub unsafe fn update(&mut self) {
        SkCamera3D_update(self)
    }
    #[inline]
    pub unsafe fn patchToMatrix(&self, arg1: *const SkPatch3D, matrix: *mut SkMatrix) {
        SkCamera3D_patchToMatrix(self, arg1, matrix)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkCamera3D_SkCamera3D(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct Sk3DView {
    pub fRec: *mut Sk3DView_Rec,
    pub fInitialRec: Sk3DView_Rec,
    pub fCamera: SkCamera3D,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Sk3DView_Rec {
    pub fNext: *mut Sk3DView_Rec,
    pub fMatrix: SkM44,
}
#[test]
fn bindgen_test_layout_Sk3DView_Rec() {
    assert_eq!(
        ::core::mem::size_of::<Sk3DView_Rec>(),
        72usize,
        concat!("Size of: ", stringify!(Sk3DView_Rec))
    );
    assert_eq!(
        ::core::mem::align_of::<Sk3DView_Rec>(),
        8usize,
        concat!("Alignment of ", stringify!(Sk3DView_Rec))
    );
    fn test_field_fNext() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<Sk3DView_Rec>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fNext) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(Sk3DView_Rec),
                "::",
                stringify!(fNext)
            )
        );
    }
    test_field_fNext();
    fn test_field_fMatrix() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<Sk3DView_Rec>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fMatrix) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(Sk3DView_Rec),
                "::",
                stringify!(fMatrix)
            )
        );
    }
    test_field_fMatrix();
}
#[test]
fn bindgen_test_layout_Sk3DView() {
    assert_eq!(
        ::core::mem::size_of::<Sk3DView>(),
        176usize,
        concat!("Size of: ", stringify!(Sk3DView))
    );
    assert_eq!(
        ::core::mem::align_of::<Sk3DView>(),
        8usize,
        concat!("Alignment of ", stringify!(Sk3DView))
    );
    fn test_field_fRec() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<Sk3DView>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fRec) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(Sk3DView),
                "::",
                stringify!(fRec)
            )
        );
    }
    test_field_fRec();
    fn test_field_fInitialRec() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<Sk3DView>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fInitialRec) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(Sk3DView),
                "::",
                stringify!(fInitialRec)
            )
        );
    }
    test_field_fInitialRec();
    fn test_field_fCamera() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<Sk3DView>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fCamera) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(Sk3DView),
                "::",
                stringify!(fCamera)
            )
        );
    }
    test_field_fCamera();
}
extern "C" {
    #[link_name = "\u{1}__ZN8Sk3DView4saveEv"]
    pub fn Sk3DView_save(this: *mut Sk3DView);
}
extern "C" {
    #[link_name = "\u{1}__ZN8Sk3DView7restoreEv"]
    pub fn Sk3DView_restore(this: *mut Sk3DView);
}
extern "C" {
    #[link_name = "\u{1}__ZN8Sk3DView9translateEfff"]
    pub fn Sk3DView_translate(this: *mut Sk3DView, x: SkScalar, y: SkScalar, z: SkScalar);
}
extern "C" {
    #[link_name = "\u{1}__ZN8Sk3DView7rotateXEf"]
    pub fn Sk3DView_rotateX(this: *mut Sk3DView, deg: SkScalar);
}
extern "C" {
    #[link_name = "\u{1}__ZN8Sk3DView7rotateYEf"]
    pub fn Sk3DView_rotateY(this: *mut Sk3DView, deg: SkScalar);
}
extern "C" {
    #[link_name = "\u{1}__ZN8Sk3DView7rotateZEf"]
    pub fn Sk3DView_rotateZ(this: *mut Sk3DView, deg: SkScalar);
}
extern "C" {
    #[link_name = "\u{1}__ZNK8Sk3DView9getMatrixEP8SkMatrix"]
    pub fn Sk3DView_getMatrix(this: *const Sk3DView, arg1: *mut SkMatrix);
}
extern "C" {
    #[link_name = "\u{1}__ZNK8Sk3DView13applyToCanvasEP8SkCanvas"]
    pub fn Sk3DView_applyToCanvas(this: *const Sk3DView, arg1: *mut SkCanvas);
}
extern "C" {
    #[link_name = "\u{1}__ZNK8Sk3DView13dotWithNormalEfff"]
    pub fn Sk3DView_dotWithNormal(
        this: *const Sk3DView,
        dx: SkScalar,
        dy: SkScalar,
        dz: SkScalar,
    ) -> SkScalar;
}
extern "C" {
    #[link_name = "\u{1}__ZN8Sk3DViewC1Ev"]
    pub fn Sk3DView_Sk3DView(this: *mut Sk3DView);
}
extern "C" {
    #[link_name = "\u{1}__ZN8Sk3DViewD1Ev"]
    pub fn Sk3DView_Sk3DView_destructor(this: *mut Sk3DView);
}
impl Sk3DView {
    #[inline]
    pub unsafe fn save(&mut self) {
        Sk3DView_save(self)
    }
    #[inline]
    pub unsafe fn restore(&mut self) {
        Sk3DView_restore(self)
    }
    #[inline]
    pub unsafe fn translate(&mut self, x: SkScalar, y: SkScalar, z: SkScalar) {
        Sk3DView_translate(self, x, y, z)
    }
    #[inline]
    pub unsafe fn rotateX(&mut self, deg: SkScalar) {
        Sk3DView_rotateX(self, deg)
    }
    #[inline]
    pub unsafe fn rotateY(&mut self, deg: SkScalar) {
        Sk3DView_rotateY(self, deg)
    }
    #[inline]
    pub unsafe fn rotateZ(&mut self, deg: SkScalar) {
        Sk3DView_rotateZ(self, deg)
    }
    #[inline]
    pub unsafe fn getMatrix(&self, arg1: *mut SkMatrix) {
        Sk3DView_getMatrix(self, arg1)
    }
    #[inline]
    pub unsafe fn applyToCanvas(&self, arg1: *mut SkCanvas) {
        Sk3DView_applyToCanvas(self, arg1)
    }
    #[inline]
    pub unsafe fn dotWithNormal(&self, dx: SkScalar, dy: SkScalar, dz: SkScalar) -> SkScalar {
        Sk3DView_dotWithNormal(self, dx, dy, dz)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        Sk3DView_Sk3DView(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        Sk3DView_Sk3DView_destructor(self)
    }
}
#[repr(C)]
pub struct SkCustomTypefaceBuilder {
    pub fGlyphRecs: [u64; 3usize],
    pub fMetrics: SkFontMetrics,
    pub fStyle: SkFontStyle,
}
#[repr(C)]
#[derive(Debug)]
pub struct SkCustomTypefaceBuilder_GlyphRec {
    pub fPath: SkPath,
    pub fDrawable: sk_sp<SkDrawable>,
    pub fBounds: SkRect,
    pub fAdvance: f32,
}
#[test]
fn bindgen_test_layout_SkCustomTypefaceBuilder_GlyphRec() {
    assert_eq!(
        ::core::mem::size_of::<SkCustomTypefaceBuilder_GlyphRec>(),
        48usize,
        concat!("Size of: ", stringify!(SkCustomTypefaceBuilder_GlyphRec))
    );
    assert_eq!(
        ::core::mem::align_of::<SkCustomTypefaceBuilder_GlyphRec>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(SkCustomTypefaceBuilder_GlyphRec)
        )
    );
    fn test_field_fPath() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkCustomTypefaceBuilder_GlyphRec>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fPath) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SkCustomTypefaceBuilder_GlyphRec),
                "::",
                stringify!(fPath)
            )
        );
    }
    test_field_fPath();
    fn test_field_fDrawable() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkCustomTypefaceBuilder_GlyphRec>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fDrawable) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(SkCustomTypefaceBuilder_GlyphRec),
                "::",
                stringify!(fDrawable)
            )
        );
    }
    test_field_fDrawable();
    fn test_field_fBounds() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkCustomTypefaceBuilder_GlyphRec>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fBounds) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(SkCustomTypefaceBuilder_GlyphRec),
                "::",
                stringify!(fBounds)
            )
        );
    }
    test_field_fBounds();
    fn test_field_fAdvance() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkCustomTypefaceBuilder_GlyphRec>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fAdvance) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(SkCustomTypefaceBuilder_GlyphRec),
                "::",
                stringify!(fAdvance)
            )
        );
    }
    test_field_fAdvance();
}
#[test]
fn bindgen_test_layout_SkCustomTypefaceBuilder() {
    assert_eq!(
        ::core::mem::size_of::<SkCustomTypefaceBuilder>(),
        96usize,
        concat!("Size of: ", stringify!(SkCustomTypefaceBuilder))
    );
    assert_eq!(
        ::core::mem::align_of::<SkCustomTypefaceBuilder>(),
        8usize,
        concat!("Alignment of ", stringify!(SkCustomTypefaceBuilder))
    );
    fn test_field_fGlyphRecs() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkCustomTypefaceBuilder>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fGlyphRecs) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SkCustomTypefaceBuilder),
                "::",
                stringify!(fGlyphRecs)
            )
        );
    }
    test_field_fGlyphRecs();
    fn test_field_fMetrics() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkCustomTypefaceBuilder>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fMetrics) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(SkCustomTypefaceBuilder),
                "::",
                stringify!(fMetrics)
            )
        );
    }
    test_field_fMetrics();
    fn test_field_fStyle() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkCustomTypefaceBuilder>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fStyle) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(SkCustomTypefaceBuilder),
                "::",
                stringify!(fStyle)
            )
        );
    }
    test_field_fStyle();
}
extern "C" {
    #[link_name = "\u{1}__ZN23SkCustomTypefaceBuilder8setGlyphEtfRK6SkPath"]
    pub fn SkCustomTypefaceBuilder_setGlyph(
        this: *mut SkCustomTypefaceBuilder,
        arg1: SkGlyphID,
        advance: f32,
        arg2: *const SkPath,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN23SkCustomTypefaceBuilder10setMetricsERK13SkFontMetricsf"]
    pub fn SkCustomTypefaceBuilder_setMetrics(
        this: *mut SkCustomTypefaceBuilder,
        fm: *const SkFontMetrics,
        scale: f32,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN23SkCustomTypefaceBuilder12setFontStyleE11SkFontStyle"]
    pub fn SkCustomTypefaceBuilder_setFontStyle(
        this: *mut SkCustomTypefaceBuilder,
        arg1: SkFontStyle,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN23SkCustomTypefaceBuilder6detachEv"]
    pub fn SkCustomTypefaceBuilder_detach(this: *mut SkCustomTypefaceBuilder) -> sk_sp<SkTypeface>;
}
extern "C" {
    #[link_name = "\u{1}__ZN23SkCustomTypefaceBuilderC1Ev"]
    pub fn SkCustomTypefaceBuilder_SkCustomTypefaceBuilder(this: *mut SkCustomTypefaceBuilder);
}
impl SkCustomTypefaceBuilder {
    #[inline]
    pub unsafe fn setGlyph(&mut self, arg1: SkGlyphID, advance: f32, arg2: *const SkPath) {
        SkCustomTypefaceBuilder_setGlyph(self, arg1, advance, arg2)
    }
    #[inline]
    pub unsafe fn setMetrics(&mut self, fm: *const SkFontMetrics, scale: f32) {
        SkCustomTypefaceBuilder_setMetrics(self, fm, scale)
    }
    #[inline]
    pub unsafe fn setFontStyle(&mut self, arg1: SkFontStyle) {
        SkCustomTypefaceBuilder_setFontStyle(self, arg1)
    }
    #[inline]
    pub unsafe fn detach(&mut self) -> sk_sp<SkTypeface> {
        SkCustomTypefaceBuilder_detach(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkCustomTypefaceBuilder_SkCustomTypefaceBuilder(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
pub struct SkOrderedFontMgr {
    pub _base: SkFontMgr,
    pub fList: [u64; 3usize],
}
#[test]
fn bindgen_test_layout_SkOrderedFontMgr() {
    assert_eq!(
        ::core::mem::size_of::<SkOrderedFontMgr>(),
        40usize,
        concat!("Size of: ", stringify!(SkOrderedFontMgr))
    );
    assert_eq!(
        ::core::mem::align_of::<SkOrderedFontMgr>(),
        8usize,
        concat!("Alignment of ", stringify!(SkOrderedFontMgr))
    );
    fn test_field_fList() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SkOrderedFontMgr>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fList) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(SkOrderedFontMgr),
                "::",
                stringify!(fList)
            )
        );
    }
    test_field_fList();
}
extern "C" {
    #[link_name = "\u{1}__ZN16SkOrderedFontMgr6appendE5sk_spI9SkFontMgrE"]
    pub fn SkOrderedFontMgr_append(this: *mut SkOrderedFontMgr, arg1: sk_sp<SkFontMgr>);
}
extern "C" {
    #[link_name = "\u{1}__ZN16SkOrderedFontMgrC1Ev"]
    pub fn SkOrderedFontMgr_SkOrderedFontMgr(this: *mut SkOrderedFontMgr);
}
impl SkOrderedFontMgr {
    #[inline]
    pub unsafe fn append(&mut self, arg1: sk_sp<SkFontMgr>) {
        SkOrderedFontMgr_append(self, arg1)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        SkOrderedFontMgr_SkOrderedFontMgr(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}__ZN16SkOrderedFontMgrD1Ev"]
    pub fn SkOrderedFontMgr_SkOrderedFontMgr_destructor(this: *mut SkOrderedFontMgr);
}
extern "C" {
    #[link_name = "\u{1}__ZNK16SkOrderedFontMgr15onCountFamiliesEv"]
    pub fn SkOrderedFontMgr_onCountFamilies(
        this: *mut ::core::ffi::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__ZNK16SkOrderedFontMgr15onGetFamilyNameEiP8SkString"]
    pub fn SkOrderedFontMgr_onGetFamilyName(
        this: *mut ::core::ffi::c_void,
        index: ::std::os::raw::c_int,
        familyName: *mut SkString,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNK16SkOrderedFontMgr16onCreateStyleSetEi"]
    pub fn SkOrderedFontMgr_onCreateStyleSet(
        this: *mut ::core::ffi::c_void,
        index: ::std::os::raw::c_int,
    ) -> *mut SkFontStyleSet;
}
extern "C" {
    #[link_name = "\u{1}__ZNK16SkOrderedFontMgr13onMatchFamilyEPKc"]
    pub fn SkOrderedFontMgr_onMatchFamily(
        this: *mut ::core::ffi::c_void,
        familyName: *const ::std::os::raw::c_char,
    ) -> *mut SkFontStyleSet;
}
extern "C" {
    #[link_name = "\u{1}__ZNK16SkOrderedFontMgr18onMatchFamilyStyleEPKcRK11SkFontStyle"]
    pub fn SkOrderedFontMgr_onMatchFamilyStyle(
        this: *mut ::core::ffi::c_void,
        familyName: *const ::std::os::raw::c_char,
        arg1: *const SkFontStyle,
    ) -> *mut SkTypeface;
}
extern "C" {
    #[link_name = "\u{1}__ZNK16SkOrderedFontMgr27onMatchFamilyStyleCharacterEPKcRK11SkFontStylePS1_ii"]
    pub fn SkOrderedFontMgr_onMatchFamilyStyleCharacter(
        this: *mut ::core::ffi::c_void,
        familyName: *const ::std::os::raw::c_char,
        arg1: *const SkFontStyle,
        bcp47: *mut *const ::std::os::raw::c_char,
        bcp47Count: ::std::os::raw::c_int,
        character: SkUnichar,
    ) -> *mut SkTypeface;
}
extern "C" {
    #[link_name = "\u{1}__ZNK16SkOrderedFontMgr14onMakeFromDataE5sk_spI6SkDataEi"]
    pub fn SkOrderedFontMgr_onMakeFromData(
        this: *mut ::core::ffi::c_void,
        arg1: sk_sp<SkData>,
        ttcIndex: ::std::os::raw::c_int,
    ) -> sk_sp<SkTypeface>;
}
extern "C" {
    #[link_name = "\u{1}__ZNK16SkOrderedFontMgr21onMakeFromStreamIndexENSt3__110unique_ptrI13SkStreamAssetNS0_14default_deleteIS2_EEEEi"]
    pub fn SkOrderedFontMgr_onMakeFromStreamIndex(
        this: *mut ::core::ffi::c_void,
        arg1: u64,
        ttcIndex: ::std::os::raw::c_int,
    ) -> sk_sp<SkTypeface>;
}
extern "C" {
    #[link_name = "\u{1}__ZNK16SkOrderedFontMgr20onMakeFromStreamArgsENSt3__110unique_ptrI13SkStreamAssetNS0_14default_deleteIS2_EEEERK15SkFontArguments"]
    pub fn SkOrderedFontMgr_onMakeFromStreamArgs(
        this: *mut ::core::ffi::c_void,
        arg1: u64,
        arg2: *const SkFontArguments,
    ) -> sk_sp<SkTypeface>;
}
extern "C" {
    #[link_name = "\u{1}__ZNK16SkOrderedFontMgr14onMakeFromFileEPKci"]
    pub fn SkOrderedFontMgr_onMakeFromFile(
        this: *mut ::core::ffi::c_void,
        path: *const ::std::os::raw::c_char,
        ttcIndex: ::std::os::raw::c_int,
    ) -> sk_sp<SkTypeface>;
}
extern "C" {
    #[link_name = "\u{1}__ZNK16SkOrderedFontMgr20onLegacyMakeTypefaceEPKc11SkFontStyle"]
    pub fn SkOrderedFontMgr_onLegacyMakeTypeface(
        this: *mut ::core::ffi::c_void,
        familyName: *const ::std::os::raw::c_char,
        arg1: SkFontStyle,
    ) -> sk_sp<SkTypeface>;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkParsePath {
    pub _address: u8,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkParsePath_PathEncoding {
    Absolute = 0,
    Relative = 1,
}
#[test]
fn bindgen_test_layout_SkParsePath() {
    assert_eq!(
        ::core::mem::size_of::<SkParsePath>(),
        1usize,
        concat!("Size of: ", stringify!(SkParsePath))
    );
    assert_eq!(
        ::core::mem::align_of::<SkParsePath>(),
        1usize,
        concat!("Alignment of ", stringify!(SkParsePath))
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN11SkParsePath13FromSVGStringEPKcP6SkPath"]
    pub fn SkParsePath_FromSVGString(
        str_: *const ::std::os::raw::c_char,
        arg1: *mut SkPath,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN11SkParsePath11ToSVGStringERK6SkPathP8SkStringNS_12PathEncodingE"]
    pub fn SkParsePath_ToSVGString(
        arg1: *const SkPath,
        arg2: *mut SkString,
        arg3: SkParsePath_PathEncoding,
    );
}
impl SkParsePath {
    #[inline]
    pub unsafe fn FromSVGString(str_: *const ::std::os::raw::c_char, arg1: *mut SkPath) -> bool {
        SkParsePath_FromSVGString(str_, arg1)
    }
    #[inline]
    pub unsafe fn ToSVGString(
        arg1: *const SkPath,
        arg2: *mut SkString,
        arg3: SkParsePath_PathEncoding,
    ) {
        SkParsePath_ToSVGString(arg1, arg2, arg3)
    }
}
pub const SkShadowFlags_kNone_ShadowFlag: SkShadowFlags = 0;
pub const SkShadowFlags_kTransparentOccluder_ShadowFlag: SkShadowFlags = 1;
pub const SkShadowFlags_kGeometricOnly_ShadowFlag: SkShadowFlags = 2;
pub const SkShadowFlags_kDirectionalLight_ShadowFlag: SkShadowFlags = 4;
pub const SkShadowFlags_kConcaveBlurOnly_ShadowFlag: SkShadowFlags = 8;
pub const SkShadowFlags_kAll_ShadowFlag: SkShadowFlags = 15;
pub type SkShadowFlags = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkShadowUtils {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_SkShadowUtils() {
    assert_eq!(
        ::core::mem::size_of::<SkShadowUtils>(),
        1usize,
        concat!("Size of: ", stringify!(SkShadowUtils))
    );
    assert_eq!(
        ::core::mem::align_of::<SkShadowUtils>(),
        1usize,
        concat!("Alignment of ", stringify!(SkShadowUtils))
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN13SkShadowUtils10DrawShadowEP8SkCanvasRK6SkPathRK8SkPoint3S7_fjjj"]
    pub fn SkShadowUtils_DrawShadow(
        canvas: *mut SkCanvas,
        path: *const SkPath,
        zPlaneParams: *const SkPoint3,
        lightPos: *const SkPoint3,
        lightRadius: SkScalar,
        ambientColor: SkColor,
        spotColor: SkColor,
        flags: u32,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN13SkShadowUtils14GetLocalBoundsERK8SkMatrixRK6SkPathRK8SkPoint3S8_fjP6SkRect"]
    pub fn SkShadowUtils_GetLocalBounds(
        ctm: *const SkMatrix,
        path: *const SkPath,
        zPlaneParams: *const SkPoint3,
        lightPos: *const SkPoint3,
        lightRadius: SkScalar,
        flags: u32,
        bounds: *mut SkRect,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN13SkShadowUtils18ComputeTonalColorsEjjPjS0_"]
    pub fn SkShadowUtils_ComputeTonalColors(
        inAmbientColor: SkColor,
        inSpotColor: SkColor,
        outAmbientColor: *mut SkColor,
        outSpotColor: *mut SkColor,
    );
}
impl SkShadowUtils {
    #[inline]
    pub unsafe fn DrawShadow(
        canvas: *mut SkCanvas,
        path: *const SkPath,
        zPlaneParams: *const SkPoint3,
        lightPos: *const SkPoint3,
        lightRadius: SkScalar,
        ambientColor: SkColor,
        spotColor: SkColor,
        flags: u32,
    ) {
        SkShadowUtils_DrawShadow(
            canvas,
            path,
            zPlaneParams,
            lightPos,
            lightRadius,
            ambientColor,
            spotColor,
            flags,
        )
    }
    #[inline]
    pub unsafe fn GetLocalBounds(
        ctm: *const SkMatrix,
        path: *const SkPath,
        zPlaneParams: *const SkPoint3,
        lightPos: *const SkPoint3,
        lightRadius: SkScalar,
        flags: u32,
        bounds: *mut SkRect,
    ) -> bool {
        SkShadowUtils_GetLocalBounds(
            ctm,
            path,
            zPlaneParams,
            lightPos,
            lightRadius,
            flags,
            bounds,
        )
    }
    #[inline]
    pub unsafe fn ComputeTonalColors(
        inAmbientColor: SkColor,
        inSpotColor: SkColor,
        outAmbientColor: *mut SkColor,
        outSpotColor: *mut SkColor,
    ) {
        SkShadowUtils_ComputeTonalColors(inAmbientColor, inSpotColor, outAmbientColor, outSpotColor)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkTextUtils {
    pub _address: u8,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SkTextUtils_Align {
    Left = 0,
    Center = 1,
    Right = 2,
}
#[test]
fn bindgen_test_layout_SkTextUtils() {
    assert_eq!(
        ::core::mem::size_of::<SkTextUtils>(),
        1usize,
        concat!("Size of: ", stringify!(SkTextUtils))
    );
    assert_eq!(
        ::core::mem::align_of::<SkTextUtils>(),
        1usize,
        concat!("Alignment of ", stringify!(SkTextUtils))
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN11SkTextUtils4DrawEP8SkCanvasPKvm14SkTextEncodingffRK6SkFontRK7SkPaintNS_5AlignE"]
    pub fn SkTextUtils_Draw(
        arg1: *mut SkCanvas,
        text: *const ::core::ffi::c_void,
        size: usize,
        arg2: SkTextEncoding,
        x: SkScalar,
        y: SkScalar,
        arg3: *const SkFont,
        arg4: *const SkPaint,
        arg5: SkTextUtils_Align,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN11SkTextUtils7GetPathEPKvm14SkTextEncodingffRK6SkFontP6SkPath"]
    pub fn SkTextUtils_GetPath(
        text: *const ::core::ffi::c_void,
        length: usize,
        arg1: SkTextEncoding,
        x: SkScalar,
        y: SkScalar,
        arg2: *const SkFont,
        arg3: *mut SkPath,
    );
}
impl SkTextUtils {
    #[inline]
    pub unsafe fn Draw(
        arg1: *mut SkCanvas,
        text: *const ::core::ffi::c_void,
        size: usize,
        arg2: SkTextEncoding,
        x: SkScalar,
        y: SkScalar,
        arg3: *const SkFont,
        arg4: *const SkPaint,
        arg5: SkTextUtils_Align,
    ) {
        SkTextUtils_Draw(arg1, text, size, arg2, x, y, arg3, arg4, arg5)
    }
    #[inline]
    pub unsafe fn GetPath(
        text: *const ::core::ffi::c_void,
        length: usize,
        arg1: SkTextEncoding,
        x: SkScalar,
        y: SkScalar,
        arg2: *const SkFont,
        arg3: *mut SkPath,
    ) {
        SkTextUtils_GetPath(text, length, arg1, x, y, arg2, arg3)
    }
}
extern "C" {
    pub fn C_SkCodec_MakeFromData(data: *mut SkData) -> *mut SkCodec;
}
extern "C" {
    pub fn C_SkCodec_getInfo(self_: *const SkCodec, info: *mut SkImageInfo);
}
extern "C" {
    pub fn C_SkCodec_dimensions(self_: *const SkCodec) -> SkISize;
}
extern "C" {
    pub fn C_SkCodec_bounds(self_: *const SkCodec) -> SkIRect;
}
extern "C" {
    pub fn C_SkCodec_getOrigin(self_: *const SkCodec) -> SkEncodedOrigin;
}
extern "C" {
    pub fn C_SkCodec_getScaledDimensions(self_: *const SkCodec, desiredScale: f32) -> SkISize;
}
extern "C" {
    pub fn C_SkCodec_getValidSubset(self_: *const SkCodec, desiredSubset: *mut SkIRect) -> bool;
}
extern "C" {
    pub fn C_SkCodec_getEncodedFormat(self_: *const SkCodec) -> SkEncodedImageFormat;
}
extern "C" {
    pub fn C_SkCodec_getImage(
        self_: *mut SkCodec,
        info: *const SkImageInfo,
        opts: *const SkCodec_Options,
        result: *mut SkCodec_Result,
    ) -> *mut SkImage;
}
extern "C" {
    pub fn C_SkCodec_incrementalDecode(
        self_: *mut SkCodec,
        rowsDecoded: *mut ::std::os::raw::c_int,
    ) -> SkCodec_Result;
}
extern "C" {
    pub fn C_SkCodec_getScanlineOrder(self_: *const SkCodec) -> SkCodec_SkScanlineOrder;
}
extern "C" {
    pub fn C_SkCodec_nextScanline(self_: *const SkCodec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn C_SkCodec_getFrameCount(self_: *mut SkCodec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn C_SkCodec_getRepetitionCount(self_: *mut SkCodec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn C_SkEncodedOriginToMatrix(
        origin: SkEncodedOrigin,
        w: ::std::os::raw::c_int,
        h: ::std::os::raw::c_int,
        matrix: *mut SkMatrix,
    );
}
extern "C" {
    pub fn C_Core_Types(
        arg1: *mut SkGraphics,
        arg2: *mut SkCoverageMode,
        arg3: *mut SkColorChannelFlag,
    );
}
extern "C" {
    pub fn C_SkBlender_Mode(mode: SkBlendMode) -> *mut SkBlender;
}
extern "C" {
    pub fn C_SkBlender_Deserialize(
        data: *const ::core::ffi::c_void,
        length: usize,
    ) -> *mut SkBlender;
}
extern "C" {
    pub fn C_SkCubicMap_computeFromT(self_: *const SkCubicMap, t: f32) -> SkPoint;
}
extern "C" {
    pub fn C_SkSurface_MakeRasterDirect(
        imageInfo: *const SkImageInfo,
        pixels: *mut ::core::ffi::c_void,
        rowBytes: usize,
        surfaceProps: *const SkSurfaceProps,
    ) -> *mut SkSurface;
}
extern "C" {
    pub fn C_SkSurface_MakeRaster(
        imageInfo: *const SkImageInfo,
        rowBytes: usize,
        surfaceProps: *const SkSurfaceProps,
    ) -> *mut SkSurface;
}
extern "C" {
    pub fn C_SkSurface_MakeRasterN32Premul(
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        surfaceProps: *const SkSurfaceProps,
    ) -> *mut SkSurface;
}
extern "C" {
    pub fn C_SkSurface_MakeNull(
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
    ) -> *mut SkSurface;
}
extern "C" {
    pub fn C_SkSurface_width(self_: *const SkSurface) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn C_SkSurface_height(self_: *const SkSurface) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn C_SkSurface_imageInfo(self_: *mut SkSurface, info: *mut SkImageInfo);
}
extern "C" {
    pub fn C_SkSurface_makeImageSnapshot(
        self_: *mut SkSurface,
        bounds: *const SkIRect,
    ) -> *mut SkImage;
}
extern "C" {
    pub fn C_SkSurface_makeSurface(
        self_: *mut SkSurface,
        imageInfo: *const SkImageInfo,
    ) -> *mut SkSurface;
}
extern "C" {
    pub fn C_SkSurface_makeSurface2(
        self_: *mut SkSurface,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
    ) -> *mut SkSurface;
}
extern "C" {
    pub fn C_SkSurface_props(self_: *const SkSurface) -> *const SkSurfaceProps;
}
extern "C" {
    pub fn C_SkSurface_draw(
        self_: *mut SkSurface,
        displayList: *const SkDeferredDisplayList,
        xOffset: ::std::os::raw::c_int,
        yOffset: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    pub fn C_SkSurfaceCharacterization_Construct(uninitialized: *mut SkSurfaceCharacterization);
}
extern "C" {
    pub fn C_SkSurfaceCharacterization_CopyConstruct(
        uninitialized: *mut SkSurfaceCharacterization,
        from: *const SkSurfaceCharacterization,
    );
}
extern "C" {
    pub fn C_SkSurfaceCharacterization_destruct(self_: *mut SkSurfaceCharacterization);
}
extern "C" {
    pub fn C_SkSurfaceCharacterization_equals(
        self_: *const SkSurfaceCharacterization,
        rhs: *const SkSurfaceCharacterization,
    ) -> bool;
}
extern "C" {
    pub fn C_SkSurfaceCharacterization_createColorSpace(
        self_: *const SkSurfaceCharacterization,
        cs: *mut SkColorSpace,
        out: *mut SkSurfaceCharacterization,
    );
}
extern "C" {
    pub fn C_SkImage_MakeRasterFromCompressed(
        data: *mut SkData,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        type_: SkImage_CompressionType,
    ) -> *mut SkImage;
}
extern "C" {
    pub fn C_SkImage_MakeRasterData(
        info: *const SkImageInfo,
        pixels: *mut SkData,
        rowBytes: usize,
    ) -> *mut SkImage;
}
extern "C" {
    pub fn C_SkImage_MakeFromBitmap(bitmap: *const SkBitmap) -> *mut SkImage;
}
extern "C" {
    pub fn C_SkImage_MakeFromGenerator(imageGenerator: *mut SkImageGenerator) -> *mut SkImage;
}
extern "C" {
    pub fn C_SkImage_MakeFromEncoded(
        encoded: *mut SkData,
        alphaType: *const SkAlphaType,
    ) -> *mut SkImage;
}
extern "C" {
    pub fn C_SkImage_MakeFromPicture(
        picture: *mut SkPicture,
        dimensions: *const SkISize,
        matrix: *const SkMatrix,
        paint: *const SkPaint,
        bitDepth: SkImage_BitDepth,
        colorSpace: *mut SkColorSpace,
        props: *const SkSurfaceProps,
    ) -> *mut SkImage;
}
extern "C" {
    pub fn C_SkImage_makeShader(
        self_: *const SkImage,
        tileMode1: SkTileMode,
        tileMode2: SkTileMode,
        samplingOptions: *const SkSamplingOptions,
        localMatrix: *const SkMatrix,
    ) -> *mut SkShader;
}
extern "C" {
    pub fn C_SkImage_makeRawShader(
        self_: *const SkImage,
        tileMode1: SkTileMode,
        tileMode2: SkTileMode,
        samplingOptions: *const SkSamplingOptions,
        localMatrix: *const SkMatrix,
    ) -> *mut SkShader;
}
extern "C" {
    pub fn C_SkImage_encodeToData(
        self_: *const SkImage,
        imageFormat: SkEncodedImageFormat,
        quality: ::std::os::raw::c_int,
    ) -> *mut SkData;
}
extern "C" {
    pub fn C_SkImage_refEncodedData(self_: *const SkImage) -> *mut SkData;
}
extern "C" {
    pub fn C_SkImage_makeSubset(
        self_: *const SkImage,
        subset: *const SkIRect,
        direct: *mut GrDirectContext,
    ) -> *mut SkImage;
}
extern "C" {
    pub fn C_SkImage_withDefaultMipmaps(self_: *const SkImage) -> *mut SkImage;
}
extern "C" {
    pub fn C_SkImage_makeNonTextureImage(self_: *const SkImage) -> *mut SkImage;
}
extern "C" {
    pub fn C_SkImage_makeRasterImage(
        self_: *const SkImage,
        cachingHint: SkImage_CachingHint,
    ) -> *mut SkImage;
}
extern "C" {
    pub fn C_SkImage_makeWithFilter(
        self_: *const SkImage,
        context: *mut GrRecordingContext,
        filter: *const SkImageFilter,
        subset: *const SkIRect,
        clipBounds: *const SkIRect,
        outSubset: *mut SkIRect,
        offset: *mut SkIPoint,
    ) -> *mut SkImage;
}
extern "C" {
    pub fn C_SkImage_makeColorSpace(
        self_: *const SkImage,
        target: *mut SkColorSpace,
        direct: *mut GrDirectContext,
    ) -> *mut SkImage;
}
extern "C" {
    pub fn C_SkImage_reinterpretColorSpace(
        self_: *const SkImage,
        newColorSpace: *mut SkColorSpace,
    ) -> *mut SkImage;
}
extern "C" {
    pub fn C_SkEncodePixmap(
        src: *const SkPixmap,
        format: SkEncodedImageFormat,
        quality: ::std::os::raw::c_int,
    ) -> *mut SkData;
}
extern "C" {
    pub fn C_SkEncodeBitmap(
        src: *const SkBitmap,
        format: SkEncodedImageFormat,
        quality: ::std::os::raw::c_int,
    ) -> *mut SkData;
}
extern "C" {
    pub fn C_SkData_ref(self_: *const SkData);
}
extern "C" {
    pub fn C_SkData_unref(self_: *const SkData);
}
extern "C" {
    pub fn C_SkData_unique(self_: *const SkData) -> bool;
}
extern "C" {
    pub fn C_SkData_MakeWithCopy(data: *const ::core::ffi::c_void, length: usize) -> *mut SkData;
}
extern "C" {
    pub fn C_SkData_MakeSubset(src: *const SkData, offset: usize, length: usize) -> *mut SkData;
}
extern "C" {
    pub fn C_SkData_MakeUninitialized(length: usize) -> *mut SkData;
}
extern "C" {
    pub fn C_SkData_MakeZeroInitialized(length: usize) -> *mut SkData;
}
extern "C" {
    pub fn C_SkData_MakeWithCString(cstr: *const ::std::os::raw::c_char) -> *mut SkData;
}
extern "C" {
    pub fn C_SkData_MakeWithoutCopy(data: *const ::core::ffi::c_void, length: usize)
        -> *mut SkData;
}
extern "C" {
    pub fn C_SkData_MakeEmpty() -> *mut SkData;
}
extern "C" {
    pub fn C_SkPaint_destruct(self_: *mut SkPaint);
}
extern "C" {
    pub fn C_SkPaint_copy(self_: *mut SkPaint, rhs: *const SkPaint);
}
extern "C" {
    pub fn C_SkPaint_Equals(lhs: *const SkPaint, rhs: *const SkPaint) -> bool;
}
extern "C" {
    pub fn C_SkPaint_getStyle(self_: *const SkPaint) -> SkPaint_Style;
}
extern "C" {
    pub fn C_SkPaint_getAlpha(self_: *const SkPaint) -> u8;
}
extern "C" {
    pub fn C_SkPaint_getStrokeCap(self_: *const SkPaint) -> SkPaint_Cap;
}
extern "C" {
    pub fn C_SkPaint_getStrokeJoin(self_: *const SkPaint) -> SkPaint_Join;
}
extern "C" {
    pub fn C_SkPaint_setShader(self_: *mut SkPaint, shader: *mut SkShader);
}
extern "C" {
    pub fn C_SkPaint_setColorFilter(self_: *mut SkPaint, colorFilter: *mut SkColorFilter);
}
extern "C" {
    pub fn C_SkPaint_asBlendMode(self_: *const SkPaint, mode: *mut SkBlendMode) -> bool;
}
extern "C" {
    pub fn C_SkPaint_setBlender(self_: *mut SkPaint, blender: *mut SkBlender);
}
extern "C" {
    pub fn C_SkPaint_setPathEffect(self_: *mut SkPaint, pathEffect: *mut SkPathEffect);
}
extern "C" {
    pub fn C_SkPaint_setMaskFilter(self_: *mut SkPaint, maskFilter: *mut SkMaskFilter);
}
extern "C" {
    pub fn C_SkPaint_setImageFilter(self_: *mut SkPaint, imageFilter: *mut SkImageFilter);
}
extern "C" {
    pub fn C_SkPath_Construct(uninitialized: *mut SkPath);
}
extern "C" {
    pub fn C_SkPath_Make(
        uninitialized: *mut SkPath,
        pts: *const SkPoint,
        pointCount: ::std::os::raw::c_int,
        vbs: *const u8,
        verbCount: ::std::os::raw::c_int,
        ws: *const SkScalar,
        wCount: ::std::os::raw::c_int,
        ft: SkPathFillType,
        isVolatile: bool,
    );
}
extern "C" {
    pub fn C_SkPath_Rect(uninitialized: *mut SkPath, r: *const SkRect, dir: SkPathDirection);
}
extern "C" {
    pub fn C_SkPath_Oval(uninitialized: *mut SkPath, r: *const SkRect, dir: SkPathDirection);
}
extern "C" {
    pub fn C_SkPath_OvalWithStartIndex(
        uninitialized: *mut SkPath,
        r: *const SkRect,
        dir: SkPathDirection,
        startIndex: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn C_SkPath_Circle(
        uninitialized: *mut SkPath,
        x: SkScalar,
        y: SkScalar,
        r: SkScalar,
        dir: SkPathDirection,
    );
}
extern "C" {
    pub fn C_SkPath_RRect(uninitialized: *mut SkPath, rr: *const SkRRect, dir: SkPathDirection);
}
extern "C" {
    pub fn C_SkPath_RRectWithStartIndex(
        uninitialized: *mut SkPath,
        r: *const SkRRect,
        dir: SkPathDirection,
        startIndex: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn C_SkPath_Polygon(
        uninitialized: *mut SkPath,
        pts: *const SkPoint,
        count: ::std::os::raw::c_int,
        isClosed: bool,
        ft: SkPathFillType,
        isVolatile: bool,
    );
}
extern "C" {
    pub fn C_SkPath_destruct(self_: *const SkPath);
}
extern "C" {
    pub fn C_SkPath_Equals(lhs: *const SkPath, rhs: *const SkPath) -> bool;
}
extern "C" {
    pub fn C_SkPath_serialize(self_: *const SkPath) -> *mut SkData;
}
extern "C" {
    pub fn C_SkPath_Iter_destruct(self_: *mut SkPath_Iter);
}
extern "C" {
    pub fn C_SkPath_Iter_isCloseLine(self_: *const SkPath_Iter) -> bool;
}
extern "C" {
    pub fn C_SkPath_RawIter_Construct(uninitialized: *mut SkPath_RawIter);
}
extern "C" {
    pub fn C_SkPath_RawIter_destruct(self_: *mut SkPath_RawIter);
}
extern "C" {
    pub fn C_SkPath_RawIter_peek(self_: *const SkPath_RawIter) -> SkPath_Verb;
}
extern "C" {
    pub fn C_SkPath_getFillType(self_: *const SkPath) -> SkPathFillType;
}
extern "C" {
    pub fn C_SkPath_getPoint(self_: *const SkPath, index: ::std::os::raw::c_int) -> SkPoint;
}
extern "C" {
    pub fn C_SkPath_getBounds(self_: *const SkPath) -> *const SkRect;
}
extern "C" {
    pub fn C_SkPath_computeTightBounds(self_: *const SkPath) -> SkRect;
}
extern "C" {
    pub fn C_SkPathBuilder_Construct(uninitialized: *mut SkPathBuilder);
}
extern "C" {
    pub fn C_SkPathBuilder_Construct3(uninitialized: *mut SkPathBuilder, path: *const SkPath);
}
extern "C" {
    pub fn C_SkPathBuilder_computeBounds(self_: *const SkPathBuilder) -> SkRect;
}
extern "C" {
    pub fn C_SkPathBuilder_CopyConstruct(
        uninitialized: *mut SkPathBuilder,
        pathBuilder: *const SkPathBuilder,
    );
}
extern "C" {
    pub fn C_SkPathBuilder_destruct(self_: *mut SkPathBuilder);
}
extern "C" {
    pub fn C_SkPathBuilder_snapshot(self_: *const SkPathBuilder, path: *mut SkPath);
}
extern "C" {
    pub fn C_SkPathBuilder_detach(self_: *mut SkPathBuilder, path: *mut SkPath);
}
extern "C" {
    pub fn C_SkPathMeasure_destruct(self_: *const SkPathMeasure);
}
extern "C" {
    pub fn C_SkPathTypes_Types(
        arg1: *mut SkPathFillType,
        arg2: *mut SkPathDirection,
        arg3: *mut SkPathSegmentMask,
        arg4: *mut SkPathVerb,
    );
}
extern "C" {
    pub fn C_SkCanvas_newEmpty() -> *mut SkCanvas;
}
extern "C" {
    pub fn C_SkCanvas_newWidthHeightAndProps(
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        props: *const SkSurfaceProps,
    ) -> *mut SkCanvas;
}
extern "C" {
    pub fn C_SkCanvas_newFromBitmap(bitmap: *const SkBitmap) -> *mut SkCanvas;
}
extern "C" {
    pub fn C_SkCanvas_newFromBitmapAndProps(
        bitmap: *const SkBitmap,
        props: *const SkSurfaceProps,
    ) -> *mut SkCanvas;
}
extern "C" {
    pub fn C_SkCanvas_delete(self_: *const SkCanvas);
}
extern "C" {
    pub fn C_SkCanvas_MakeRasterDirect(
        info: *const SkImageInfo,
        pixels: *mut ::core::ffi::c_void,
        row_bytes: usize,
        props: *const SkSurfaceProps,
    ) -> *mut SkCanvas;
}
extern "C" {
    pub fn C_SkCanvas_imageInfo(self_: *const SkCanvas, info: *mut SkImageInfo);
}
extern "C" {
    pub fn C_SkCanvas_getBaseLayerSize(self_: *const SkCanvas, size: *mut SkISize);
}
extern "C" {
    pub fn C_SkCanvas_makeSurface(
        self_: *mut SkCanvas,
        info: *const SkImageInfo,
        props: *const SkSurfaceProps,
    ) -> *mut SkSurface;
}
extern "C" {
    pub fn C_SkCanvas_clipShader(self_: *mut SkCanvas, shader: *mut SkShader, op: SkClipOp);
}
extern "C" {
    pub fn C_SkCanvas_getLocalClipBounds(self_: *const SkCanvas) -> SkRect;
}
extern "C" {
    pub fn C_SkCanvas_getDeviceClipBounds(self_: *const SkCanvas) -> SkIRect;
}
extern "C" {
    pub fn C_SkCanvas_isClipEmpty(self_: *const SkCanvas) -> bool;
}
extern "C" {
    pub fn C_SkCanvas_isClipRect(self_: *const SkCanvas) -> bool;
}
extern "C" {
    pub fn C_SkCanvas_getLocalToDevice(self_: *const SkCanvas, uninitialized: *mut SkM44);
}
extern "C" {
    pub fn C_SkCanvas_getTotalMatrix(self_: *const SkCanvas, matrix: *mut SkMatrix);
}
extern "C" {
    pub fn C_SkCanvas_discard(self_: *mut SkCanvas);
}
extern "C" {
    pub fn C_SkAutoCanvasRestore_Construct(
        uninitialized: *mut SkAutoCanvasRestore,
        canvas: *mut SkCanvas,
        doSave: bool,
    );
}
extern "C" {
    pub fn C_SkAutoCanvasRestore_destruct(self_: *const SkAutoCanvasRestore);
}
extern "C" {
    pub fn C_SkAutoCanvasRestore_restore(self_: *mut SkAutoCanvasRestore);
}
extern "C" {
    pub fn C_SkColorInfo_Construct(uninitialized: *mut SkColorInfo);
}
extern "C" {
    pub fn C_SkColorInfo_Construct2(
        uninitialized: *mut SkColorInfo,
        ct: SkColorType,
        at: SkAlphaType,
        cs: *mut SkColorSpace,
    );
}
extern "C" {
    pub fn C_SkColorInfo_destruct(self_: *mut SkColorInfo);
}
extern "C" {
    pub fn C_SkColorInfo_Copy(from: *const SkColorInfo, to: *mut SkColorInfo);
}
extern "C" {
    pub fn C_SkColorInfo_Equals(lhs: *const SkColorInfo, rhs: *const SkColorInfo) -> bool;
}
extern "C" {
    pub fn C_SkColorInfo_makeAlphaType(
        self_: *const SkColorInfo,
        newAlphaType: SkAlphaType,
        uninitialized: *mut SkColorInfo,
    );
}
extern "C" {
    pub fn C_SkColorInfo_makeColorType(
        self_: *const SkColorInfo,
        newColorType: SkColorType,
        uninitialized: *mut SkColorInfo,
    );
}
extern "C" {
    pub fn C_SkColorInfo_makeColorSpace(
        self_: *const SkColorInfo,
        newColorSpace: *mut SkColorSpace,
        uninitialized: *mut SkColorInfo,
    );
}
extern "C" {
    pub fn C_SkImageInfo_Construct(uninitialized: *mut SkImageInfo);
}
extern "C" {
    pub fn C_SkImageInfo_destruct(self_: *mut SkImageInfo);
}
extern "C" {
    pub fn C_SkImageInfo_Copy(from: *const SkImageInfo, to: *mut SkImageInfo);
}
extern "C" {
    pub fn C_SkImageInfo_Equals(lhs: *const SkImageInfo, rhs: *const SkImageInfo) -> bool;
}
extern "C" {
    pub fn C_SkImageInfo_Make(
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        ct: SkColorType,
        at: SkAlphaType,
        cs: *mut SkColorSpace,
        uninitialized: *mut SkImageInfo,
    );
}
extern "C" {
    pub fn C_SkImageInfo_MakeN32(
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        at: SkAlphaType,
        cs: *mut SkColorSpace,
        uninitialized: *mut SkImageInfo,
    );
}
extern "C" {
    pub fn C_SkImageInfo_MakeS32(
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        at: SkAlphaType,
        uninitialized: *mut SkImageInfo,
    );
}
extern "C" {
    pub fn C_SkImageInfo_MakeN32Premul(
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        cs: *mut SkColorSpace,
        uninitialized: *mut SkImageInfo,
    );
}
extern "C" {
    pub fn C_SkImageInfo_MakeA8(
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        uninitialized: *mut SkImageInfo,
    );
}
extern "C" {
    pub fn C_SkImageInfo_MakeUnknown(
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        uninitialized: *mut SkImageInfo,
    );
}
extern "C" {
    pub fn C_SkImageInfo_makeColorSpace(
        self_: *const SkImageInfo,
        cs: *mut SkColorSpace,
        uninitialized: *mut SkImageInfo,
    );
}
extern "C" {
    pub fn C_SkImageInfo_reset(self_: *mut SkImageInfo);
}
extern "C" {
    pub fn C_SkColorSpace_Types(arg1: *mut SkColorSpacePrimaries);
}
extern "C" {
    pub fn C_SkColorSpace_ref(self_: *const SkColorSpace);
}
extern "C" {
    pub fn C_SkColorSpace_unref(self_: *const SkColorSpace);
}
extern "C" {
    pub fn C_SkColorSpace_unique(self_: *const SkColorSpace) -> bool;
}
extern "C" {
    pub fn C_SkColorSpace_MakeSRGB() -> *mut SkColorSpace;
}
extern "C" {
    pub fn C_SkColorSpace_MakeSRGBLinear() -> *mut SkColorSpace;
}
extern "C" {
    pub fn C_SkColorSpace_makeLinearGamma(self_: *const SkColorSpace) -> *mut SkColorSpace;
}
extern "C" {
    pub fn C_SkColorSpace_makeSRGBGamma(self_: *const SkColorSpace) -> *mut SkColorSpace;
}
extern "C" {
    pub fn C_SkColorSpace_makeColorSpin(self_: *const SkColorSpace) -> *mut SkColorSpace;
}
extern "C" {
    pub fn C_SkColorSpace_serialize(self_: *const SkColorSpace) -> *mut SkData;
}
extern "C" {
    pub fn C_SkColorSpace_Deserialize(
        data: *const ::core::ffi::c_void,
        length: usize,
    ) -> *mut SkColorSpace;
}
extern "C" {
    pub fn C_SkM44_Types(arg1: *mut SkV2);
}
extern "C" {
    pub fn C_SkM44_equals(self_: *const SkM44, other: *const SkM44) -> bool;
}
extern "C" {
    pub fn C_SkM44_RectToRect(src: *const SkRect, dst: *const SkRect, uninitialized: *mut SkM44);
}
extern "C" {
    pub fn C_SkM44_LookAt(
        eye: *const SkV3,
        center: *const SkV3,
        up: *const SkV3,
        uninitialized: *mut SkM44,
    );
}
extern "C" {
    pub fn C_SkM44_Perspective(near: f32, far: f32, angle: f32, uninitialized: *mut SkM44);
}
extern "C" {
    pub fn C_SkM44_transpose(self_: *const SkM44, uninitialized: *mut SkM44);
}
extern "C" {
    pub fn C_SkM44_map(self_: *const SkM44, x: f32, y: f32, z: f32, w: f32) -> SkV4;
}
extern "C" {
    pub fn C_SkMatrix_Equals(self_: *const SkMatrix, rhs: *const SkMatrix) -> bool;
}
extern "C" {
    pub fn C_SkMatrix_SubscriptMut(self_: *mut SkMatrix, index: usize) -> *mut SkScalar;
}
extern "C" {
    pub fn C_SkMatrix_getType(self_: *const SkMatrix) -> SkMatrix_TypeMask;
}
extern "C" {
    pub fn C_SkMatrix_rectStaysRect(self_: *const SkMatrix) -> bool;
}
extern "C" {
    pub fn C_SkMatrix_hasPerspective(self_: *const SkMatrix) -> bool;
}
extern "C" {
    pub fn C_SkMatrix_invert(self_: *const SkMatrix, inverse: *mut SkMatrix) -> bool;
}
extern "C" {
    pub fn C_SkMatrix_setScaleTranslate(
        self_: *mut SkMatrix,
        sx: SkScalar,
        sy: SkScalar,
        tx: SkScalar,
        ty: SkScalar,
    );
}
extern "C" {
    pub fn C_SkMatrix_isFinite(self_: *const SkMatrix) -> bool;
}
extern "C" {
    pub fn C_SkMatrix_InvalidMatrix() -> *const SkMatrix;
}
extern "C" {
    pub fn C_SkMatrix_normalizePerspective(self_: *mut SkMatrix);
}
extern "C" {
    pub fn C_SkSurfaceProps_Equals(
        self_: *const SkSurfaceProps,
        rhs: *const SkSurfaceProps,
    ) -> bool;
}
extern "C" {
    pub fn C_SkBitmap_Construct(uninitialized: *mut SkBitmap);
}
extern "C" {
    pub fn C_SkBitmap_destruct(self_: *mut SkBitmap);
}
extern "C" {
    pub fn C_SkBitmap_Copy(from: *const SkBitmap, to: *mut SkBitmap);
}
extern "C" {
    pub fn C_SkBitmap_ComputeIsOpaque(self_: *const SkBitmap) -> bool;
}
extern "C" {
    pub fn C_SkBitmap_tryAllocN32Pixels(
        self_: *mut SkBitmap,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        isOpaque: bool,
    ) -> bool;
}
extern "C" {
    pub fn C_SkBitmap_tryAllocPixels(self_: *mut SkBitmap) -> bool;
}
extern "C" {
    pub fn C_SkBitmap_pixelRefOrigin(self_: *const SkBitmap) -> SkIPoint;
}
extern "C" {
    pub fn C_SkBitmap_setPixelRef(
        self_: *mut SkBitmap,
        pixelRef: *mut SkPixelRef,
        dx: ::std::os::raw::c_int,
        dy: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn C_SkBitmap_readyToDraw(self_: *const SkBitmap) -> bool;
}
extern "C" {
    pub fn C_SkBitmap_eraseARGB(self_: *const SkBitmap, a: U8CPU, r: U8CPU, g: U8CPU, b: U8CPU);
}
extern "C" {
    pub fn C_SkBitmap_getAlphaf(
        self_: *const SkBitmap,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
    ) -> f32;
}
extern "C" {
    pub fn C_SkBitmap_extractAlpha(
        self_: *const SkBitmap,
        dst: *mut SkBitmap,
        paint: *const SkPaint,
        offset: *mut SkIPoint,
    ) -> bool;
}
extern "C" {
    pub fn C_SkBitmap_makeShader(
        self_: *const SkBitmap,
        tmx: SkTileMode,
        tmy: SkTileMode,
        sampling: *const SkSamplingOptions,
        localMatrix: *const SkMatrix,
    ) -> *mut SkShader;
}
extern "C" {
    pub fn C_SkBitmap_asImage(self_: *const SkBitmap) -> *mut SkImage;
}
extern "C" {
    pub fn C_SkPicture_MakeFromData(data: *const SkData) -> *mut SkPicture;
}
extern "C" {
    pub fn C_SkPicture_MakeFromData2(
        data: *const ::core::ffi::c_void,
        size: usize,
    ) -> *mut SkPicture;
}
extern "C" {
    pub fn C_SkPicture_serialize(self_: *const SkPicture) -> *mut SkData;
}
extern "C" {
    pub fn C_SkPicture_MakePlaceholder(cull: *const SkRect) -> *mut SkPicture;
}
extern "C" {
    pub fn C_SkPicture_playback(self_: *const SkPicture, canvas: *mut SkCanvas);
}
extern "C" {
    pub fn C_SkPicture_cullRect(self_: *const SkPicture) -> SkRect;
}
extern "C" {
    pub fn C_SkPicture_uniqueID(self_: *const SkPicture) -> u32;
}
extern "C" {
    pub fn C_SkPicture_approximateOpCount(
        self_: *const SkPicture,
        nested: bool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn C_SkPicture_approximateBytesUsed(self_: *const SkPicture, out: *mut usize);
}
extern "C" {
    pub fn C_SkPicture_makeShader(
        self_: *const SkPicture,
        tmx: SkTileMode,
        tmy: SkTileMode,
        mode: SkFilterMode,
        localMatrix: *const SkMatrix,
        tileRect: *const SkRect,
    ) -> *mut SkShader;
}
extern "C" {
    pub fn C_SkRRect_Construct(uninitialized: *mut SkRRect);
}
extern "C" {
    pub fn C_SkRRect_getType(self_: *const SkRRect) -> SkRRect_Type;
}
extern "C" {
    pub fn C_SkRRect_setRect(self_: *mut SkRRect, rect: *const SkRect);
}
extern "C" {
    pub fn C_SkRRect_dumpToString(self_: *const SkRRect, asHex: bool, str_: *mut SkString);
}
extern "C" {
    pub fn C_SkRRect_Equals(lhs: *const SkRRect, rhs: *const SkRRect) -> bool;
}
extern "C" {
    pub fn C_SkRegion_destruct(region: *mut SkRegion);
}
extern "C" {
    pub fn C_SkRegion_Equals(lhs: *const SkRegion, rhs: *const SkRegion) -> bool;
}
extern "C" {
    pub fn C_SkRegion_set(self_: *mut SkRegion, region: *const SkRegion) -> bool;
}
extern "C" {
    pub fn C_SkRegion_quickContains(self_: *const SkRegion, r: *const SkIRect) -> bool;
}
extern "C" {
    pub fn C_SkRegion_Iterator_Construct(uninitialized: *mut SkRegion_Iterator);
}
extern "C" {
    pub fn C_SkRegion_Iterator_destruct(self_: *mut SkRegion_Iterator);
}
extern "C" {
    pub fn C_SkRegion_Iterator_rgn(self_: *const SkRegion_Iterator) -> *const SkRegion;
}
extern "C" {
    pub fn C_SkRegion_Cliperator_destruct(self_: *mut SkRegion_Cliperator);
}
extern "C" {
    pub fn C_SkRegion_Spanerator_destruct(self_: *mut SkRegion_Spanerator);
}
extern "C" {
    pub fn C_SkFontStyle_Construct(uninitialized: *mut SkFontStyle);
}
extern "C" {
    pub fn C_SkFontStyle_Construct2(
        uninitialized: *mut SkFontStyle,
        weight: ::std::os::raw::c_int,
        width: ::std::os::raw::c_int,
        slant: SkFontStyle_Slant,
    );
}
extern "C" {
    pub fn C_SkFontStyle_Equals(lhs: *const SkFontStyle, rhs: *const SkFontStyle) -> bool;
}
extern "C" {
    pub fn C_SkFontStyle_weight(self_: *const SkFontStyle) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn C_SkFontStyle_width(self_: *const SkFontStyle) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn C_SkFontStyle_slant(self_: *const SkFontStyle) -> SkFontStyle_Slant;
}
extern "C" {
    pub fn C_SkTextBlob_ref(self_: *const SkTextBlob);
}
extern "C" {
    pub fn C_SkTextBlob_unref(self_: *const SkTextBlob);
}
extern "C" {
    pub fn C_SkTextBlob_unique(self_: *const SkTextBlob) -> bool;
}
extern "C" {
    pub fn C_SkTextBlob_MakeFromText(
        text: *const ::core::ffi::c_void,
        byteLength: usize,
        font: *const SkFont,
        encoding: SkTextEncoding,
    ) -> *mut SkTextBlob;
}
extern "C" {
    pub fn C_SkTextBlob_MakeFromPosTextH(
        text: *const ::core::ffi::c_void,
        byteLength: usize,
        xPos: *const SkScalar,
        constY: SkScalar,
        font: *const SkFont,
        encoding: SkTextEncoding,
    ) -> *mut SkTextBlob;
}
extern "C" {
    pub fn C_SkTextBlob_MakeFromPosText(
        text: *const ::core::ffi::c_void,
        byteLength: usize,
        pos: *const SkPoint,
        font: *const SkFont,
        encoding: SkTextEncoding,
    ) -> *mut SkTextBlob;
}
extern "C" {
    pub fn C_SkTextBlob_MakeFromRSXform(
        text: *const ::core::ffi::c_void,
        byteLength: usize,
        xform: *const SkRSXform,
        font: *const SkFont,
        encoding: SkTextEncoding,
    ) -> *mut SkTextBlob;
}
extern "C" {
    pub fn C_SkTextBlob_Iter_destruct(self_: *mut SkTextBlob_Iter);
}
extern "C" {
    pub fn C_SkTextBlobBuilder_destruct(self_: *mut SkTextBlobBuilder);
}
extern "C" {
    pub fn C_SkTextBlobBuilder_make(self_: *mut SkTextBlobBuilder) -> *mut SkTextBlob;
}
extern "C" {
    pub fn C_SkTypeface_isBold(self_: *const SkTypeface) -> bool;
}
extern "C" {
    pub fn C_SkTypeface_isItalic(self_: *const SkTypeface) -> bool;
}
extern "C" {
    pub fn C_SkTypeface_MakeDefault() -> *mut SkTypeface;
}
extern "C" {
    pub fn C_SkTypeface_MakeFromName(
        familyName: *const ::std::os::raw::c_char,
        fontStyle: SkFontStyle,
    ) -> *mut SkTypeface;
}
extern "C" {
    pub fn C_SkTypeface_MakeFromData(
        data: *mut SkData,
        index: ::std::os::raw::c_int,
    ) -> *mut SkTypeface;
}
extern "C" {
    pub fn C_SkTypeface_makeClone(
        self_: *const SkTypeface,
        arguments: *const SkFontArguments,
    ) -> *mut SkTypeface;
}
extern "C" {
    pub fn C_SkTypeface_serialize(
        self_: *const SkTypeface,
        behavior: SkTypeface_SerializeBehavior,
    ) -> *mut SkData;
}
extern "C" {
    pub fn C_SkTypeface_MakeDeserialize(stream: *mut SkStream) -> *mut SkTypeface;
}
extern "C" {
    pub fn C_SkTypeface_copyTableData(self_: *const SkTypeface, tag: SkFontTableTag)
        -> *mut SkData;
}
extern "C" {
    pub fn C_SkTypeface_openStream(
        self_: *const SkTypeface,
        ttcIndex: *mut ::std::os::raw::c_int,
    ) -> *mut SkStreamAsset;
}
extern "C" {
    pub fn C_SkTypeface_getBounds(self_: *const SkTypeface) -> SkRect;
}
extern "C" {
    pub fn C_SkTypeface_LocalizedStrings_unref(self_: *mut SkTypeface_LocalizedStrings);
}
extern "C" {
    pub fn C_SkTypeface_LocalizedStrings_next(
        self_: *mut SkTypeface_LocalizedStrings,
        string: *mut SkString,
        language: *mut SkString,
    ) -> bool;
}
extern "C" {
    pub fn C_SkFlattenable_getTypeName(
        self_: *const SkFlattenable,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn C_SkFlattenable_serialize(self_: *const SkFlattenable) -> *mut SkData;
}
extern "C" {
    pub fn C_SkFont_ConstructFromTypeface(uninitialized: *mut SkFont, typeface: *mut SkTypeface);
}
extern "C" {
    pub fn C_SkFont_ConstructFromTypefaceWithSize(
        uninitialized: *mut SkFont,
        typeface: *mut SkTypeface,
        size: SkScalar,
    );
}
extern "C" {
    pub fn C_SkFont_ConstructFromTypefaceWithSizeScaleAndSkew(
        uninitialized: *mut SkFont,
        typeface: *mut SkTypeface,
        size: SkScalar,
        scaleX: SkScalar,
        skewX: SkScalar,
    );
}
extern "C" {
    pub fn C_SkFont_destruct(self_: *mut SkFont);
}
extern "C" {
    pub fn C_SkFont_Equals(self_: *const SkFont, other: *const SkFont) -> bool;
}
extern "C" {
    pub fn C_SkFont_getEdging(self_: *const SkFont) -> SkFont_Edging;
}
extern "C" {
    pub fn C_SkFont_getHinting(self_: *const SkFont) -> SkFontHinting;
}
extern "C" {
    pub fn C_SkFont_makeWithSize(self_: *const SkFont, size: SkScalar, result: *mut SkFont);
}
extern "C" {
    pub fn C_SkFont_getTypeface(self_: *mut SkFont) -> *mut SkTypeface;
}
extern "C" {
    pub fn C_SkFont_setTypeface(self_: *mut SkFont, tf: *mut SkTypeface);
}
extern "C" {
    pub fn C_SkFont_getIntercepts(
        self_: *const SkFont,
        glyphs: *const SkGlyphID,
        count: ::std::os::raw::c_int,
        pos: *const SkPoint,
        top: SkScalar,
        bottom: SkScalar,
        paint: *const SkPaint,
        vs: *mut VecSink<SkScalar>,
    );
}
extern "C" {
    pub fn C_SkFontArguments_construct(uninitialized: *mut SkFontArguments);
}
extern "C" {
    pub fn C_SkFontArguments_destruct(self_: *mut SkFontArguments);
}
extern "C" {
    pub fn C_SkFontArguments_setCollectionIndex(
        self_: *mut SkFontArguments,
        collectionIndex: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn C_SkFontArguments_setVariationDesignPosition(
        self_: *mut SkFontArguments,
        position: SkFontArguments_VariationPosition,
    );
}
extern "C" {
    pub fn C_SkFontArguments_setPalette(
        self_: *mut SkFontArguments,
        palette: SkFontArguments_Palette,
    );
}
extern "C" {
    pub fn C_SkFontArguments_getVariationDesignPosition(
        self_: *const SkFontArguments,
    ) -> SkFontArguments_VariationPosition;
}
extern "C" {
    pub fn C_SkFontArguments_getPalette(self_: *const SkFontArguments) -> SkFontArguments_Palette;
}
extern "C" {
    pub fn C_SkFontStyleSet_count(self_: *mut SkFontStyleSet) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn C_SkFontStyleSet_getStyle(
        self_: *mut SkFontStyleSet,
        index: ::std::os::raw::c_int,
        fontStyle: *mut SkFontStyle,
        style: *mut SkString,
    );
}
extern "C" {
    pub fn C_SkFontStyleSet_createTypeface(
        self_: *mut SkFontStyleSet,
        index: ::std::os::raw::c_int,
    ) -> *mut SkTypeface;
}
extern "C" {
    pub fn C_SkFontStyleSet_matchStyle(
        self_: *mut SkFontStyleSet,
        pattern: *const SkFontStyle,
    ) -> *mut SkTypeface;
}
extern "C" {
    pub fn C_SkFontMgr_makeFromStream(
        self_: *const SkFontMgr,
        stream: *mut SkStreamAsset,
        ttcIndex: ::std::os::raw::c_int,
    ) -> *mut SkTypeface;
}
extern "C" {
    pub fn C_SkFontMgr_RefDefault() -> *mut SkFontMgr;
}
extern "C" {
    pub fn C_SkFontParameters_Variation_Axis_isHidden(
        self_: *const SkFontParameters_Variation_Axis,
    ) -> bool;
}
extern "C" {
    pub fn C_SkFontParameters_Variation_Axis_setHidden(
        self_: *mut SkFontParameters_Variation_Axis,
        hidden: bool,
    );
}
extern "C" {
    pub fn C_SkVertices_ref(self_: *const SkVertices);
}
extern "C" {
    pub fn C_SkVertices_unref(self_: *const SkVertices);
}
extern "C" {
    pub fn C_SkVertices_unique(self_: *const SkVertices) -> bool;
}
extern "C" {
    pub fn C_SkVertices_MakeCopy(
        mode: SkVertices_VertexMode,
        vertexCount: ::std::os::raw::c_int,
        positions: *const SkPoint,
        texs: *const SkPoint,
        colors: *const SkColor,
        indexCount: ::std::os::raw::c_int,
        indices: *const u16,
    ) -> *mut SkVertices;
}
extern "C" {
    pub fn C_SkVertices_Builder_destruct(builder: *mut SkVertices_Builder);
}
extern "C" {
    pub fn C_SkVertices_Builder_detach(builder: *mut SkVertices_Builder) -> *mut SkVertices;
}
extern "C" {
    pub fn C_SkPictureRecorder_Construct(uninitialized: *mut SkPictureRecorder);
}
extern "C" {
    pub fn C_SkPictureRecorder_destruct(self_: *mut SkPictureRecorder);
}
extern "C" {
    pub fn C_SkPictureRecorder_finishRecordingAsPicture(
        self_: *mut SkPictureRecorder,
        cullRect: *const SkRect,
    ) -> *mut SkPicture;
}
extern "C" {
    pub fn C_SkPictureRecorder_finishRecordingAsDrawable(
        self_: *mut SkPictureRecorder,
    ) -> *mut SkDrawable;
}
extern "C" {
    pub fn C_SkPixelRef_width(self_: *const SkPixelRef) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn C_SkPixelRef_height(self_: *const SkPixelRef) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn C_SkPixelRef_pixels(self_: *const SkPixelRef) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn C_SkPixelRef_rowBytes(self_: *const SkPixelRef) -> usize;
}
extern "C" {
    pub fn C_SkPixelRef_isImmutable(self_: *const SkPixelRef) -> bool;
}
extern "C" {
    pub fn C_SkPixelRef_notifyAddedToCache(self_: *mut SkPixelRef);
}
extern "C" {
    pub fn C_SkPoint_isFinite(self_: *const SkPoint) -> bool;
}
extern "C" {
    pub fn C_SkIRect_isEmpty(self_: *const SkIRect) -> bool;
}
extern "C" {
    pub fn C_SkIRect_contains(self_: *const SkIRect, rect: *const SkRect) -> bool;
}
extern "C" {
    pub fn C_SkRect_round(self_: *const SkRect, dst: *mut SkIRect);
}
extern "C" {
    pub fn C_SkRect_roundIn(self_: *const SkRect, dst: *mut SkIRect);
}
extern "C" {
    pub fn C_SkRect_roundOut(self_: *const SkRect, dst: *mut SkIRect);
}
extern "C" {
    pub fn C_SkRefCntBase_ref(self_: *const SkRefCntBase);
}
extern "C" {
    pub fn C_SkRefCntBase_unref(self_: *const SkRefCntBase);
}
extern "C" {
    pub fn C_SkRefCntBase_unique(self_: *const SkRefCntBase) -> bool;
}
extern "C" {
    pub fn C_SkColorFilter_makeComposed(
        self_: *const SkColorFilter,
        inner: *mut SkColorFilter,
    ) -> *mut SkColorFilter;
}
extern "C" {
    pub fn C_SkColorFilter_Deserialize(
        data: *const ::core::ffi::c_void,
        length: usize,
    ) -> *mut SkColorFilter;
}
extern "C" {
    pub fn C_SkColorFilter_filterColor4f(
        self_: *const SkColorFilter,
        srcColor: *const SkColor4f,
        srcCS: *mut SkColorSpace,
        dstCS: *mut SkColorSpace,
    ) -> SkColor4f;
}
extern "C" {
    pub fn C_SkColorFilters_Compose(
        outer: *mut SkColorFilter,
        inner: *mut SkColorFilter,
    ) -> *mut SkColorFilter;
}
extern "C" {
    pub fn C_SkColorFilters_Blend2(
        c: *const SkColor4f,
        colorSpace: *mut SkColorSpace,
        blendMode: SkBlendMode,
    ) -> *mut SkColorFilter;
}
extern "C" {
    pub fn C_SkColorFilters_Blend(c: SkColor, blendMode: SkBlendMode) -> *mut SkColorFilter;
}
extern "C" {
    pub fn C_SkColorFilters_Matrix(colorMatrix: *const SkColorMatrix) -> *mut SkColorFilter;
}
extern "C" {
    pub fn C_SkColorFilters_MatrixRowMajor(array: *const SkScalar) -> *mut SkColorFilter;
}
extern "C" {
    pub fn C_SkColorFilters_HSLAMatrixOfColorMatrix(
        colorMatrix: *const SkColorMatrix,
    ) -> *mut SkColorFilter;
}
extern "C" {
    pub fn C_SkColorFilters_HSLAMatrix(rowMajor: *const f32) -> *mut SkColorFilter;
}
extern "C" {
    pub fn C_SkColorFilters_LinearToSRGBGamma() -> *mut SkColorFilter;
}
extern "C" {
    pub fn C_SkColorFilters_SRGBToLinearGamma() -> *mut SkColorFilter;
}
extern "C" {
    pub fn C_SkColorFilters_Lerp(
        t: f32,
        dst: *mut SkColorFilter,
        src: *mut SkColorFilter,
    ) -> *mut SkColorFilter;
}
extern "C" {
    pub fn C_SkContourMeasureIter_destruct(self_: *mut SkContourMeasureIter);
}
extern "C" {
    pub fn C_SkContourMeasureIter_next(self_: *mut SkContourMeasureIter) -> *mut SkContourMeasure;
}
extern "C" {
    pub fn C_SkContourMeasure_length(self_: *const SkContourMeasure) -> SkScalar;
}
extern "C" {
    pub fn C_SkContourMeasure_isClosed(self_: *const SkContourMeasure) -> bool;
}
extern "C" {
    pub fn C_SkDataTable_count(self_: *const SkDataTable) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn C_SkDataTable_MakeEmpty() -> *mut SkDataTable;
}
extern "C" {
    pub fn C_SkDataTable_MakeCopyArrays(
        ptrs: *const *const ::core::ffi::c_void,
        sizes: *const usize,
        count: ::std::os::raw::c_int,
    ) -> *mut SkDataTable;
}
extern "C" {
    pub fn C_SkDataTable_MakeCopyArray(
        array: *const ::core::ffi::c_void,
        elemSize: usize,
        count: ::std::os::raw::c_int,
    ) -> *mut SkDataTable;
}
extern "C" {
    pub fn C_SkDeferredDisplayListRecorder_destruct(self_: *mut SkDeferredDisplayListRecorder);
}
extern "C" {
    pub fn C_SkDeferredDisplayListRecorder_detach(
        self_: *mut SkDeferredDisplayListRecorder,
    ) -> *mut SkDeferredDisplayList;
}
extern "C" {
    pub fn C_SkDeferredDisplayList_ref(self_: *const SkDeferredDisplayList);
}
extern "C" {
    pub fn C_SkDeferredDisplayList_unref(self_: *const SkDeferredDisplayList);
}
extern "C" {
    pub fn C_SkDeferredDisplayList_unique(self_: *const SkDeferredDisplayList) -> bool;
}
extern "C" {
    pub fn C_SkDrawable_Deserialize(
        data: *const ::core::ffi::c_void,
        length: usize,
    ) -> *mut SkDrawable;
}
extern "C" {
    pub fn C_SkDrawable_getBounds(self_: *mut SkDrawable) -> SkRect;
}
extern "C" {
    pub fn C_SkImageFilter_computeFastBounds(
        self_: *const SkImageFilter,
        bounds: *const SkRect,
    ) -> SkRect;
}
extern "C" {
    pub fn C_SkImageFilter_makeWithLocalMatrix(
        self_: *const SkImageFilter,
        matrix: *const SkMatrix,
    ) -> *mut SkImageFilter;
}
extern "C" {
    pub fn C_SkImageFilter_Deserialize(
        data: *const ::core::ffi::c_void,
        length: usize,
    ) -> *mut SkImageFilter;
}
extern "C" {
    pub fn C_SkImageFilter_filterBounds(
        self_: *const SkImageFilter,
        src: *const SkIRect,
        ctm: *const SkMatrix,
        mapDirection: SkImageFilter_MapDirection,
        inputRect: *const SkIRect,
    ) -> SkIRect;
}
extern "C" {
    pub fn C_SkImageFilter_isColorFilterNode(
        self_: *const SkImageFilter,
        filterPtr: *mut *mut SkColorFilter,
    ) -> bool;
}
extern "C" {
    pub fn C_SkImageFilter_countInputs(self_: *const SkImageFilter) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn C_SkImageFilter_getInput(
        self_: *const SkImageFilter,
        i: ::std::os::raw::c_int,
    ) -> *const SkImageFilter;
}
extern "C" {
    pub fn C_SkImageGenerator_delete(self_: *mut SkImageGenerator);
}
extern "C" {
    pub fn C_SkImageGenerator_refEncodedData(self_: *mut SkImageGenerator) -> *mut SkData;
}
extern "C" {
    pub fn C_SkImageGenerator_MakeFromEncoded(
        data: *mut SkData,
        alphaType: *const SkAlphaType,
    ) -> *mut SkImageGenerator;
}
extern "C" {
    pub fn C_SkImageGenerator_MakeFromPicture(
        size: *const SkISize,
        picture: *mut SkPicture,
        matrix: *const SkMatrix,
        paint: *const SkPaint,
        bd: SkImage_BitDepth,
        cs: *mut SkColorSpace,
        props: *const SkSurfaceProps,
    ) -> *mut SkImageGenerator;
}
extern "C" {
    pub fn C_SkString_destruct(self_: *mut SkString);
}
extern "C" {
    pub fn C_SkString_c_str_size(
        self_: *const SkString,
        size: *mut usize,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn C_SkStrings_construct(
        uninitialized: *mut SkStrings,
        string: *mut SkString,
        count: usize,
    );
}
extern "C" {
    pub fn C_SkStrings_destruct(self_: *mut SkStrings);
}
extern "C" {
    pub fn C_SkStrings_ptr_count(self_: *const SkStrings, count: *mut usize) -> *const SkString;
}
extern "C" {
    pub fn C_string_view_ptr_size(
        self_: *const std_string_view,
        size: *mut usize,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn C_string_ptr_size(
        self_: *const std_string,
        size: *mut usize,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn C_SkStrokeRec_destruct(self_: *mut SkStrokeRec);
}
extern "C" {
    pub fn C_SkStrokeRec_copy(self_: *const SkStrokeRec, other: *mut SkStrokeRec);
}
extern "C" {
    pub fn C_SkStrokeRec_getCap(self_: *const SkStrokeRec) -> SkPaint_Cap;
}
extern "C" {
    pub fn C_SkStrokeRec_getJoin(self_: *const SkStrokeRec) -> SkPaint_Join;
}
extern "C" {
    pub fn C_SkStrokeRec_hasEqualEffect(
        self_: *const SkStrokeRec,
        other: *const SkStrokeRec,
    ) -> bool;
}
extern "C" {
    pub fn C_SkPathEffect_MakeSum(
        first: *mut SkPathEffect,
        second: *mut SkPathEffect,
    ) -> *mut SkPathEffect;
}
extern "C" {
    pub fn C_SkPathEffect_MakeCompose(
        outer: *mut SkPathEffect,
        inner: *mut SkPathEffect,
    ) -> *mut SkPathEffect;
}
extern "C" {
    pub fn C_SkPathEffect_DashInfo_Construct(uninitialized: *mut SkPathEffect_DashInfo);
}
extern "C" {
    pub fn C_SkPathEffect_Deserialize(
        data: *const ::core::ffi::c_void,
        length: usize,
    ) -> *mut SkPathEffect;
}
extern "C" {
    pub fn C_SkPixmap_destruct(self_: *mut SkPixmap);
}
extern "C" {
    pub fn C_SkPixmap_setColorSpace(self_: *mut SkPixmap, colorSpace: *mut SkColorSpace);
}
extern "C" {
    pub fn C_SkMaskFilter_MakeBlur(
        style: SkBlurStyle,
        sigma: SkScalar,
        respectCTM: bool,
    ) -> *mut SkMaskFilter;
}
extern "C" {
    pub fn C_SkMaskFilter_Deserialize(
        data: *const ::core::ffi::c_void,
        length: usize,
    ) -> *mut SkMaskFilter;
}
extern "C" {
    pub fn C_SkSize_toRound(size: *const SkSize) -> SkISize;
}
extern "C" {
    pub fn C_SkSize_toCeil(size: *const SkSize) -> SkISize;
}
extern "C" {
    pub fn C_SkSize_toFloor(size: *const SkSize) -> SkISize;
}
extern "C" {
    pub fn C_SkShader_isOpaque(self_: *const SkShader) -> bool;
}
extern "C" {
    pub fn C_SkShader_isAImage(self_: *const SkShader) -> bool;
}
extern "C" {
    pub fn C_SkShader_asAGradient(
        self_: *const SkShader,
        info: *mut SkShader_GradientInfo,
    ) -> SkShader_GradientType;
}
extern "C" {
    pub fn C_SkShader_makeWithLocalMatrix(
        self_: *const SkShader,
        matrix: *const SkMatrix,
    ) -> *mut SkShader;
}
extern "C" {
    pub fn C_SkShader_makeWithColorFilter(
        self_: *const SkShader,
        colorFilter: *mut SkColorFilter,
    ) -> *mut SkShader;
}
extern "C" {
    pub fn C_SkShaders_Empty() -> *mut SkShader;
}
extern "C" {
    pub fn C_SkShaders_Color(color: SkColor) -> *mut SkShader;
}
extern "C" {
    pub fn C_SkShaders_Color2(
        color: *const SkColor4f,
        colorSpace: *mut SkColorSpace,
    ) -> *mut SkShader;
}
extern "C" {
    pub fn C_SkShaders_Blend(
        blender: *mut SkBlender,
        dst: *mut SkShader,
        src: *mut SkShader,
    ) -> *mut SkShader;
}
extern "C" {
    pub fn C_SkShader_Deserialize(data: *const ::core::ffi::c_void, length: usize)
        -> *mut SkShader;
}
extern "C" {
    pub fn C_SkStream_delete(stream: *mut SkStream);
}
extern "C" {
    pub fn C_SkStream_read(
        stream: *mut SkStream,
        buffer: *mut ::core::ffi::c_void,
        len: usize,
    ) -> usize;
}
extern "C" {
    pub fn C_SkStreamAsset_getLength(self_: *const SkStreamAsset) -> usize;
}
extern "C" {
    pub fn C_SkWStream_destruct(self_: *mut SkWStream);
}
extern "C" {
    pub fn C_SkWStream_write(
        self_: *mut SkWStream,
        buffer: *const ::core::ffi::c_void,
        size: usize,
    ) -> bool;
}
extern "C" {
    pub fn C_SkMemoryStream_MakeDirect(
        data: *const ::core::ffi::c_void,
        length: usize,
    ) -> *mut SkMemoryStream;
}
extern "C" {
    pub fn C_SkDynamicMemoryWStream_Construct(uninitialized: *mut SkDynamicMemoryWStream);
}
extern "C" {
    pub fn C_SkDynamicMemoryWStream_detachAsData(self_: *mut SkDynamicMemoryWStream)
        -> *mut SkData;
}
extern "C" {
    pub fn C_SkDynamicMemoryWStream_detachAsStream(
        self_: *mut SkDynamicMemoryWStream,
    ) -> *mut SkStreamAsset;
}
extern "C" {
    pub fn C_SkYUVAInfo_Construct(uninitialized: *mut SkYUVAInfo);
}
extern "C" {
    pub fn C_SkYUVAInfo_destruct(self_: *mut SkYUVAInfo);
}
extern "C" {
    pub fn C_SkYUVAInfo_SubsamplingFactors(
        subsampling: SkYUVAInfo_Subsampling,
        factors: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn C_SkYUVAInfo_PlaneSubsamplingFactors(
        planeConfig: SkYUVAInfo_PlaneConfig,
        subsampling: SkYUVAInfo_Subsampling,
        planeIdx: ::std::os::raw::c_int,
        factors: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn C_SkYUVAInfo_NumPlanes(planeConfig: SkYUVAInfo_PlaneConfig) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn C_SkYUVAInfo_NumChannelsInPlane(
        planarConfig: SkYUVAInfo_PlaneConfig,
        i: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn C_SkYUVAInfo_equals(a: *const SkYUVAInfo, b: *const SkYUVAInfo) -> bool;
}
extern "C" {
    pub fn C_SkYUVAInfo_makeSubsampling(
        self_: *const SkYUVAInfo,
        subsampling: SkYUVAInfo_Subsampling,
        uninitialized: *mut SkYUVAInfo,
    );
}
extern "C" {
    pub fn C_SkYUVAInfo_makeDimensions(
        self_: *const SkYUVAInfo,
        dimensions: *const SkISize,
        uninitialized: *mut SkYUVAInfo,
    );
}
extern "C" {
    pub fn C_SkYUVAPixmapInfo_Construct(uninitialized: *mut SkYUVAPixmapInfo);
}
extern "C" {
    pub fn C_SkYUVAPixmapInfo_destruct(self_: *mut SkYUVAPixmapInfo);
}
extern "C" {
    pub fn C_SkYUVAPixmapInfo_equals(
        a: *const SkYUVAPixmapInfo,
        b: *const SkYUVAPixmapInfo,
    ) -> bool;
}
extern "C" {
    pub fn C_SkYUVAPixmapInfo_rowBytes(
        self_: *const SkYUVAPixmapInfo,
        i: ::std::os::raw::c_int,
    ) -> usize;
}
extern "C" {
    pub fn C_SkYUVAPixmapInfo_planeInfo(
        self_: *const SkYUVAPixmapInfo,
        i: ::std::os::raw::c_int,
    ) -> *const SkImageInfo;
}
extern "C" {
    pub fn C_SkYUVAPixmapInfo_isValid(self_: *const SkYUVAPixmapInfo) -> bool;
}
extern "C" {
    pub fn C_SkYUVAPixmapInfo_SupportedDataTypes_Construct(
        uninitialized: *mut SkYUVAPixmapInfo_SupportedDataTypes,
    );
}
extern "C" {
    pub fn C_SkYUVAPixmapInfo_SupportedDataTypes_destruct(
        self_: *mut SkYUVAPixmapInfo_SupportedDataTypes,
    );
}
extern "C" {
    pub fn C_SkYUVAPixmapInfo_SupportedDataTypes_All(
        uninitialized: *mut SkYUVAPixmapInfo_SupportedDataTypes,
    );
}
extern "C" {
    pub fn C_SkYUVAPixmapInfo_SupportedDataTypes_supported(
        self_: *const SkYUVAPixmapInfo_SupportedDataTypes,
        pc: SkYUVAPixmapInfo_PlaneConfig,
        dt: SkYUVAPixmapInfo_DataType,
    ) -> bool;
}
extern "C" {
    pub fn C_SkYUVAPixmapInfo_DefaultColorTypeForDataType(
        dt: SkYUVAPixmapInfo_DataType,
        numChannels: ::std::os::raw::c_int,
    ) -> SkColorType;
}
extern "C" {
    pub fn C_SkYUVAPixmapInfo_NumChannelsAndDataType(
        colorType: SkColorType,
        dataType: *mut SkYUVAPixmapInfo_DataType,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn C_SkYUVAPixmaps_Construct(uninitialized: *mut SkYUVAPixmaps);
}
extern "C" {
    pub fn C_SkYUVAPixmaps_destruct(self_: *mut SkYUVAPixmaps);
}
extern "C" {
    pub fn C_SkYUVAPixmaps_MakeCopy(self_: *const SkYUVAPixmaps, uninitialized: *mut SkYUVAPixmaps);
}
extern "C" {
    pub fn C_SkYUVAPixmaps_Allocate(
        uninitialized: *mut SkYUVAPixmaps,
        yuvaPixmapInfo: *const SkYUVAPixmapInfo,
    );
}
extern "C" {
    pub fn C_SkYUVAPixmaps_FromData(
        uninitialized: *mut SkYUVAPixmaps,
        yuvaPixmapInfo: *const SkYUVAPixmapInfo,
        data: *mut SkData,
    );
}
extern "C" {
    pub fn C_SkYUVAPixmaps_FromExternalMemory(
        uninitialized: *mut SkYUVAPixmaps,
        yuvaPixmapInfo: *const SkYUVAPixmapInfo,
        memory: *mut ::core::ffi::c_void,
    );
}
extern "C" {
    pub fn C_SkYUVAPixmaps_FromExternalPixmaps(
        uninitialized: *mut SkYUVAPixmaps,
        yuvaInfo: *const SkYUVAInfo,
        pixmaps: *const SkPixmap,
    );
}
extern "C" {
    pub fn C_SkYUVAPixmaps_pixmapsInfo(
        self_: *const SkYUVAPixmaps,
        uninitialized: *mut SkYUVAPixmapInfo,
    );
}
extern "C" {
    pub fn C_SkYUVAPixmaps_planes(self_: *const SkYUVAPixmaps) -> *const SkPixmap;
}
extern "C" {
    pub fn C_SkYUVAPixmaps_isValid(self_: *const SkYUVAPixmaps) -> bool;
}
extern "C" {
    pub fn C_Effects_Types(arg1: *mut SkTableMaskFilter);
}
extern "C" {
    pub fn C_SkBlenders_Arithmetic(
        k1: f32,
        k2: f32,
        k3: f32,
        k4: f32,
        enforcePremul: bool,
    ) -> *mut SkBlender;
}
extern "C" {
    pub fn C_SkGradientShader_Types(arg1: *mut SkGradientShader);
}
extern "C" {
    pub fn C_SkGradientShader_MakeLinear(
        pts: *const SkPoint,
        colors: *const SkColor,
        pos: *const SkScalar,
        count: ::std::os::raw::c_int,
        mode: SkTileMode,
        flags: u32,
        localMatrix: *const SkMatrix,
    ) -> *mut SkShader;
}
extern "C" {
    pub fn C_SkGradientShader_MakeLinear2(
        pts: *const SkPoint,
        colors: *const SkColor4f,
        colorSpace: *mut SkColorSpace,
        pos: *const SkScalar,
        count: ::std::os::raw::c_int,
        mode: SkTileMode,
        flags: u32,
        localMatrix: *const SkMatrix,
    ) -> *mut SkShader;
}
extern "C" {
    pub fn C_SkGradientShader_MakeRadial(
        center: *const SkPoint,
        radius: SkScalar,
        colors: *const SkColor,
        pos: *const SkScalar,
        count: ::std::os::raw::c_int,
        mode: SkTileMode,
        flags: u32,
        localMatrix: *const SkMatrix,
    ) -> *mut SkShader;
}
extern "C" {
    pub fn C_SkGradientShader_MakeRadial2(
        center: *const SkPoint,
        radius: SkScalar,
        colors: *const SkColor4f,
        colorSpace: *mut SkColorSpace,
        pos: *const SkScalar,
        count: ::std::os::raw::c_int,
        mode: SkTileMode,
        flags: u32,
        localMatrix: *const SkMatrix,
    ) -> *mut SkShader;
}
extern "C" {
    pub fn C_SkGradientShader_MakeTwoPointConical(
        start: *const SkPoint,
        startRadius: SkScalar,
        end: *const SkPoint,
        endRadius: SkScalar,
        colors: *const SkColor,
        pos: *const SkScalar,
        count: ::std::os::raw::c_int,
        mode: SkTileMode,
        flags: u32,
        localMatrix: *const SkMatrix,
    ) -> *mut SkShader;
}
extern "C" {
    pub fn C_SkGradientShader_MakeTwoPointConical2(
        start: *const SkPoint,
        startRadius: SkScalar,
        end: *const SkPoint,
        endRadius: SkScalar,
        colors: *const SkColor4f,
        colorSpace: *mut SkColorSpace,
        pos: *const SkScalar,
        count: ::std::os::raw::c_int,
        mode: SkTileMode,
        flags: u32,
        localMatrix: *const SkMatrix,
    ) -> *mut SkShader;
}
extern "C" {
    pub fn C_SkGradientShader_MakeSweep(
        cx: SkScalar,
        cy: SkScalar,
        colors: *const SkColor,
        pos: *const SkScalar,
        count: ::std::os::raw::c_int,
        mode: SkTileMode,
        startAngle: SkScalar,
        endAngle: SkScalar,
        flags: u32,
        localMatrix: *const SkMatrix,
    ) -> *mut SkShader;
}
extern "C" {
    pub fn C_SkGradientShader_MakeSweep2(
        cx: SkScalar,
        cy: SkScalar,
        colors: *const SkColor4f,
        colorSpace: *mut SkColorSpace,
        pos: *const SkScalar,
        count: ::std::os::raw::c_int,
        mode: SkTileMode,
        startAngle: SkScalar,
        endAngle: SkScalar,
        flags: u32,
        localMatrix: *const SkMatrix,
    ) -> *mut SkShader;
}
extern "C" {
    pub fn C_SkPerlinNoiseShader_MakeFractalNoise(
        baseFrequencyX: SkScalar,
        baseFrequencyY: SkScalar,
        numOctaves: ::std::os::raw::c_int,
        seed: SkScalar,
        tileSize: *const SkISize,
    ) -> *mut SkShader;
}
extern "C" {
    pub fn C_SkPerlinNoiseShader_MakeTurbulence(
        baseFrequencyX: SkScalar,
        baseFrequencyY: SkScalar,
        numOctaves: ::std::os::raw::c_int,
        seed: SkScalar,
        tileSize: *const SkISize,
    ) -> *mut SkShader;
}
extern "C" {
    pub fn C_SkPath1DPathEffect_Make(
        path: *const SkPath,
        advance: SkScalar,
        phase: SkScalar,
        style: SkPath1DPathEffect_Style,
    ) -> *mut SkPathEffect;
}
extern "C" {
    pub fn C_SkLine2DPathEffect_Make(width: SkScalar, matrix: *const SkMatrix)
        -> *mut SkPathEffect;
}
extern "C" {
    pub fn C_SkPath2DPathEffect_Make(
        matrix: *const SkMatrix,
        path: *const SkPath,
    ) -> *mut SkPathEffect;
}
extern "C" {
    pub fn C_SkColorMatrix_Construct(uninitialized: *mut SkColorMatrix);
}
extern "C" {
    pub fn C_SkColorMatrix_Construct2(
        uninitialized: *mut SkColorMatrix,
        m00: f32,
        m01: f32,
        m02: f32,
        m03: f32,
        m04: f32,
        m10: f32,
        m11: f32,
        m12: f32,
        m13: f32,
        m14: f32,
        m20: f32,
        m21: f32,
        m22: f32,
        m23: f32,
        m24: f32,
        m30: f32,
        m31: f32,
        m32: f32,
        m33: f32,
        m34: f32,
    );
}
extern "C" {
    pub fn C_SkColorMatrix_setRowMajor(self_: *mut SkColorMatrix, src: *const f32);
}
extern "C" {
    pub fn C_SkColorMatrix_getRowMajor(self_: *const SkColorMatrix, dst: *mut f32);
}
extern "C" {
    pub fn C_SkColorMatrixFilter_MakeLightingFilter(
        mul: SkColor,
        add: SkColor,
    ) -> *mut SkColorFilter;
}
extern "C" {
    pub fn C_SkCornerPathEffect_Make(radius: SkScalar) -> *mut SkPathEffect;
}
extern "C" {
    pub fn C_SkDashPathEffect_Make(
        intervals: *const SkScalar,
        count: ::std::os::raw::c_int,
        phase: SkScalar,
    ) -> *mut SkPathEffect;
}
extern "C" {
    pub fn C_SkDiscretePathEffect_Make(
        segLength: SkScalar,
        dev: SkScalar,
        seedAssist: u32,
    ) -> *mut SkPathEffect;
}
extern "C" {
    pub fn C_SkHighContrastFilter_Make(config: *const SkHighContrastConfig) -> *mut SkColorFilter;
}
extern "C" {
    pub fn C_SkLumaColorFilter_Make() -> *mut SkColorFilter;
}
extern "C" {
    pub fn C_SkMergePathEffect_Make(
        one: *mut SkPathEffect,
        two: *mut SkPathEffect,
        op: SkPathOp,
    ) -> *mut SkPathEffect;
}
extern "C" {
    pub fn C_SkMatrixPathEffect_MakeTranslate(dx: SkScalar, dy: SkScalar) -> *mut SkPathEffect;
}
extern "C" {
    pub fn C_SkMatrixPathEffect_Make(m: *const SkMatrix) -> *mut SkPathEffect;
}
extern "C" {
    pub fn C_SkStrokePathEffect_Make(
        width: SkScalar,
        join: SkPaint_Join,
        cap: SkPaint_Cap,
        miter: SkScalar,
    ) -> *mut SkPathEffect;
}
extern "C" {
    pub fn C_SkOverdrawColorFilter_MakeWithSkColors(colors: *const SkColor) -> *mut SkColorFilter;
}
extern "C" {
    pub fn C_SkRuntimeEffect_MakeForColorFilter(
        sksl: *const SkString,
        options: *const SkRuntimeEffect_Options,
        error: *mut SkString,
    ) -> *mut SkRuntimeEffect;
}
extern "C" {
    pub fn C_SkRuntimeEffect_MakeForShader(
        sksl: *const SkString,
        options: *const SkRuntimeEffect_Options,
        error: *mut SkString,
    ) -> *mut SkRuntimeEffect;
}
extern "C" {
    pub fn C_SkRuntimeEffect_MakeForBlender(
        sksl: *const SkString,
        options: *const SkRuntimeEffect_Options,
        error: *mut SkString,
    ) -> *mut SkRuntimeEffect;
}
extern "C" {
    pub fn C_SkRuntimeEffect_makeShader(
        self_: *const SkRuntimeEffect,
        uniforms: *const SkData,
        children: *mut SkRuntimeEffect_ChildPtr,
        childCount: usize,
        localMatrix: *const SkMatrix,
    ) -> *mut SkShader;
}
extern "C" {
    pub fn C_SkRuntimeEffect_makeImage(
        self_: *const SkRuntimeEffect,
        context: *mut GrRecordingContext,
        uniforms: *const SkData,
        children: *mut SkRuntimeEffect_ChildPtr,
        childCount: usize,
        localMatrix: *const SkMatrix,
        resultInfo: *const SkImageInfo,
        mipmapped: bool,
    ) -> *mut SkImage;
}
extern "C" {
    pub fn C_SkRuntimeEffect_makeColorFilter(
        self_: *const SkRuntimeEffect,
        inputs: *const SkData,
        children: *mut SkRuntimeEffect_ChildPtr,
        childCount: usize,
    ) -> *mut SkColorFilter;
}
extern "C" {
    pub fn C_SkRuntimeEffect_makeBlender(
        self_: *const SkRuntimeEffect,
        uniforms: *const SkData,
        children: *mut SkRuntimeEffect_ChildPtr,
        childCount: usize,
    ) -> *mut SkBlender;
}
extern "C" {
    pub fn C_SkRuntimeEffect_source(
        self_: *const SkRuntimeEffect,
        len: *mut usize,
    ) -> *const ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn C_SkRuntimeEffect_uniforms(
        self_: *const SkRuntimeEffect,
        count: *mut usize,
    ) -> *const SkRuntimeEffect_Uniform;
}
extern "C" {
    pub fn C_SkRuntimeEffect_children(
        self_: *const SkRuntimeEffect,
        count: *mut usize,
    ) -> *const SkRuntimeEffect_Child;
}
extern "C" {
    pub fn C_SkRuntimeEffect_findUniform(
        self_: *const SkRuntimeEffect,
        name: *const ::std::os::raw::c_char,
        count: usize,
    ) -> *const SkRuntimeEffect_Uniform;
}
extern "C" {
    pub fn C_SkRuntimeEffect_findChild(
        self_: *const SkRuntimeEffect,
        name: *const ::std::os::raw::c_char,
        count: usize,
    ) -> *const SkRuntimeEffect_Child;
}
extern "C" {
    pub fn C_SkRuntimeEffect_allowShader(self_: *const SkRuntimeEffect) -> bool;
}
extern "C" {
    pub fn C_SkRuntimeEffect_allowColorFilter(self_: *const SkRuntimeEffect) -> bool;
}
extern "C" {
    pub fn C_SkRuntimeEffect_allowBlender(self_: *const SkRuntimeEffect) -> bool;
}
extern "C" {
    pub fn C_SkShaderMaskFilter_Make(shader: *mut SkShader) -> *mut SkMaskFilter;
}
extern "C" {
    pub fn C_SkStrokeAndFillePathEffect_Make() -> *mut SkPathEffect;
}
extern "C" {
    pub fn C_SkTableColorFilter_Make(table: *const u8) -> *mut SkColorFilter;
}
extern "C" {
    pub fn C_SkTableColorFilter_MakeARGB(
        tableA: *const u8,
        tableR: *const u8,
        tableG: *const u8,
        tableB: *const u8,
    ) -> *mut SkColorFilter;
}
extern "C" {
    pub fn C_SkTrimPathEffect_Make(
        startT: SkScalar,
        stopT: SkScalar,
        mode: SkTrimPathEffect_Mode,
    ) -> *mut SkPathEffect;
}
extern "C" {
    pub fn C_SkImageFilters_AlphaThreshold(
        region: *const SkRegion,
        innerMin: SkScalar,
        outerMax: SkScalar,
        input: *mut SkImageFilter,
        cropRect: *const SkImageFilters_CropRect,
    ) -> *mut SkImageFilter;
}
extern "C" {
    pub fn C_SkImageFilters_Arithmetic(
        k1: f32,
        k2: f32,
        k3: f32,
        k4: f32,
        enforcePMColor: bool,
        background: *mut SkImageFilter,
        foreground: *mut SkImageFilter,
        cropRect: *const SkImageFilters_CropRect,
    ) -> *mut SkImageFilter;
}
extern "C" {
    pub fn C_SkImageFilters_Blend(
        blender: *mut SkBlender,
        background: *mut SkImageFilter,
        foreground: *mut SkImageFilter,
        cropRect: *const SkImageFilters_CropRect,
    ) -> *mut SkImageFilter;
}
extern "C" {
    pub fn C_SkImageFilters_Blur(
        sigmaX: SkScalar,
        sigmaY: SkScalar,
        tileMode: SkTileMode,
        input: *mut SkImageFilter,
        cropRect: *const SkImageFilters_CropRect,
    ) -> *mut SkImageFilter;
}
extern "C" {
    pub fn C_SkImageFilters_ColorFilter(
        cf: *mut SkColorFilter,
        input: *mut SkImageFilter,
        cropRect: *const SkImageFilters_CropRect,
    ) -> *mut SkImageFilter;
}
extern "C" {
    pub fn C_SkImageFilters_Compose(
        outer: *mut SkImageFilter,
        inner: *mut SkImageFilter,
    ) -> *mut SkImageFilter;
}
extern "C" {
    pub fn C_SkImageFilters_DisplacementMap(
        xChannelSelector: SkColorChannel,
        yChannelSelector: SkColorChannel,
        scale: SkScalar,
        displacement: *mut SkImageFilter,
        color: *mut SkImageFilter,
        cropRect: *const SkImageFilters_CropRect,
    ) -> *mut SkImageFilter;
}
extern "C" {
    pub fn C_SkImageFilters_DropShadow(
        dx: SkScalar,
        dy: SkScalar,
        sigmaX: SkScalar,
        sigmaY: SkScalar,
        color: SkColor,
        input: *mut SkImageFilter,
        cropRect: *const SkImageFilters_CropRect,
    ) -> *mut SkImageFilter;
}
extern "C" {
    pub fn C_SkImageFilters_DropShadowOnly(
        dx: SkScalar,
        dy: SkScalar,
        sigmaX: SkScalar,
        sigmaY: SkScalar,
        color: SkColor,
        input: *mut SkImageFilter,
        cropRect: *const SkImageFilters_CropRect,
    ) -> *mut SkImageFilter;
}
extern "C" {
    pub fn C_SkImageFilters_Image(
        image: *mut SkImage,
        srcRect: *const SkRect,
        dstRect: *const SkRect,
        sampling: *const SkSamplingOptions,
    ) -> *mut SkImageFilter;
}
extern "C" {
    pub fn C_SkImageFilters_Magnifier(
        srcRect: *const SkRect,
        inset: SkScalar,
        input: *mut SkImageFilter,
        cropRect: *const SkImageFilters_CropRect,
    ) -> *mut SkImageFilter;
}
extern "C" {
    pub fn C_SkImageFilters_MatrixConvolution(
        kernelSize: *const SkISize,
        kernel: *const SkScalar,
        gain: SkScalar,
        bias: SkScalar,
        kernelOffset: *const SkIPoint,
        tileMode: SkTileMode,
        convolveAlpha: bool,
        input: *mut SkImageFilter,
        cropRect: *const SkImageFilters_CropRect,
    ) -> *mut SkImageFilter;
}
extern "C" {
    pub fn C_SkImageFilters_MatrixTransform(
        matrix: *const SkMatrix,
        sampling: *const SkSamplingOptions,
        input: *mut SkImageFilter,
    ) -> *mut SkImageFilter;
}
extern "C" {
    pub fn C_SkImageFilters_Merge(
        filters: *const *mut SkImageFilter,
        count: ::std::os::raw::c_int,
        cropRect: *const SkImageFilters_CropRect,
    ) -> *mut SkImageFilter;
}
extern "C" {
    pub fn C_SkImageFilters_Offset(
        dx: SkScalar,
        dy: SkScalar,
        input: *mut SkImageFilter,
        cropRect: *const SkImageFilters_CropRect,
    ) -> *mut SkImageFilter;
}
extern "C" {
    pub fn C_SkImageFilters_Paint(
        paint: *const SkPaint,
        cropRect: *const SkImageFilters_CropRect,
    ) -> *mut SkImageFilter;
}
extern "C" {
    pub fn C_SkImageFilters_Picture(
        pic: *mut SkPicture,
        targetRect: *const SkRect,
    ) -> *mut SkImageFilter;
}
extern "C" {
    pub fn C_SkImageFilters_Shader(
        shader: *mut SkShader,
        dither: SkImageFilters_Dither,
        cropRect: *const SkImageFilters_CropRect,
    ) -> *mut SkImageFilter;
}
extern "C" {
    pub fn C_SkImageFilters_Tile(
        src: *const SkRect,
        dst: *const SkRect,
        input: *mut SkImageFilter,
    ) -> *mut SkImageFilter;
}
extern "C" {
    pub fn C_SkImageFilters_Dilate(
        radiusX: SkScalar,
        radiusY: SkScalar,
        input: *mut SkImageFilter,
        cropRect: *const SkImageFilters_CropRect,
    ) -> *mut SkImageFilter;
}
extern "C" {
    pub fn C_SkImageFilters_Erode(
        radiusX: SkScalar,
        radiusY: SkScalar,
        input: *mut SkImageFilter,
        cropRect: *const SkImageFilters_CropRect,
    ) -> *mut SkImageFilter;
}
extern "C" {
    pub fn C_SkImageFilters_DistantLitDiffuse(
        direction: *const SkPoint3,
        lightColor: SkColor,
        surfaceScale: SkScalar,
        kd: SkScalar,
        input: *mut SkImageFilter,
        cropRect: *const SkImageFilters_CropRect,
    ) -> *mut SkImageFilter;
}
extern "C" {
    pub fn C_SkImageFilters_PointLitDiffuse(
        direction: *const SkPoint3,
        lightColor: SkColor,
        surfaceScale: SkScalar,
        kd: SkScalar,
        input: *mut SkImageFilter,
        cropRect: *const SkImageFilters_CropRect,
    ) -> *mut SkImageFilter;
}
extern "C" {
    pub fn C_SkImageFilters_SpotLitDiffuse(
        location: *const SkPoint3,
        target: *const SkPoint3,
        specularExponent: SkScalar,
        cutoffAngle: SkScalar,
        lightColor: SkColor,
        surfaceScale: SkScalar,
        kd: SkScalar,
        input: *mut SkImageFilter,
        cropRect: *const SkImageFilters_CropRect,
    ) -> *mut SkImageFilter;
}
extern "C" {
    pub fn C_ImageFilters_DistantLitSpecular(
        direction: *const SkPoint3,
        lightColor: SkColor,
        surfaceScale: SkScalar,
        ks: SkScalar,
        shininess: SkScalar,
        input: *mut SkImageFilter,
        cropRect: *const SkImageFilters_CropRect,
    ) -> *mut SkImageFilter;
}
extern "C" {
    pub fn C_SkImageFilters_PointLitSpecular(
        location: *const SkPoint3,
        lightColor: SkColor,
        surfaceScale: SkScalar,
        ks: SkScalar,
        shininess: SkScalar,
        input: *mut SkImageFilter,
        cropRect: *const SkImageFilters_CropRect,
    ) -> *mut SkImageFilter;
}
extern "C" {
    pub fn C_SkImageFilters_SpotLitSpecular(
        location: *const SkPoint3,
        target: *const SkPoint3,
        specularExponent: SkScalar,
        cutoffAngle: SkScalar,
        lightColor: SkColor,
        surfaceScale: SkScalar,
        ks: SkScalar,
        shininess: SkScalar,
        input: *mut SkImageFilter,
        cropRect: *const SkImageFilters_CropRect,
    ) -> *mut SkImageFilter;
}
extern "C" {
    pub fn C_SkPDF_AttributeList_destruct(self_: *mut SkPDF_AttributeList);
}
extern "C" {
    pub fn C_SkPDF_AttributeList_appendFloatArray(
        self_: *mut SkPDF_AttributeList,
        owner: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        value: *const f32,
        len: usize,
    );
}
extern "C" {
    pub fn C_SkPDF_StructureElementNode_New() -> *mut SkPDF_StructureElementNode;
}
extern "C" {
    pub fn C_SkPDF_StructureElementNode_delete(self_: *mut SkPDF_StructureElementNode);
}
extern "C" {
    pub fn C_SkPDF_StructureElementNode_setChildVector(
        self_: *mut SkPDF_StructureElementNode,
        nodes: *mut *mut SkPDF_StructureElementNode,
        len: usize,
    );
}
extern "C" {
    pub fn C_SkPDF_StructElementNode_appendChild(
        self_: *mut SkPDF_StructureElementNode,
        node: *mut SkPDF_StructureElementNode,
    );
}
extern "C" {
    pub fn C_SkPDF_StructureElementNode_getChildVector(
        self_: *const SkPDF_StructureElementNode,
        nodes: *mut *mut SkPDF_StructureElementNode,
    ) -> usize;
}
extern "C" {
    pub fn C_SkPDF_Metadata_Construct(uninitialized: *mut SkPDF_Metadata);
}
extern "C" {
    pub fn C_SkPDF_Metadata_destruct(self_: *mut SkPDF_Metadata);
}
extern "C" {
    pub fn C_SkPDF_MakeDocument(
        stream: *mut SkWStream,
        metadata: *const SkPDF_Metadata,
    ) -> *mut SkDocument;
}
extern "C" {
    pub fn C_SkOpBuilder_Construct(uninitialized: *mut SkOpBuilder);
}
extern "C" {
    pub fn C_SkOpBuilder_destruct(self_: *mut SkOpBuilder);
}
extern "C" {
    pub fn C_SVG_Types(arg1: *mut SkSVGCanvas);
}
extern "C" {
    pub fn C_SkSVGCanvas_Make(
        bounds: *const SkRect,
        writer: *mut SkWStream,
        flags: u32,
    ) -> *mut SkCanvas;
}
extern "C" {
    pub fn C_Utils_Types(
        arg1: *mut SkShadowFlags,
        arg2: *mut SkShadowUtils,
        arg3: *mut SkTextUtils,
        arg4: *mut SkParsePath,
        arg5: *mut SkCustomTypefaceBuilder,
    );
}
extern "C" {
    pub fn C_Sk3DView_new() -> *mut Sk3DView;
}
extern "C" {
    pub fn C_Sk3DView_delete(self_: *mut Sk3DView);
}
extern "C" {
    pub fn C_SkCustomTypefaceBuilder_destruct(self_: *mut SkCustomTypefaceBuilder);
}
extern "C" {
    pub fn C_SkCustomTypefaceBuilder_detach(self_: *mut SkCustomTypefaceBuilder)
        -> *mut SkTypeface;
}
extern "C" {
    pub fn C_SkCustomTypefaceBuilder_setGlyph(
        self_: *mut SkCustomTypefaceBuilder,
        glyph: SkGlyphID,
        advance: f32,
        drawable: *mut SkDrawable,
        bounds: *const SkRect,
    );
}
extern "C" {
    pub fn C_SkMakeNullCanvas() -> *mut SkCanvas;
}
extern "C" {
    pub fn C_SkOrderedFontMgr_new() -> *mut SkOrderedFontMgr;
}
extern "C" {
    pub fn C_SkOrderedFontMgr_append(self_: *mut SkOrderedFontMgr, fontMgr: *mut SkFontMgr);
}
#[repr(C)]
#[derive(Debug)]
pub struct RustStream {
    pub _base: SkStream,
    pub m_data: *mut ::core::ffi::c_void,
    pub m_length: usize,
    pub m_isEof: bool,
    pub m_read: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: *mut ::core::ffi::c_void,
            arg3: usize,
        ) -> usize,
    >,
    pub m_seekAbsolute: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void, arg2: usize) -> bool,
    >,
    pub m_seekRelative: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void, arg2: ::std::os::raw::c_long) -> bool,
    >,
}
#[test]
fn bindgen_test_layout_RustStream() {
    assert_eq!(
        ::core::mem::size_of::<RustStream>(),
        56usize,
        concat!("Size of: ", stringify!(RustStream))
    );
    assert_eq!(
        ::core::mem::align_of::<RustStream>(),
        8usize,
        concat!("Alignment of ", stringify!(RustStream))
    );
    fn test_field_m_data() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<RustStream>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).m_data) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(RustStream),
                "::",
                stringify!(m_data)
            )
        );
    }
    test_field_m_data();
    fn test_field_m_length() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<RustStream>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).m_length) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(RustStream),
                "::",
                stringify!(m_length)
            )
        );
    }
    test_field_m_length();
    fn test_field_m_isEof() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<RustStream>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).m_isEof) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(RustStream),
                "::",
                stringify!(m_isEof)
            )
        );
    }
    test_field_m_isEof();
    fn test_field_m_read() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<RustStream>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).m_read) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(RustStream),
                "::",
                stringify!(m_read)
            )
        );
    }
    test_field_m_read();
    fn test_field_m_seekAbsolute() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<RustStream>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).m_seekAbsolute) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(RustStream),
                "::",
                stringify!(m_seekAbsolute)
            )
        );
    }
    test_field_m_seekAbsolute();
    fn test_field_m_seekRelative() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<RustStream>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).m_seekRelative) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(RustStream),
                "::",
                stringify!(m_seekRelative)
            )
        );
    }
    test_field_m_seekRelative();
}
extern "C" {
    #[link_name = "\u{1}__ZN10RustStreamC1EPvmPFmS0_S0_mEPFbS0_mEPFbS0_lE"]
    pub fn RustStream_RustStream(
        this: *mut RustStream,
        data: *mut ::core::ffi::c_void,
        length: usize,
        read: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::core::ffi::c_void,
                arg2: *mut ::core::ffi::c_void,
                arg3: usize,
            ) -> usize,
        >,
        seekAbsolute: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void, arg2: usize) -> bool,
        >,
        seekRelative: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::core::ffi::c_void,
                arg2: ::std::os::raw::c_long,
            ) -> bool,
        >,
    );
}
impl RustStream {
    #[inline]
    pub unsafe fn new(
        data: *mut ::core::ffi::c_void,
        length: usize,
        read: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::core::ffi::c_void,
                arg2: *mut ::core::ffi::c_void,
                arg3: usize,
            ) -> usize,
        >,
        seekAbsolute: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void, arg2: usize) -> bool,
        >,
        seekRelative: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::core::ffi::c_void,
                arg2: ::std::os::raw::c_long,
            ) -> bool,
        >,
    ) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        RustStream_RustStream(
            __bindgen_tmp.as_mut_ptr(),
            data,
            length,
            read,
            seekAbsolute,
            seekRelative,
        );
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}__ZN10RustStream4readEPvm"]
    pub fn RustStream_read(
        this: *mut ::core::ffi::c_void,
        buffer: *mut ::core::ffi::c_void,
        count: usize,
    ) -> usize;
}
extern "C" {
    #[link_name = "\u{1}__ZN10RustStream6rewindEv"]
    pub fn RustStream_rewind(this: *mut ::core::ffi::c_void) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN10RustStream4seekEm"]
    pub fn RustStream_seek(this: *mut ::core::ffi::c_void, pos: usize) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN10RustStream4moveEl"]
    pub fn RustStream_move(this: *mut ::core::ffi::c_void, offset: ::std::os::raw::c_long) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK10RustStream7isAtEndEv"]
    pub fn RustStream_isAtEnd(this: *mut ::core::ffi::c_void) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK10RustStream9hasLengthEv"]
    pub fn RustStream_hasLength(this: *mut ::core::ffi::c_void) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZNK10RustStream9getLengthEv"]
    pub fn RustStream_getLength(this: *mut ::core::ffi::c_void) -> usize;
}
extern "C" {
    pub fn C_RustStream_construct(
        out: *mut RustStream,
        data: *mut ::core::ffi::c_void,
        length: usize,
        read: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::core::ffi::c_void,
                arg2: *mut ::core::ffi::c_void,
                arg3: usize,
            ) -> usize,
        >,
        seekAbsolute: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void, arg2: usize) -> bool,
        >,
        seekRelative: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::core::ffi::c_void,
                arg2: ::std::os::raw::c_long,
            ) -> bool,
        >,
    );
}
extern "C" {
    pub fn C_RustStream_destruct(stream: *mut RustStream);
}
pub type __builtin_va_list = *mut ::std::os::raw::c_char;
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_char_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_basic_string_view_open0_char_std_char_traits_open1_char_close1_close0_instantiation(
) {
    assert_eq!(
        ::core::mem::size_of::<std_basic_string_view<::std::os::raw::c_char>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_string_view<::std::os::raw::c_char>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_basic_string_view<::std::os::raw::c_char>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_string_view<::std::os::raw::c_char>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char_close0_instantiation_1() {
    assert_eq!(
        ::core::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkString_Rec_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkString_Rec>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkString_Rec>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkString_Rec>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkString_Rec>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkString_Rec_close0_instantiation_1() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkString_Rec>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkString_Rec>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkString_Rec>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkString_Rec>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_SkString_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_1() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_2() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_3() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_4() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_5() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_6() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_7() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_8() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_9() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_10() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_11() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_12() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
}
#[test]
fn __bindgen_test_layout_SkNVRefCnt_open0_SkData_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<SkNVRefCnt>(),
        4usize,
        concat!("Size of template specialization: ", stringify!(SkNVRefCnt))
    );
    assert_eq!(
        ::core::mem::align_of::<SkNVRefCnt>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(SkNVRefCnt)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_1() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_2() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_3() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_4() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_5() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_6() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_7() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_8() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_9() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_10() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_11() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char_close0_instantiation_2() {
    assert_eq!(
        ::core::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_char_close0_instantiation_1() {
    assert_eq!(
        ::core::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_12() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_13() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_SkNVRefCnt_open0_SkColorSpace_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<SkNVRefCnt>(),
        4usize,
        concat!("Size of template specialization: ", stringify!(SkNVRefCnt))
    );
    assert_eq!(
        ::core::mem::align_of::<SkNVRefCnt>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(SkNVRefCnt)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_13() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_14() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_15() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_16() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_17() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_18() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_19() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_14() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_20() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_15() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkEncodedInfo_ICCProfile_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkEncodedInfo_ICCProfile_close0_instantiation_1()
{
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_16() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkEncodedInfo_ICCProfile_close0_instantiation_2()
{
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkStream_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkCodec_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_17() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkCodec_close0_instantiation_1() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_1() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkStream_close0_instantiation_1() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkCodec_close0_instantiation_2() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkStream_close0_instantiation_2() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkStream_close0_instantiation_3() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation_1() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorFilter_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorFilter>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorFilter>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorFilter>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorFilter>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorFilter_close0_instantiation_1() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorFilter>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorFilter>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorFilter>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorFilter>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkBlender_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkBlender>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkBlender>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkBlender>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkBlender>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkBlender_close0_instantiation_1() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkBlender>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkBlender>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkBlender>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkBlender>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkPathEffect_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkPathEffect>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkPathEffect>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkPathEffect>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkPathEffect>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkPathEffect_close0_instantiation_1() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkPathEffect>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkPathEffect>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkPathEffect>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkPathEffect>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkMaskFilter_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkMaskFilter>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkMaskFilter>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkMaskFilter>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkMaskFilter>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkMaskFilter_close0_instantiation_1() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkMaskFilter>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkMaskFilter>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkMaskFilter>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkMaskFilter>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkImageFilter_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkImageFilter>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkImageFilter>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkImageFilter>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkImageFilter>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkImageFilter_close0_instantiation_1() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkImageFilter>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkImageFilter>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkImageFilter>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkImageFilter>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkPathEffect_close0_instantiation_2() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkPathEffect>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkPathEffect>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkPathEffect>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkPathEffect>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation_2() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkMaskFilter_close0_instantiation_2() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkMaskFilter>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkMaskFilter>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkMaskFilter>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkMaskFilter>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorFilter_close0_instantiation_2() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorFilter>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorFilter>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorFilter>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorFilter>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkImageFilter_close0_instantiation_2() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkImageFilter>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkImageFilter>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkImageFilter>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkImageFilter>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkBlender_close0_instantiation_2() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkBlender>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkBlender>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkBlender>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkBlender>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkRasterHandleAllocator_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkCanvas_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkCanvas_close0_instantiation_1() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkBaseDevice_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkBaseDevice>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkBaseDevice>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkBaseDevice>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkBaseDevice>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkSurface_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkSurface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkSurface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkSurface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkSurface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation_3() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_2() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_3() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_4() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkVertices_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkVertices>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkVertices>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkVertices>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkVertices>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkBlender_close0_instantiation_3() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkBlender>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkBlender>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkBlender>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkBlender>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkSurface_close0_instantiation_1() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkSurface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkSurface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkSurface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkSurface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkBlender_close0_instantiation_4() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkBlender>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkBlender>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkBlender>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkBlender>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation_4() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkBaseDevice_close0_instantiation_1() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkBaseDevice>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkBaseDevice>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkBaseDevice>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkBaseDevice>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkImageFilter_close0_instantiation_3() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkImageFilter>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkImageFilter>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkImageFilter>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkImageFilter>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkBaseDevice_close0_instantiation_2() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkBaseDevice>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkBaseDevice>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkBaseDevice>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkBaseDevice>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkImageFilter_close0_instantiation_4() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkImageFilter>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkImageFilter>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkImageFilter>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkImageFilter>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkSpecialImage_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkSpecialImage>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkSpecialImage>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkSpecialImage>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkSpecialImage>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkCanvas_Layer_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkCanvas_BackImage_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkBaseDevice_close0_instantiation_3() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkBaseDevice>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkBaseDevice>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkBaseDevice>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkBaseDevice>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkImageFilter_close0_instantiation_5() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkImageFilter>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkImageFilter>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkImageFilter>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkImageFilter>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkBaseDevice_close0_instantiation_4() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkBaseDevice>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkBaseDevice>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkBaseDevice>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkBaseDevice>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkRasterHandleAllocator_close0_instantiation_1() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_sktext_GlyphRunBuilder_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkFlattenable_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkFlattenable>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkFlattenable>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkFlattenable>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkFlattenable>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_18() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkFlattenable_close0_instantiation_1() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkFlattenable>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkFlattenable>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkFlattenable>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkFlattenable>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorFilter_close0_instantiation_3() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorFilter>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorFilter>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorFilter>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorFilter>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorFilter_close0_instantiation_4() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorFilter>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorFilter>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorFilter>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorFilter>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorFilter_close0_instantiation_5() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorFilter>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorFilter>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorFilter>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorFilter>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_19() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkPathRef_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkPathRef>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkPathRef>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkPathRef>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkPathRef>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkContourMeasure_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkContourMeasure>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkContourMeasure>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkContourMeasure>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkContourMeasure>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkContourMeasureIter_Impl_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkDataTable_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkDataTable>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkDataTable>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkDataTable>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkDataTable>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkDataTable_close0_instantiation_1() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkDataTable>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkDataTable>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkDataTable>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkDataTable>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkDataTable_close0_instantiation_2() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkDataTable>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkDataTable>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkDataTable>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkDataTable>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkDataTable_close0_instantiation_3() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkDataTable>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkDataTable>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkDataTable>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkDataTable>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation_5() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorFilter_close0_instantiation_6() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorFilter>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorFilter>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorFilter>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorFilter>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation_6() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_5() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_20() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_6() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_7() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_8() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkImageGenerator_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_9() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_21() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_10() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_22() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_11() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkPicture_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkPicture>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkPicture>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkPicture>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkPicture>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_21() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_12() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_22() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation_7() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation_8() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_23() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_23() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_24() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_25() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_13() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_14() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_15() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_16() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_17() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_24() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_18() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_25() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_19() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_26() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_20() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkDeferredDisplayList_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkDeferredDisplayList>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkDeferredDisplayList>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkDeferredDisplayList>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkDeferredDisplayList>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_1() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_2() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkStreamAsset_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_3() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_26() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_4() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_5() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_27() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_6() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_28() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkStreamAsset_close0_instantiation_1() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkStreamAsset_close0_instantiation_2() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_7() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkStreamAsset_close0_instantiation_3() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkStreamAsset_close0_instantiation_4() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_29() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_8() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_9() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_10() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_11() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_float_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_12() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_30() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_13() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkStreamAsset_close0_instantiation_5() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_14() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkStreamAsset_close0_instantiation_6() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_15() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_16() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_17() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkFontMgr_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkFontMgr>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkFontMgr>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkFontMgr>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkFontMgr>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_31() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_18() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkStreamAsset_close0_instantiation_7() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_19() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkStreamAsset_close0_instantiation_8() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_20() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_21() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_22() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_32() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkImageGenerator_close0_instantiation_1() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkImageFilter_close0_instantiation_6() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkImageFilter>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkImageFilter>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkImageFilter>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkImageFilter>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_27() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkPixelRef_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkPixelRef>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkPixelRef>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkPixelRef>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkPixelRef>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation_9() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_21() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkPixelRef_close0_instantiation_1() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkPixelRef>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkPixelRef>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkPixelRef>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkPixelRef>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkMipmap_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkMipmap>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkMipmap>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkMipmap>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkMipmap>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_33() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkImageGenerator_close0_instantiation_2() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkPicture_close0_instantiation_1() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkPicture>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkPicture>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkPicture>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkPicture>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_28() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkImageGenerator_close0_instantiation_3() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkMaskFilter_close0_instantiation_3() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkMaskFilter>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkMaskFilter>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkMaskFilter>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkMaskFilter>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkMaskFilter_close0_instantiation_4() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkMaskFilter>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkMaskFilter>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkMaskFilter>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkMaskFilter>)
        )
    );
}
#[test]
fn __bindgen_test_layout_SkTDArray_open0_SkPoint_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<SkTDArray<SkPoint>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(SkTDArray<SkPoint>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<SkTDArray<SkPoint>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(SkTDArray<SkPoint>)
        )
    );
}
#[test]
fn __bindgen_test_layout_SkTDArray_open0_uint8_t_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<SkTDArray<u8>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(SkTDArray<u8>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<SkTDArray<u8>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(SkTDArray<u8>)
        )
    );
}
#[test]
fn __bindgen_test_layout_SkTDArray_open0_SkScalar_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<SkTDArray<SkScalar>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(SkTDArray<SkScalar>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<SkTDArray<SkScalar>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(SkTDArray<SkScalar>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkContourMeasure_close0_instantiation_1() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkContourMeasure>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkContourMeasure>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkContourMeasure>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkContourMeasure>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkPicture_close0_instantiation_2() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkPicture>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkPicture>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkPicture>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkPicture>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkPicture_close0_instantiation_3() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkPicture>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkPicture>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkPicture>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkPicture>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkPicture_close0_instantiation_4() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkPicture>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkPicture>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkPicture>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkPicture>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_34() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkPicture_close0_instantiation_5() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkPicture>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkPicture>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkPicture>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkPicture>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation_10() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_int_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkBBoxHierarchy_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkBBoxHierarchy>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkBBoxHierarchy>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkBBoxHierarchy>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkBBoxHierarchy>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkPicture_close0_instantiation_6() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkPicture>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkPicture>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkPicture>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkPicture>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkPicture_close0_instantiation_7() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkPicture>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkPicture>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkPicture>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkPicture>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkDrawable_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkDrawable>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkDrawable>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkDrawable>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkDrawable>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkBBoxHierarchy_close0_instantiation_1() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkBBoxHierarchy>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkBBoxHierarchy>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkBBoxHierarchy>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkBBoxHierarchy>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkRecorder_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkRecord_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkRecord>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkRecord>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkRecord>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkRecord>)
        )
    );
}
#[test]
fn __bindgen_test_layout_SkTDArray_open0_ptr_SkIDChangeListener_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<SkTDArray<*mut SkIDChangeListener>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(SkTDArray<*mut SkIDChangeListener>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<SkTDArray<*mut SkIDChangeListener>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(SkTDArray<*mut SkIDChangeListener>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkStreamAsset_close0_instantiation_9() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_35() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkMemoryStream_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkMemoryStream_close0_instantiation_1() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_36() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkMemoryStream_close0_instantiation_2() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_37() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_38() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_39() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkStreamAsset_close0_instantiation_10() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkSurface_close0_instantiation_2() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkSurface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkSurface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkSurface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkSurface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkSurface_close0_instantiation_3() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkSurface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkSurface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkSurface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkSurface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkSurface_close0_instantiation_4() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkSurface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkSurface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkSurface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkSurface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkSurface_close0_instantiation_5() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkSurface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkSurface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkSurface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkSurface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkSurface_close0_instantiation_6() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkSurface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkSurface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkSurface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkSurface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkSurface_close0_instantiation_7() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkSurface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkSurface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkSurface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkSurface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkSurface_close0_instantiation_8() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkSurface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkSurface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkSurface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkSurface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkSurface_close0_instantiation_9() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkSurface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkSurface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkSurface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkSurface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_22() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_23() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_29() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkDeferredDisplayList_close0_instantiation_1() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkDeferredDisplayList>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkDeferredDisplayList>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkDeferredDisplayList>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkDeferredDisplayList>)
        )
    );
}
#[test]
fn __bindgen_test_layout_SkNVRefCnt_open0_SkTextBlob_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<SkNVRefCnt>(),
        4usize,
        concat!("Size of template specialization: ", stringify!(SkNVRefCnt))
    );
    assert_eq!(
        ::core::mem::align_of::<SkNVRefCnt>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(SkNVRefCnt)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkTextBlob_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkTextBlob>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkTextBlob>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkTextBlob>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkTextBlob>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkTextBlob_close0_instantiation_1() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkTextBlob>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkTextBlob>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkTextBlob>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkTextBlob>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkTextBlob_close0_instantiation_2() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkTextBlob>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkTextBlob>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkTextBlob>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkTextBlob>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkTextBlob_close0_instantiation_3() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkTextBlob>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkTextBlob>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkTextBlob>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkTextBlob>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_40() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkTextBlob_close0_instantiation_4() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkTextBlob>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkTextBlob>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkTextBlob>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkTextBlob>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkTextBlob_close0_instantiation_5() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkTextBlob>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkTextBlob>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkTextBlob>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkTextBlob>)
        )
    );
}
#[test]
fn __bindgen_test_layout_SkNVRefCnt_open0_SkVertices_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<SkNVRefCnt>(),
        4usize,
        concat!("Size of template specialization: ", stringify!(SkNVRefCnt))
    );
    assert_eq!(
        ::core::mem::align_of::<SkNVRefCnt>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(SkNVRefCnt)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkVertices_close0_instantiation_1() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkVertices>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkVertices>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkVertices>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkVertices>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkVertices_close0_instantiation_2() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkVertices>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkVertices>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkVertices>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkVertices>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkVertices_close0_instantiation_3() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkVertices>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkVertices>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkVertices>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkVertices>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_float_close0_instantiation_1() {
    assert_eq!(
        ::core::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_int_close0_instantiation_1() {
    assert_eq!(
        ::core::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkPDFArray_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkPDF_StructureElementNode_close0_instantiation()
{
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_std_unique_ptr_open1_SkPDF_StructureElementNode_std_default_delete_open2_SkPDF_StructureElementNode_close2_close1_close0_instantiation(
) {
    assert_eq!(
        ::core::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkPDF_StructureElementNode_close0_instantiation_1(
) {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_int_close0_instantiation_2() {
    assert_eq!(
        ::core::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkPathEffect_close0_instantiation_3() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkPathEffect>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkPathEffect>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkPathEffect>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkPathEffect>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkPathEffect_close0_instantiation_4() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkPathEffect>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkPathEffect>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkPathEffect>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkPathEffect>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkPathEffect_close0_instantiation_5() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkPathEffect>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkPathEffect>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkPathEffect>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkPathEffect>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkPathEffect_close0_instantiation_6() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkPathEffect>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkPathEffect>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkPathEffect>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkPathEffect>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkPathEffect_close0_instantiation_7() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkPathEffect>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkPathEffect>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkPathEffect>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkPathEffect>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkPathEffect_close0_instantiation_8() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkPathEffect>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkPathEffect>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkPathEffect>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkPathEffect>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkPathEffect_close0_instantiation_9() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkPathEffect>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkPathEffect>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkPathEffect>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkPathEffect>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkBlender_close0_instantiation_5() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkBlender>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkBlender>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkBlender>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkBlender>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation_11() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_30() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation_12() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_31() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation_13() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation_14() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_32() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation_15() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_33() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation_16() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation_17() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_34() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation_18() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_35() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation_19() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation_20() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_36() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation_21() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_37() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation_22() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_38() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorSpace>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorSpace>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation_23() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkRuntimeEffect_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkRuntimeEffect>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkRuntimeEffect>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkRuntimeEffect>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkRuntimeEffect>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkFlattenable_close0_instantiation_2() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkFlattenable>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkFlattenable>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkFlattenable>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkFlattenable>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkFlattenable_close0_instantiation_3() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkFlattenable>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkFlattenable>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkFlattenable>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkFlattenable>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_41() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation_24() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation_25() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_42() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_SkSpan_open0_SkRuntimeEffect_ChildPtr_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<SkSpan<SkRuntimeEffect_ChildPtr>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(SkSpan<SkRuntimeEffect_ChildPtr>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<SkSpan<SkRuntimeEffect_ChildPtr>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(SkSpan<SkRuntimeEffect_ChildPtr>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation_26() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_43() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_SkSpan_open0_SkRuntimeEffect_ChildPtr_close0_instantiation_1() {
    assert_eq!(
        ::core::mem::size_of::<SkSpan<SkRuntimeEffect_ChildPtr>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(SkSpan<SkRuntimeEffect_ChildPtr>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<SkSpan<SkRuntimeEffect_ChildPtr>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(SkSpan<SkRuntimeEffect_ChildPtr>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_24() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkImage>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkImage>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_44() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorFilter_close0_instantiation_7() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorFilter>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorFilter>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorFilter>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorFilter>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_45() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorFilter_close0_instantiation_8() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorFilter>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorFilter>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorFilter>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorFilter>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorFilter_close0_instantiation_9() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorFilter>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorFilter>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorFilter>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorFilter>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_46() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_SkSpan_open0_SkRuntimeEffect_ChildPtr_close0_instantiation_2() {
    assert_eq!(
        ::core::mem::size_of::<SkSpan<SkRuntimeEffect_ChildPtr>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(SkSpan<SkRuntimeEffect_ChildPtr>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<SkSpan<SkRuntimeEffect_ChildPtr>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(SkSpan<SkRuntimeEffect_ChildPtr>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkColorFilter_close0_instantiation_10() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkColorFilter>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkColorFilter>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkColorFilter>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkColorFilter>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_47() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_SkSpan_open0_SkRuntimeEffect_ChildPtr_close0_instantiation_3() {
    assert_eq!(
        ::core::mem::size_of::<SkSpan<SkRuntimeEffect_ChildPtr>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(SkSpan<SkRuntimeEffect_ChildPtr>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<SkSpan<SkRuntimeEffect_ChildPtr>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(SkSpan<SkRuntimeEffect_ChildPtr>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkBlender_close0_instantiation_6() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkBlender>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkBlender>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkBlender>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkBlender>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation_27() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkSL_DebugTrace_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkSL_DebugTrace>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkSL_DebugTrace>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkSL_DebugTrace>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkSL_DebugTrace>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation_28() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkShader>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkShader>)
        )
    );
}
#[test]
fn __bindgen_test_layout_SkTDArray_open0_SkPathOp_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<SkTDArray<SkPathOp>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(SkTDArray<SkPathOp>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<SkTDArray<SkPathOp>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(SkTDArray<SkPathOp>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkCanvas_close0_instantiation_2() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkDrawable_close0_instantiation_1() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkDrawable>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkDrawable>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkDrawable>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkDrawable>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_23() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkDrawable_close0_instantiation_2() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkDrawable>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkDrawable>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkDrawable>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkDrawable>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_SkCustomTypefaceBuilder_GlyphRec_close0_instantiation()
{
    assert_eq!(
        ::core::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkFontMgr_close0_instantiation_1() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkFontMgr>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkFontMgr>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkFontMgr>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkFontMgr>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_48() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_24() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkStreamAsset_close0_instantiation_11() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_25() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_SkStreamAsset_close0_instantiation_12() {
    assert_eq!(
        ::core::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_26() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_27() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_28() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkTypeface>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkTypeface>)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkFontMgr_close0_instantiation_2() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkFontMgr>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkFontMgr>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkFontMgr>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkFontMgr>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_sk_sp_open1_SkFontMgr_close1_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_sk_sp_open0_SkFontMgr_close0_instantiation_3() {
    assert_eq!(
        ::core::mem::size_of::<sk_sp<SkFontMgr>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(sk_sp<SkFontMgr>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sk_sp<SkFontMgr>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(sk_sp<SkFontMgr>)
        )
    );
}
#[test]
fn __bindgen_test_layout_VecSink_open0_SkScalar_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<VecSink<SkScalar>>(),
        24usize,
        concat!(
            "Size of template specialization: ",
            stringify!(VecSink<SkScalar>)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<VecSink<SkScalar>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(VecSink<SkScalar>)
        )
    );
}
